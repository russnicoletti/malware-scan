package com.symphony.malware.scan.connector.config;

import static com.symphony.malware.scan.connector.config.MalwareScanContainerConnectorConfigProvider.ConnectionRequestType;
import static com.symphony.malware.scan.connector.config.MalwareScanContainerConnectorConfigProvider.ConnectionRequestType.MALWARE_SCAN;
import static org.assertj.core.api.Assertions.assertThat;
import static org.awaitility.Awaitility.await;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.atLeast;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.google.common.collect.ImmutableMap;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;

import java.util.Arrays;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanContainerConnectorConfigProviderTest {

  private static final long CONFIG_CACHE_RELOAD_IN_MILLIS = 50;

  private static final String MALWARE_SCAN_ID = "malware-scan-id";

  private static final int MALWARE_SCAN_SERVICE_CALL_TIMEOUT_IN_MILLIS = 1000;

  private static final int DEFAULT_SERVICE_CALL_TIMEOUT_IN_MILLIS = 60000;

  private static final String TENANT_ID = "tenantId";

  @Mock
  private MalwareScanContainerConnectorConfigRepository malwareScanContainerConnectorConfigRepository;

  @Test
  public void getContainerConnectorConfig() {
    // Use .thenAnswer() here, as we need to make sure that consistent answer is being returned for every periodic repository reload
    when(malwareScanContainerConnectorConfigRepository.findByConnectionRequestType(any(ConnectionRequestType.class)))
        .thenAnswer(new Answer<Optional<MalwareScanContainerConnectorConfigEntity>>() {
          private final Map<ConnectionRequestType, MalwareScanContainerConnectorConfigEntity> answers = ImmutableMap.of(
              MALWARE_SCAN, new MalwareScanContainerConnectorConfigEntity().setId(MALWARE_SCAN_ID)
                  .setConnectionRequestType(MALWARE_SCAN).setServiceCallTimeoutInMillis(MALWARE_SCAN_SERVICE_CALL_TIMEOUT_IN_MILLIS)
          );

          @Override
          public Optional<MalwareScanContainerConnectorConfigEntity> answer(final InvocationOnMock invocationOnMock) throws Throwable {
            return Arrays.stream(invocationOnMock.getArguments()).filter(ConnectionRequestType.class::isInstance)
                .map(ConnectionRequestType.class::cast).map(answers::get).findFirst();
          }
        });

    final MalwareScanContainerConnectorConfigProvider malwareScanContainerConnectorConfigProvider =
        new MalwareScanContainerConnectorConfigProvider(CONFIG_CACHE_RELOAD_IN_MILLIS, malwareScanContainerConnectorConfigRepository);

    assertThat(malwareScanContainerConnectorConfigProvider.getContainerConnectorConfig(MALWARE_SCAN, TENANT_ID)
        .getConnectionRequestType()).isEqualTo(MALWARE_SCAN);
    assertThat(malwareScanContainerConnectorConfigProvider.getContainerConnectorConfig(MALWARE_SCAN, TENANT_ID)
        .getServiceCallTimeoutInMillis()).isEqualTo(MALWARE_SCAN_SERVICE_CALL_TIMEOUT_IN_MILLIS);

    // Make sure repository is pulled periodically, means called more that once
    await().atMost(3, TimeUnit.SECONDS).ignoreExceptions()
        .untilAsserted(() -> verify(malwareScanContainerConnectorConfigRepository, atLeast(1)).findByConnectionRequestType(any(ConnectionRequestType.class)));
  }

  @Test
  public void getContainerConnectorConfig_configNotFound_defaultConfigReturned() {
    // Use .thenAnswer() here, as we need to make sure that consistent answer is being returned for every periodic repository reload
    when(malwareScanContainerConnectorConfigRepository.findByConnectionRequestType(any(ConnectionRequestType.class)))
        .thenAnswer(invocationOnMock -> Optional.empty());

    final MalwareScanContainerConnectorConfigProvider malwareScanContainerConnectorConfigProvider =
        new MalwareScanContainerConnectorConfigProvider(CONFIG_CACHE_RELOAD_IN_MILLIS, malwareScanContainerConnectorConfigRepository);

    assertThat(malwareScanContainerConnectorConfigProvider.getContainerConnectorConfig(MALWARE_SCAN, TENANT_ID)
        .getConnectionRequestType()).isEqualTo(MALWARE_SCAN);
    assertThat(malwareScanContainerConnectorConfigProvider.getContainerConnectorConfig(MALWARE_SCAN, TENANT_ID)
        .getServiceCallTimeoutInMillis()).isEqualTo(DEFAULT_SERVICE_CALL_TIMEOUT_IN_MILLIS);

    // Make sure repository is pulled periodically, means called more that once
    await().atMost(3, TimeUnit.SECONDS).ignoreExceptions()
        .untilAsserted(() -> verify(malwareScanContainerConnectorConfigRepository, atLeast(2)).findByConnectionRequestType(any(ConnectionRequestType.class)));
  }

  @Test
  public void getContainerConnectorConfig_exceptionThrown_defaultConfigReturned() {
    // Use .thenAnswer() here, as we need to make sure that consistent answer is being returned for every periodic repository reload
    when(malwareScanContainerConnectorConfigRepository.findByConnectionRequestType(any(ConnectionRequestType.class)))
        .thenAnswer(invocationOnMock -> {
          throw new RuntimeException();
        });

    final MalwareScanContainerConnectorConfigProvider malwareScanContainerConnectorConfigProvider =
        new MalwareScanContainerConnectorConfigProvider(CONFIG_CACHE_RELOAD_IN_MILLIS, malwareScanContainerConnectorConfigRepository);

    assertThat(malwareScanContainerConnectorConfigProvider.getContainerConnectorConfig(MALWARE_SCAN, TENANT_ID)
        .getConnectionRequestType()).isEqualTo(MALWARE_SCAN);
    assertThat(malwareScanContainerConnectorConfigProvider.getContainerConnectorConfig(MALWARE_SCAN, TENANT_ID)
        .getServiceCallTimeoutInMillis()).isEqualTo(DEFAULT_SERVICE_CALL_TIMEOUT_IN_MILLIS);

    // Make sure repository is pulled periodically, means called more that once
    await().atMost(3, TimeUnit.SECONDS).ignoreExceptions()
        .untilAsserted(() -> verify(malwareScanContainerConnectorConfigRepository, atLeast(2)).findByConnectionRequestType(any(ConnectionRequestType.class)));
  }
}
