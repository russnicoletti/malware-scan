import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.eq;

import com.symphony.circuitbreaker.CommandConfig;
import com.symphony.dlp.efsymproxyconnector.ConnectionIdUsageScenario;
import com.symphony.dlp.efsymproxyconnector.ContainerConnector;
import com.symphony.dlp.efsymproxyconnector.ContainerResponse;
import com.symphony.dlp.efsymproxyconnector.ContainerServiceException;
import com.symphony.dlp.efsymproxyconnector.ContainerServiceUnavailableException;
import com.symphony.dlp.efsymproxyconnector.connectorconfig.ContainerConnectorConfiguration;
import com.symphony.dlp.efsymproxyconnector.metric.SymproxMetricReportCache;
import com.symphony.dlp.symproxy.operation.OperationRequest;
import com.symphony.malwarescan.MalwareScanOperationImpl;
import com.symphony.malwarescan.MalwareScanResponse;
import com.symphony.malwarescan.Status;
import com.symphony.msgpack.internal.types.Attachment;
import com.symphony.msgpack.internal.types.SocialMessage;
import com.symphony.msgpack.user.User;
import com.symphony.proto320.Descriptors;
import com.symphony.proto320.Message;
import com.symphony.remoteservice.longpoll.RemoteServiceMetric;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;
import com.symphony.remoteservice.longpoll.client.TimedOutException;
import com.symphony.services.rlp.RLP;

import com.google.common.base.Optional;
import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Matchers;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

/**
 * Created by sergii.oliinyk
 */
public class MalwareScanOperationServiceTest {

  private static final String SYMRPOXY_CONNECTION =
      "~dlp.SymProxyForAttachments~dlp.SymProxy~dlp.LoggerService~dlp"
          + ".SymproxyOperationService~:5b3272f8b9d82100013333b5";
  private static final long ID = 1L;
  private static final String DEV_1 = "Dev1";
  private static final String SURNAME = "Pro";
  private static final String COMPANY = "Symphony";
  private static final String EMAIL = "dev1@symphony.com";
  private static final String ATTACHMENT_1 = "Attachment1";
  private static final long CREATOR_ID = 777L;
  private static final String CONTENT_TYPE = "docx";
  private static final int SIZE = 35678888;

  @InjectMocks
  private MalwareScanOperationImpl malwareOperationService;

  @Mock
  protected ContainerConnector connector;

  @Mock
  private SymproxMetricReportCache metricReportCache;

  @Mock
  private ContainerConnectorConfiguration connectorConfiguration;


  @Before
  public void setup() {
    MockitoAnnotations.initMocks(this);
    HashSet<String> symproxyConections = new HashSet<>();
    symproxyConections.add(SYMRPOXY_CONNECTION);
    Mockito.when(connector.getConnectionIds()).thenReturn(symproxyConections);
  }


  @Test
  public void malwareScanningPositiveTest()
      throws TimedOutException, ContainerServiceException, ContainerServiceUnavailableException {
    RLP.ResponseHeader rspHeader =
        RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.OK).build();
    MalwareScanResponse mockResponse =
        MalwareScanResponse.newBuilder().setStatus(Status.OK).build();
    getContainerResponse(rspHeader, mockResponse);

    SocialMessage socialMessage = new SocialMessage();
    List<Attachment> attachments = new ArrayList<>();
    Attachment attachment = createAttachment(Thread.currentThread().toString(), ATTACHMENT_1,
        CREATOR_ID, CONTENT_TYPE, false, SIZE);
    attachments.add(attachment);
    socialMessage.setAttachments(attachments);
    socialMessage.setFromPod(1);
    socialMessage.setActualIngestionDate(DateTime.now().toDateTime().getMillis());
    socialMessage.setThreadId(Thread.currentThread().toString().getBytes());
    User user = getUser(ID, DEV_1, SURNAME, COMPANY, EMAIL);
    socialMessage.setActualFromUser(user);
    List<MalwareScanResponse> malwareScanRespons = getMalwareScanResponse();
    for (MalwareScanResponse rs : malwareScanRespons) {
      assertEquals(rs.getStatus(), Status.OK);
    }
  }

  @Test
  public void malwareScanningNegativeTest()
      throws TimedOutException, ContainerServiceException, ContainerServiceUnavailableException {
    RLP.ResponseHeader rspHeader =
        RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.ERROR).build();
    MalwareScanResponse mockResponse =
        MalwareScanResponse.newBuilder().setStatus(Status.FAILED).build();
    getContainerResponse(rspHeader, mockResponse);

    List<MalwareScanResponse> malwareScanRespons = getMalwareScanResponse();
    for (MalwareScanResponse rs : malwareScanRespons) {
      assertEquals(rs.getStatus(), Status.FAILED);
    }
  }

  private List<MalwareScanResponse> getMalwareScanResponse() {
    SocialMessage socialMessage = new SocialMessage();
    List<Attachment> attachments = new ArrayList<>();
    Attachment attachment = createAttachment(Thread.currentThread().toString(), ATTACHMENT_1,
        CREATOR_ID, CONTENT_TYPE, false, SIZE);
    attachments.add(attachment);
    socialMessage.setAttachments(attachments);
    socialMessage.setFromPod(1);
    socialMessage.setActualIngestionDate(DateTime.now().toDateTime().getMillis());
    socialMessage.setThreadId(Thread.currentThread().toString().getBytes());
    User user = getUser(ID, DEV_1, SURNAME, COMPANY, EMAIL);
    socialMessage.setActualFromUser(user);
    return malwareOperationService.scan(socialMessage);
  }

  private void getContainerResponse(RLP.ResponseHeader rspHeader, MalwareScanResponse mockResponse)
      throws TimedOutException,
      ContainerServiceUnavailableException,
      ContainerServiceException {
    ContainerResponse containerResponse = new ContainerResponse(rspHeader, mockResponse);
    Mockito.when(connector.call(eq(ConnectionIdUsageScenario.VALID),
        eq(RLPUsageScenario.USE_SPECIFIC_CONNECTION_ID),
        Matchers.any(Descriptors.MethodDescriptor.class),
        Matchers.any(OperationRequest.class), Matchers.any(Message.class),
        Matchers.eq(Optional.absent()),
        Matchers.eq(Optional.absent()),
        Matchers.any(RemoteServiceMetric.class), Matchers.anyInt(),
        Matchers.any(CommandConfig.class))).thenReturn(
        containerResponse);
  }

  private Attachment createAttachment(String fieldID, String name, Long creatorId,
      String contentType,
      boolean blocked, long size) {
    Attachment attachment = new Attachment();
    attachment.setFileId(fieldID);
    attachment.setName(name);
    attachment.setCreatorId(creatorId);
    attachment.setContentType(contentType);
    attachment.setBlocked(blocked);
    attachment.setSizeInBytes(size);
    return attachment;
  }

  private User getUser(long id, String firstName, String surname, String company, String email) {
    User user = new User();
    user.setId(id);
    user.setFirstName(firstName);
    user.setSurname(surname);
    user.setCompanyName(company);
    user.setEmail(email);
    return user;

  }
}
