package com.symphony.malware.scan.service;

import static junit.framework.TestCase.fail;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.codahale.metrics.Meter;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.metrics.MalwareScanningMetrics;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanFileMapping;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.model.User;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.persistence.service.MalwareScanPersistenceService;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import util.TimestampMillisSupplier;

import java.util.Optional;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanOperationPersistenceServiceTest {

    private static final String FILE_ID = "fileId";
    private static final Integer FROM_POD = 21;

    @Mock
    private MalwareScanPersistenceService malwareScanPersistenceService;

    @Mock
    private MalwareScanningMetrics malwareScanMetrics;

    @Mock
    private Meter countOfFailUpdateState;
    @Mock
    private Meter countOfFailCreateState;
    @Mock
    private TimestampMillisSupplier timestampMillisSupplier;

    private MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;

    @Before
    public void before() {
        when(malwareScanMetrics.countOfFailUpdateState()).thenReturn(countOfFailUpdateState);
        when(malwareScanMetrics.countOfFailCreateState()).thenReturn(countOfFailCreateState);
        this.malwareScanOperationPersistenceService = new MalwareScanOperationPersistenceService(malwareScanPersistenceService, malwareScanMetrics, timestampMillisSupplier);
    }

    @Test
    public void create_persistentException_fileMapping() throws Exception {
        doThrow(PersistentException.class).when(malwareScanPersistenceService).putMalwareScanFileMapping(any(MalwareScanFileMapping.class));

        try {
            malwareScanOperationPersistenceService.create(
                    MalwareScanRequestDto.builder().fromPod(FROM_POD).attachmentMetaDto(AttachmentMetaDto.builder().build()).build());
            fail("malwareScanOperationPersistenceService.create should have thrown a PersistentException");
        } catch (PersistentException e) {
            verify(malwareScanPersistenceService, times(0)).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));
        }
    }

    @Test
    public void create_malwareScanException_fileState() throws Exception {
        doThrow(MalwareScanException.class).when(malwareScanPersistenceService).putIfAbsent(any(MalwareScanFileState.class), any(Actor.class));

        try {
            malwareScanOperationPersistenceService.create(
                    MalwareScanRequestDto.builder().fromPod(FROM_POD).attachmentMetaDto(AttachmentMetaDto.builder().build()).build());
            fail("malwareScanOperationPersistenceService.create should have thrown a MalwareScanException");
        } catch (MalwareScanException e) {
            verify(countOfFailCreateState).mark();
            verify(malwareScanPersistenceService, never()).putMalwareScanFileMapping(any(MalwareScanFileMapping.class));
        }
    }

    @Test
    public void create_insertedState_success() throws Exception {
        final MalwareScanResponseDto malwareScanResponseDto = malwareScanOperationPersistenceService.create(
            MalwareScanRequestDto.builder()
                .fromPod(FROM_POD)
                .attachmentMetaDto(AttachmentMetaDto.builder().build())
                .user(User.builder()
                    .userId(1L).email("user@email.com").firstName("userName").lastName("userLastname")
                    .build())
                .build());

        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.SUCCESS);
        assertThat(malwareScanResponseDto.getError()).contains("");

        verify(malwareScanPersistenceService, times(1)).putMalwareScanFileMapping(any(MalwareScanFileMapping.class));
        verify(malwareScanPersistenceService, times(1)).putIfAbsent(any(MalwareScanFileState.class), eq(Actor.SYMPHONY));
    }

    @Test
    public void create_alreadyPresent_statePresent() throws Exception {
        MalwareScanFileState mockedState = mock(MalwareScanFileState.class);
        doReturn(mockedState).when(malwareScanPersistenceService)
            .putIfAbsent(any(MalwareScanFileState.class), eq(Actor.SYMPHONY));

        final MalwareScanResponseDto malwareScanResponseDto = malwareScanOperationPersistenceService.create(
            MalwareScanRequestDto.builder().fromPod(FROM_POD).attachmentMetaDto(AttachmentMetaDto.builder().build()).build());

        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.STATE_PRESENT);
        assertThat(malwareScanResponseDto.getError()).contains("");

        verify(malwareScanPersistenceService, times(1)).putMalwareScanFileMapping(any(MalwareScanFileMapping.class));
        verify(malwareScanPersistenceService, times(1)).putIfAbsent(any(MalwareScanFileState.class), eq(Actor.SYMPHONY));
    }

    @Test
    public void update_persistentException_failed() throws Exception {
        when(malwareScanPersistenceService.getMalwareScanFileState(FILE_ID)).thenReturn(Optional.of(MalwareScanFileState.builder().build()));
        doThrow(PersistentException.class).when(malwareScanPersistenceService).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));

        try {
            malwareScanOperationPersistenceService.update(
                    MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build(),
                    MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);
            fail("malwareScanOperationPersistenceService.update should have thrown a PersistentException");
        } catch (PersistentException e) {
            verify(countOfFailUpdateState).mark();
        }
    }

    @Test
    public void update_malwareScanUpdateException_failed() throws Exception {
        when(malwareScanPersistenceService.getMalwareScanFileState(FILE_ID)).thenReturn(Optional.of(MalwareScanFileState.builder().build()));
        doThrow(MalwareScanException.class).when(malwareScanPersistenceService).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));

        try {
            malwareScanOperationPersistenceService.update(
                    MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build(),
                    MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);
            fail("malwareScanOperationPersistenceService.update should have thrown a MalwareScanException");
        } catch (MalwareScanException e) {
            verify(countOfFailUpdateState).mark();
        }
    }

    @Test
    public void update_existingMalwareScanFileStateNotFound_failed() throws Exception {
        when(malwareScanPersistenceService.getMalwareScanFileState(FILE_ID)).thenReturn(Optional.empty());

        try {
            malwareScanOperationPersistenceService.update(
                    MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build(),
                    MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);
            fail("malwareScanOperationPersistenceService.update should have thrown a MalwareScanException");
        } catch (MalwareScanException e) {
            verify(malwareScanPersistenceService, times(0)).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));
            verify(countOfFailUpdateState).mark();
        }
    }

    @Test
    public void update_noException_ok() throws Exception {
        when(malwareScanPersistenceService.getMalwareScanFileState(FILE_ID)).thenReturn(Optional.of(MalwareScanFileState.builder().build()));

        final MalwareScanResponseDto malwareScanResponseDto = malwareScanOperationPersistenceService.update(
            MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build(),
            MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);

        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.SUCCESS);
        assertThat(malwareScanResponseDto.getError()).contains("");

        verify(malwareScanPersistenceService, times(1)).putMalwareScanFileState(any(MalwareScanFileState.class), eq(Actor.SYMPHONY));
    }

}
