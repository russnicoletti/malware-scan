package com.symphony.malware.scan.service;

import static junit.framework.TestCase.fail;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.codahale.metrics.Meter;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.metrics.MalwareScanningMetrics;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanFileMapping;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanFileStatusDetails;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.model.User;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.persistence.service.MalwareScanPersistenceService;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;
import util.TimestampMillisSupplier;

import java.util.Optional;

import javax.persistence.OptimisticLockException;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanOperationPersistenceServiceTest {

    private static final String FILE_ID = "fileId";
    private static final Integer FROM_POD = 21;
    private MalwareScanFileState pendingFileState;
    private MalwareScanFileState okFileState;
    private long pendingVersion = 1L;
    private long okVersion = 2L;

    @Mock
    private MalwareScanPersistenceService malwareScanPersistenceService;

    @Mock
    private MalwareScanningMetrics malwareScanMetrics;

    @Mock
    private Meter countOfFailUpdateState;
    @Mock
    private Meter countOfFailCreateState;
    @Mock
    private TimestampMillisSupplier timestampMillisSupplier;

    private MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;

    @Before
    public void before() {
        when(malwareScanMetrics.countOfFailUpdateState()).thenReturn(countOfFailUpdateState);
        when(malwareScanMetrics.countOfFailCreateState()).thenReturn(countOfFailCreateState);
        this.malwareScanOperationPersistenceService = new MalwareScanOperationPersistenceService(malwareScanPersistenceService, malwareScanMetrics, timestampMillisSupplier);
        pendingFileState = MalwareScanFileState.builder()
            .status(MalwareScanFileState.Status.PENDING)
            .fileId(FILE_ID)
            .version(pendingVersion)
            .build();
        okFileState = MalwareScanFileState.builder()
            .status(MalwareScanFileState.Status.OK)
            .fileId(FILE_ID)
            .version(okVersion)
            .build();
    }

    @Test
    public void create_persistentException_fileMapping() throws Exception {
        doThrow(PersistentException.class).when(malwareScanPersistenceService).putMalwareScanFileMapping(any(MalwareScanFileMapping.class));

        try {
            malwareScanOperationPersistenceService.create(
                    MalwareScanRequestDto.builder().fromPod(FROM_POD).attachmentMetaDto(AttachmentMetaDto.builder().build()).build());
            fail("malwareScanOperationPersistenceService.create should have thrown a PersistentException");
        } catch (PersistentException e) {
            verify(malwareScanPersistenceService, times(0)).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));
        }
    }

    @Test
    public void create_malwareScanException_fileState() throws Exception {
        doThrow(MalwareScanException.class).when(malwareScanPersistenceService).putIfAbsent(any(MalwareScanFileState.class), any(Actor.class));

        try {
            malwareScanOperationPersistenceService.create(
                    MalwareScanRequestDto.builder().fromPod(FROM_POD).attachmentMetaDto(AttachmentMetaDto.builder().build()).build());
            fail("malwareScanOperationPersistenceService.create should have thrown a MalwareScanException");
        } catch (MalwareScanException e) {
            verify(countOfFailCreateState).mark();
            verify(malwareScanPersistenceService, never()).putMalwareScanFileMapping(any(MalwareScanFileMapping.class));
        }
    }

    @Test
    public void create_insertedState_success() throws Exception {
        final MalwareScanResponseDto malwareScanResponseDto = malwareScanOperationPersistenceService.create(
            MalwareScanRequestDto.builder()
                .fromPod(FROM_POD)
                .attachmentMetaDto(AttachmentMetaDto.builder().build())
                .user(User.builder()
                    .userId(1L).email("user@email.com").firstName("userName").lastName("userLastname")
                    .build())
                .build());

        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.SUCCESS);
        assertThat(malwareScanResponseDto.getError()).contains("");

        verify(malwareScanPersistenceService, times(1)).putMalwareScanFileMapping(any(MalwareScanFileMapping.class));
        verify(malwareScanPersistenceService, times(1)).putIfAbsent(any(MalwareScanFileState.class), eq(Actor.SYMPHONY));
    }

    @Test
    public void create_alreadyPresent_statePresent() throws Exception {
        MalwareScanFileState mockedState = mock(MalwareScanFileState.class);
        doReturn(mockedState).when(malwareScanPersistenceService)
            .putIfAbsent(any(MalwareScanFileState.class), eq(Actor.SYMPHONY));

        final MalwareScanResponseDto malwareScanResponseDto = malwareScanOperationPersistenceService.create(
            MalwareScanRequestDto.builder().fromPod(FROM_POD).attachmentMetaDto(AttachmentMetaDto.builder().build()).build());

        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.STATE_PRESENT);
        assertThat(malwareScanResponseDto.getError()).contains("");

        verify(malwareScanPersistenceService, times(1)).putMalwareScanFileMapping(any(MalwareScanFileMapping.class));
        verify(malwareScanPersistenceService, times(1)).putIfAbsent(any(MalwareScanFileState.class), eq(Actor.SYMPHONY));
    }

    @Test
    public void update_persistentException_failed() throws Exception {
        when(malwareScanPersistenceService.getMalwareScanFileStateFromDb(FILE_ID)).thenReturn(Optional.of(MalwareScanFileState.builder().build()));
        doThrow(PersistentException.class).when(malwareScanPersistenceService).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));

        try {
            malwareScanOperationPersistenceService.updateScanStateFromWorkflow(
                    MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build(),
                    MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);
            fail("malwareScanOperationPersistenceService.update should have thrown a PersistentException");
        } catch (PersistentException e) {
            verify(countOfFailUpdateState).mark();
        }
    }

    @Test
    public void updateScanStateFromWorkflow_malwareScanUpdateException_failed() throws Exception {
        when(malwareScanPersistenceService.getMalwareScanFileStateFromDb(FILE_ID)).thenReturn(Optional.of(MalwareScanFileState.builder().build()));
        doThrow(MalwareScanException.class).when(malwareScanPersistenceService).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));

        try {
            malwareScanOperationPersistenceService.updateScanStateFromWorkflow(
                    MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build(),
                    MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);
            fail("malwareScanOperationPersistenceService.update should have thrown a MalwareScanException");
        } catch (MalwareScanException e) {
            verify(countOfFailUpdateState).mark();
        }
    }

    @Test
    public void updateScanStateFromWorkflow_existingMalwareScanFileStateNotFound_failed() throws Exception {
        when(malwareScanPersistenceService.getMalwareScanFileStateFromDb(FILE_ID)).thenReturn(Optional.empty());

        try {
            malwareScanOperationPersistenceService.updateScanStateFromWorkflow(
                    MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build(),
                    MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);
            fail("malwareScanOperationPersistenceService.update should have thrown a MalwareScanException");
        } catch (MalwareScanException e) {
            verify(malwareScanPersistenceService, times(0)).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));
            verify(countOfFailUpdateState).mark();
        }
    }

    @Test
    public void updateScanStateFromWorkflow_ok() throws Exception {
        when(malwareScanPersistenceService.getMalwareScanFileStateFromDb(FILE_ID)).thenReturn(
            Optional.of(MalwareScanFileState.builder().fileId(FILE_ID).build()));
        Long lastSubmissionAttemptTimestamp = 999L;
        when(timestampMillisSupplier.now()).thenReturn(lastSubmissionAttemptTimestamp);

        doAnswer(new Answer<Void>() {
            @Override
            public Void answer(final InvocationOnMock invocation) {
                final Object[] args = invocation.getArguments();
                MalwareScanFileState malwareScanFileState = (MalwareScanFileState)args[0];
                assertThat(malwareScanFileState.getFileId()).isEqualTo(FILE_ID);
                assertThat(malwareScanFileState.getLastSubmissionAttemptTimestamp()).isEqualTo(lastSubmissionAttemptTimestamp);
                assertThat(malwareScanFileState.getStatus()).isEqualTo(MalwareScanFileState.Status.SUBMITTED);

                Actor actor = (Actor)args[1];
                assertThat(actor).isEqualTo(Actor.SYMPHONY);
                return null;
            }
        }).when(malwareScanPersistenceService).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));

        final MalwareScanResponseDto malwareScanResponseDto = malwareScanOperationPersistenceService.updateScanStateFromWorkflow(
            MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build(),
            MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);

        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.SUCCESS);
        assertThat(malwareScanResponseDto.getError()).contains("");
    }

    @Test
    public void updateScanStateFromScanner_ok() throws Exception {
        final String detailsMessage = "detailsMessage";
        final String detailsUrlText = "detailsUrlText";
        final String detailsUrlLink = "detailsUrlLink";
        MalwareScanFileStatusDetails details = new MalwareScanFileStatusDetails(detailsMessage, detailsUrlText, detailsUrlLink);

        when(malwareScanPersistenceService.getMalwareScanFileStateFromDb(FILE_ID)).thenReturn(
            Optional.of(MalwareScanFileState.builder().fileId(FILE_ID).build()));

        doAnswer(new Answer<Void>() {
            @Override
            public Void answer(final InvocationOnMock invocation) {
                final Object[] args = invocation.getArguments();
                MalwareScanFileState malwareScanFileState = (MalwareScanFileState)args[0];
                assertThat(malwareScanFileState.getFileId()).isEqualTo(FILE_ID);
                assertThat(malwareScanFileState.getTtl()).isEqualTo(500L);
                assertThat(malwareScanFileState.getLastSubmissionAttemptTimestamp()).isEqualTo(null);
                assertThat(malwareScanFileState.getDetails().getMessage()).isEqualTo(detailsMessage);
                assertThat(malwareScanFileState.getDetails().getLink().getText()).isEqualTo(detailsUrlText);
                assertThat(malwareScanFileState.getDetails().getLink().getUrl()).isEqualTo(detailsUrlLink);
                assertThat(malwareScanFileState.getStatus()).isEqualTo(MalwareScanFileState.Status.OK);

                Actor actor = (Actor)args[1];
                assertThat(actor).isEqualTo(Actor.MALWARE_SCANNER);
                return null;
            }
        }).when(malwareScanPersistenceService).putMalwareScanFileState(any(MalwareScanFileState.class), any(Actor.class));

        malwareScanOperationPersistenceService.updateScanStateFromScanner(
            FILE_ID, MalwareScanFileState.Status.OK, 500L, details);
    }

    @Test
    public void updateScanStateFromScanner_OptimisticLockException() throws Exception {

        when(malwareScanPersistenceService.getMalwareScanFileStateFromDb(FILE_ID))
            .thenReturn(Optional.of(pendingFileState))
            .thenReturn(Optional.of(okFileState));

        PersistentException persistentException = mock(PersistentException.class);
        when(persistentException.getCause()).thenReturn(mock(OptimisticLockException.class));

        doThrow(persistentException).
            doAnswer(
                new Answer<Void>() {
                    @Override
                    public Void answer(final InvocationOnMock invocation) {
                        final Object[] args = invocation.getArguments();
                        MalwareScanFileState malwareScanFileState = (MalwareScanFileState) args[0];
                        assertThat(malwareScanFileState.getFileId()).isEqualTo(FILE_ID);
                        assertThat(malwareScanFileState.getTtl()).isEqualTo(500L);
                        assertThat(malwareScanFileState.getLastSubmissionAttemptTimestamp()).isEqualTo(null);
                        assertThat(malwareScanFileState.getDetails()).isEqualTo(null);
                        assertThat(malwareScanFileState.getStatus()).isEqualTo(MalwareScanFileState.Status.OK);
                        assertThat(malwareScanFileState.getVersion()).isEqualTo(okVersion);

                        Actor actor = (Actor) args[1];
                        assertThat(actor).isEqualTo(Actor.MALWARE_SCANNER);
                        return null;
                    }
                }
            ).when(malwareScanPersistenceService).putMalwareScanFileState(any(MalwareScanFileState.class), eq(Actor.MALWARE_SCANNER));

        malwareScanOperationPersistenceService.updateScanStateFromScanner(
            FILE_ID, MalwareScanFileState.Status.OK, 500L, null);
    }

    @Test
    public void prepareForRescanSuccess() throws Exception {
        when(malwareScanPersistenceService.getMalwareScanFileStateFromDb(FILE_ID)).thenReturn(Optional.of(MalwareScanFileState.builder()
            .status(MalwareScanFileState.Status.PENDING)
            .fileId(FILE_ID).build()));

        Long lastSubmissionAttemptTimestamp = 999L;
        when(timestampMillisSupplier.now()).thenReturn(lastSubmissionAttemptTimestamp);

        MalwareScanResponseDto malwareScanResponseDto = malwareScanOperationPersistenceService.prepareForReScan(
            MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build());

        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.SUCCESS);

        ArgumentCaptor<MalwareScanFileState> malwareScanFileStateCaptorArgumentCaptor = ArgumentCaptor.forClass(MalwareScanFileState.class);

        verify(malwareScanPersistenceService, times(1)).putMalwareScanFileState(malwareScanFileStateCaptorArgumentCaptor.capture(), any(Actor.class));
        MalwareScanFileState capturedFileState = malwareScanFileStateCaptorArgumentCaptor.getValue();
        assertThat(capturedFileState.getStatus()).isEqualTo(MalwareScanFileState.Status.PENDING);
        assertThat(capturedFileState.getLastSubmissionAttemptTimestamp()).isEqualTo(lastSubmissionAttemptTimestamp);
    }

    @Test
    public void prepareForRescanPersistentException() throws Exception {
        doThrow(PersistentException.class).when(malwareScanPersistenceService).getMalwareScanFileStateFromDb(FILE_ID);

        assertThatThrownBy(() -> malwareScanOperationPersistenceService.prepareForReScan(
            MalwareScanRequestDto.builder().attachmentMetaDto(AttachmentMetaDto.builder().fileId(FILE_ID).build()).build()))
                .isInstanceOf(PersistentException.class);
    }
}
