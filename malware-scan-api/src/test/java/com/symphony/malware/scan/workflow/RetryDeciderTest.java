package com.symphony.malware.scan.workflow;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import util.TimestampMillisSupplier;

import java.util.Date;

import static org.junit.Assert.*;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class RetryDeciderTest {

    @Mock
    private TimestampMillisSupplier timestampMillisSupplier;

    private Long NOW_MILLIS;
    private RetryDecider retryDecider;
    private final Integer maximumRetrySeconds = 60 * 3;
    private final Long maximumRetryMillis = maximumRetrySeconds * 1000L;
    private final Integer minimumRetryIntervalSeconds = 60;
    private final Long minimumRetryIntervalSecondsMillis = minimumRetryIntervalSeconds * 1000L;

    @Before
    public void before() throws Exception {
        NOW_MILLIS = new Date().getTime();
        when(timestampMillisSupplier.now()).thenReturn(NOW_MILLIS);
        retryDecider = new RetryDecider(timestampMillisSupplier);
    }

    @Test
    public void shouldStopRetryNowAfterMaxDuration() throws Exception {

        // initial attempt timestamp plus maximum retry seconds is greater than "now" -- stop retrying
        Long initialAttemptTimestamp = NOW_MILLIS - (maximumRetryMillis + 1000);

        assertTrue(retryDecider.shouldStopRetryAttempts(maximumRetrySeconds, initialAttemptTimestamp));
    }

    @Test
    public void shouldStopRetryNowEqualsMaxDuration() throws Exception {

        // initial attempt timestamp plus maximum retry seconds is greater than "now" -- stop retrying
        Long initialAttemptTimestamp = NOW_MILLIS - maximumRetryMillis;

        assertTrue(retryDecider.shouldStopRetryAttempts(maximumRetrySeconds, initialAttemptTimestamp));
    }

    @Test
    public void shouldRetryNowLessThanMaxDuration() throws Exception {

        // initial attempt timestamp plus maximum retry seconds is greater than "now" -- stop retrying
        Long initialAttemptTimestamp = NOW_MILLIS - (maximumRetryMillis - 1000);

        assertFalse(retryDecider.shouldStopRetryAttempts(maximumRetrySeconds, initialAttemptTimestamp));
    }

    @Test
    public void retryIntervalExceeded() throws Exception {

        // "now" is after the last submission attempt timestamp plus retry interval seconds
        Long lastSubmissionAttemptTimestamp = NOW_MILLIS - (minimumRetryIntervalSecondsMillis + 1000);

        assertTrue(retryDecider.retryIntervalExceeded(minimumRetryIntervalSeconds, lastSubmissionAttemptTimestamp));
    }

    @Test
    public void retryIntervalNotExceeded() throws Exception {

        // "now" is not after the last submission attempt timestamp plus retry interval seconds
        Long lastSubmissionAttemptTimestamp = NOW_MILLIS - (minimumRetryIntervalSecondsMillis - 1000);

        assertFalse(retryDecider.retryIntervalExceeded(minimumRetryIntervalSeconds, lastSubmissionAttemptTimestamp));
    }
}