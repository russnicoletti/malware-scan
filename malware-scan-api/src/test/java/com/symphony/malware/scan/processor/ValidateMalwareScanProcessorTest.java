package com.symphony.malware.scan.processor;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.nullable;
import static org.mockito.Mockito.when;

import com.codahale.metrics.Meter;
import com.symphony.malware.scan.MalwareScanRequest;

import com.symphony.malware.scan.metrics.MalwareScanningMetrics;
import static org.mockito.Mockito.verify;

import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.model.User;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.service.MalwareScanValidationService;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.Arrays;
import java.util.UUID;

@RunWith(MockitoJUnitRunner.class)
public class ValidateMalwareScanProcessorTest {

    private static final long USER_ID_1 = 1L;
    private static final String USER_FIRST_NAME_1 = "firstName1";
    private static final String USER_LAST_NAME_1 = "lastName1";
    private static final String COMPANY_NAME_1 = "Symphony";
    private static final String USER_EMAIL_1 = "userEmail1@symphony.com";

    private static final String FILE_ID_1 = "fileId1";
    private static final String FILE_NAME_1 = "fileName1";
    private static final String CONTENT_TYPE_1 = "docx";

    private static final String STREAM_TYPE = "ROOM";
    private static final String STREAM_NAME = "stream1";
    private static final int FROM_POD = 1;

    private static final String WRAPPED_CONTENT_KEY = "wrapped-content-key";
    private static final String WRAPPED_FILE_KEY = "wrapped-file-key";
    private static final Long SIZE_IN_BYTES_1 = 100_000L;

    @Mock
    private MalwareScanningMetrics malwareScanMetrics;
    @Mock
    private Meter countOfFailRequests;

    private MalwareScanValidationService malwareScanValidationService;
    private String traceId;

    @Before
    public void before() {
        when(malwareScanMetrics.countOfFailValidationRequests())
                .thenReturn(countOfFailRequests);
        malwareScanValidationService = new MalwareScanValidationService(malwareScanMetrics);
        traceId = UUID.randomUUID().toString();
    }

    @Test
    public void scan_malwareScanRequestValidationMissingRequiredFields() throws Exception {
        final User user = User.builder().userId(null).firstName("").lastName("").companyName("").email("").build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder()
                .fileId("")
                .name("")
                .contentType("")
                .sizeInBytes(null)
                .build();
        final MalwareScanRequestDto malwareScanRequestDto =
                getMalwareScanRequestDtoMisingRequiredFields(user, attachmentMetaDto);

        assertThatExceptionOfType(MalwareScanException.class)
                .isThrownBy(() -> malwareScanValidationService.validate(malwareScanRequestDto))
                .withMessageContaining("user.userId may not be null")
                .withMessageContaining("fileId may not be empty")
                .withMessageContaining("name may not be empty")
                .withMessageContaining("sizeInBytes may not be null")
                .withMessageContaining("messageId may not be empty")
                .withMessageContaining("streamId may not be empty")
                .withMessageContaining("streamName may not be empty")
                .withMessageContaining("streamType may not be empty")
                .withMessageContaining("encryptionType may not be null")
                .withMessageContaining("wrappedContentKey may not be null")
                .withMessageContaining("wrappedFileKey may not be null")
                .withMessageContaining("traceId may not be null");
    }

    @Test
    public void scan_malwareScanRequestValidationAllFieldsPresent() throws Exception {
        final User user = User.builder().userId(USER_ID_1).firstName("").lastName("").companyName("").email("").build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder()
                .fileId(FILE_ID_1)
                .name(FILE_NAME_1)
                .contentType("")
                .sizeInBytes(SIZE_IN_BYTES_1)
                .build();
        final MalwareScanRequestDto malwareScanRequestDto =
                getMalwareScanRequestDtoAllFields(user, attachmentMetaDto);

        final MalwareScanResponseDto malwareScanResponseDto = malwareScanValidationService.validate(malwareScanRequestDto);
        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.SUCCESS);
        assertThat(malwareScanResponseDto.getError()).isEqualTo("");
    }

    @Test
    public void scan_malwareScanRequestValidationOnlyRequiredFields() throws Exception {
        final User user = User.builder().userId(USER_ID_1).firstName(null).lastName(null).companyName(null).email(null).build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder()
            .fileId(FILE_ID_1)
            .name(FILE_NAME_1)
            .contentType(null)
            .sizeInBytes(SIZE_IN_BYTES_1)
            .build();
        final MalwareScanRequestDto malwareScanRequestDto =
            getMalwareScanRequestDtoOnlyRequiredFields(user, attachmentMetaDto);

        final MalwareScanResponseDto malwareScanResponseDto = malwareScanValidationService.validate(malwareScanRequestDto);
        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.SUCCESS);
        assertThat(malwareScanResponseDto.getError()).isEqualTo("");
    }

    private MalwareScanRequestDto getMalwareScanRequestDtoAllFields(User user,
                                                                    AttachmentMetaDto attachmentMetaDto) {
        return MalwareScanRequestDto.builder()
                .fromPod(FROM_POD)
                .messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
                .streamId(Arrays.toString(Thread.currentThread().toString().getBytes()))
                .user(user)
                .attachmentMetaDto(attachmentMetaDto)
                .streamName(STREAM_NAME)
                .streamType(STREAM_TYPE)
                .encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
                .wrappedContentKey(WRAPPED_CONTENT_KEY)
                .wrappedFileKey(WRAPPED_FILE_KEY)
                .traceId(traceId)
                .build();
    }

    private MalwareScanRequestDto getMalwareScanRequestDtoOnlyRequiredFields(User user,
                                                                             AttachmentMetaDto attachmentMetaDto) {
        return MalwareScanRequestDto.builder()
                .fromPod(null)
                .messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
                .streamId(Arrays.toString(Thread.currentThread().toString().getBytes()))
                .user(user)
                .attachmentMetaDto(attachmentMetaDto)
                .streamName(STREAM_NAME)
                .streamType(STREAM_TYPE)
                .encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
                .wrappedContentKey(WRAPPED_CONTENT_KEY)
                .wrappedFileKey(WRAPPED_FILE_KEY)
                .traceId(traceId)
                .build();
    }

    private MalwareScanRequestDto getMalwareScanRequestDtoMisingRequiredFields(User user,
        AttachmentMetaDto attachmentMetaDto) {
        return MalwareScanRequestDto.builder()
            .messageId("")
            .streamId(null)
            .user(user)
            .attachmentMetaDto(attachmentMetaDto)
            .streamName(null)
            .streamType(null)
            .encryptionType(null)
            .wrappedContentKey(null)
            .wrappedFileKey(null)
            .traceId(null)
            .build();
    }

}
