package com.symphony.malware.scan.processor;

import static org.assertj.core.api.Assertions.assertThat;

import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.model.User;
import com.symphony.malware.scan.service.MalwareScanValidationService;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.Arrays;
import java.util.UUID;

@RunWith(MockitoJUnitRunner.class)
public class ValidateMalwareScanProcessorTest {

    private static final long USER_ID_1 = 1L;
    private static final String USER_FIRST_NAME_1 = "firstName1";
    private static final String USER_LAST_NAME_1 = "lastName1";
    private static final String COMPANY_NAME_1 = "Symphony";
    private static final String USER_EMAIL_1 = "userEmail1@symphony.com";

    private static final String FILE_ID_1 = "fileId1";
    private static final String FILE_NAME_1 = "fileName1";
    private static final String CONTENT_TYPE_1 = "docx";

    private static final String STREAM_TYPE = "ROOM";
    private static final String STREAM_NAME = "stream1";
    private static final int FROM_POD = 1;

    private static final String WRAPPED_CONTENT_KEY = "wrapped-content-key";
    private static final String WRAPPED_FILE_KEY = "wrapped-file-key";
    private static final Long SIZE_IN_BYTES_1 = 100_000L;

    private MalwareScanValidationService malwareScanValidationService;

    @Before
    public void before() {
        malwareScanValidationService = new MalwareScanValidationService();
    }

    @Test
    public void scan_malwareScanRequestValidationFailed_failed() throws Exception {
        final User user = User.builder().userId(USER_ID_1).firstName("").lastName("").companyName(COMPANY_NAME_1).email(USER_EMAIL_1).build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder().fileId(FILE_ID_1).name(null).contentType(CONTENT_TYPE_1).build();
        final MalwareScanRequestDto malwareScanRequestDto = MalwareScanRequestDto.builder().fromPod(FROM_POD).messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
            .streamId(Arrays.toString(Thread.currentThread().toString().getBytes())).user(user).attachmentMetaDto(attachmentMetaDto)
            .streamName(STREAM_NAME).streamType(STREAM_TYPE).encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
            .wrappedContentKey(WRAPPED_CONTENT_KEY).wrappedFileKey(WRAPPED_FILE_KEY).build();

        final MalwareScanResponseDto malwareScanResponseDto = malwareScanValidationService.validate(malwareScanRequestDto);
        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.FAILED_VALIDATION);
        assertThat(malwareScanResponseDto.getError()).contains("attachmentMetaDto.name may not be empty");
        assertThat(malwareScanResponseDto.getError()).contains("user.firstName may not be empty");
        assertThat(malwareScanResponseDto.getError()).contains("user.lastName may not be empty");
    }

    @Test
    public void scan_malwareScanRequestValidationPassed_ok() throws Exception {
        final User user = User.builder().userId(USER_ID_1).firstName(USER_FIRST_NAME_1).lastName(USER_LAST_NAME_1).companyName(COMPANY_NAME_1).email(USER_EMAIL_1).build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder()
            .fileId(FILE_ID_1)
            .name(FILE_NAME_1)
            .contentType(CONTENT_TYPE_1)
            .sizeInBytes(SIZE_IN_BYTES_1)
            .build();
        final MalwareScanRequestDto malwareScanRequestDto = MalwareScanRequestDto.builder().fromPod(FROM_POD).messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
            .streamId(Arrays.toString(Thread.currentThread().toString().getBytes())).user(user).attachmentMetaDto(attachmentMetaDto)
            .streamName(STREAM_NAME).streamType(STREAM_TYPE).encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
            .wrappedContentKey(WRAPPED_CONTENT_KEY).wrappedFileKey(WRAPPED_FILE_KEY).build();

        final MalwareScanResponseDto malwareScanResponseDto = malwareScanValidationService.validate(malwareScanRequestDto);
        assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.PROCESSED);
        assertThat(malwareScanResponseDto.getError()).isEqualTo("");
    }

}
