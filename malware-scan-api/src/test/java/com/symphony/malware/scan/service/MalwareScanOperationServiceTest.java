package com.symphony.malware.scan.service;

import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.eq;

import com.symphony.circuitbreaker.CommandConfig;
import com.symphony.dlp.efsymproxyconnector.ConnectionIdUsageScenario;
import com.symphony.dlp.efsymproxyconnector.ContainerConnector;
import com.symphony.dlp.efsymproxyconnector.ContainerResponse;
import com.symphony.dlp.efsymproxyconnector.ContainerServiceException;
import com.symphony.dlp.efsymproxyconnector.ContainerServiceUnavailableException;
import com.symphony.dlp.efsymproxyconnector.connectorconfig.ContainerConnectorConfiguration;
import com.symphony.dlp.efsymproxyconnector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.model.Attachment;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.User;
import com.symphony.proto320.Descriptors;
import com.symphony.proto320.Message;
import com.symphony.remoteservice.longpoll.RemoteServiceMetric;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;
import com.symphony.remoteservice.longpoll.client.TimedOutException;
import com.symphony.services.rlp.RLP;

import com.google.common.base.Optional;
import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Matchers;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.UUID;

/**
 * Created by sergii.oliinyk
 */
public class MalwareScanOperationServiceTest {

  private static final String SYMRPOXY_CONNECTION = "MalwareScanRequest~:5b3272f8b9d82100013333b5";
  private static final long ID = 1L;
  private static final String DEV_1 = "Dev1";
  private static final String SURNAME = "Pro";
  private static final String COMPANY = "Symphony";
  private static final String EMAIL = "dev1@symphony.com";
  private static final String Attachment_1 = " Attachment1";
  private static final long CREATOR_ID = 777L;
  private static final String CONTENT_TYPE = "docx";
  private static final int SIZE = 35678888;
  private static final String STREAM_TYPE = "ROOM";
  private static final String STREAM_NAME = "stream1";
  private static final int FROM_POD = 1;

  @InjectMocks
  private MalwareScanOperationImpl malwareOperationService;

  @Mock
  protected ContainerConnector connector;

  @Mock
  private SymproxMetricReportCache metricReportCache;

  @Mock
  private ContainerConnectorConfiguration connectorConfiguration;


  @Before
  public void setup() {
    MockitoAnnotations.initMocks(this);
    HashSet<String> symproxyConections = new HashSet<>();
    symproxyConections.add(SYMRPOXY_CONNECTION);
    Mockito.when(connector.getConnectionIds()).thenReturn(symproxyConections);
  }


  @Test
  public void malwareScanningPositiveTest()
      throws TimedOutException, ContainerServiceException, ContainerServiceUnavailableException {
    RLP.ResponseHeader rspHeader =
        RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.OK).build();
    MalwareScanResponse mockResponse =
        MalwareScanResponse.newBuilder().setStatus(Status.OK).build();
    setContainerResponse(rspHeader, mockResponse);

    List<MalwareScanResponse> malwareScanRespons = getMalwareScanResponse();
    for (MalwareScanResponse rs : malwareScanRespons) {
      assertEquals(rs.getStatus(), Status.OK);
    }
  }

  @Test
  public void malwareScanningNegativeTest()
      throws TimedOutException, ContainerServiceException, ContainerServiceUnavailableException {
    RLP.ResponseHeader rspHeader =
        RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.ERROR).build();
    MalwareScanResponse mockResponse =
        MalwareScanResponse.newBuilder().setStatus(Status.FAILED).build();
    setContainerResponse(rspHeader, mockResponse);

    List<MalwareScanResponse> malwareScanRespons = getMalwareScanResponse();
    for (MalwareScanResponse rs : malwareScanRespons) {
      assertEquals(rs.getStatus(), Status.FAILED);
    }
  }

  private List<MalwareScanResponse> getMalwareScanResponse() {
    List<Attachment> attachments = new ArrayList<>();
    Attachment attachment = createAttachmentMeta(Thread.currentThread().toString(), Attachment_1,
        CREATOR_ID, CONTENT_TYPE, SIZE);
    attachments.add(attachment);
    User user = getUser(ID, DEV_1, SURNAME, COMPANY, EMAIL);
    MalwareScanRequestDto malwareScanDTO = MalwareScanRequestDto.builder()
        .fromPod(FROM_POD)
        .uniqueMessageId(UUID.randomUUID().getLeastSignificantBits())
        .actualIngestionDate(DateTime.now().toDateTime().getMillis())
        .threadId(Arrays.toString(Thread.currentThread().toString().getBytes()))
        .user(user)
        .attachments(attachments)
        .streamName(STREAM_NAME)
        .streamType(STREAM_TYPE)
        .build();
    return malwareOperationService.scan(malwareScanDTO);
  }

  private void setContainerResponse(RLP.ResponseHeader rspHeader, MalwareScanResponse mockResponse)
      throws TimedOutException,
      ContainerServiceUnavailableException,
      ContainerServiceException {
    ContainerResponse containerResponse = new ContainerResponse(rspHeader, mockResponse);
    Mockito.when(connector.call(eq(ConnectionIdUsageScenario.VALID),
        eq(RLPUsageScenario.USE_RLP_SERVICE),
        Matchers.any(Descriptors.MethodDescriptor.class),
        Matchers.any(MalwareScanRequest.class), Matchers.any(Message.class),
        Matchers.eq(Optional.absent()),
        Matchers.eq(Optional.absent()),
        Matchers.any(RemoteServiceMetric.class), Matchers.anyInt(),
        Matchers.any(CommandConfig.class))).thenReturn(containerResponse);
  }

  private Attachment createAttachmentMeta(String fieldID, String name, Long creatorId,
      String contentType, long size) {
    return Attachment.builder()
        .fileId(fieldID)
        .name(name)
        .creatorId(creatorId)
        .contentType(contentType)
        .sizeInBytes(size)
        .build();
  }

  private User getUser(long id, String firstName, String surname, String company, String email) {
    return User.builder().userId(id)
        .firstName(firstName)
        .lastName(surname)
        .companyName(company)
        .email(email)
        .build();
  }
}
