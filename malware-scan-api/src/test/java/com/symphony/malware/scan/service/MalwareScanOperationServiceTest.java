package com.symphony.malware.scan.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.symphony.circuitbreaker.CommandConfig;
import com.symphony.container.connector.ConnectionIdUsageScenario;
import com.symphony.container.connector.ContainerConnector;
import com.symphony.container.connector.ContainerResponse;
import com.symphony.container.connector.config.ContainerConnectorConfiguration;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.AttachmentData;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.converter.AttachmentMetaProtoDtoConverter;
import com.symphony.malware.scan.converter.MalwareScanRequestProtoDtoConverter;
import com.symphony.malware.scan.converter.MalwareScanResponseProtoDtoConverter;
import com.symphony.malware.scan.converter.ProtoDtoConverter;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.model.User;
import com.symphony.proto320.Message;
import com.symphony.remoteservice.longpoll.RemoteServiceMetric;
import com.symphony.remoteservice.longpoll.client.RLPService;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;
import com.symphony.services.rlp.RLP;

import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Matchers;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.Arrays;
import java.util.List;
import java.util.UUID;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanOperationServiceTest {

    private static final String SYMRPOXY_CONNECTION = "MalwareScanRequest~:5b3272f8b9d82100013333b5";

    private static final long USER_ID_1 = 1L;
    private static final String USER_FIRST_NAME_1 = "firstName1";
    private static final String USER_LAST_NAME_1 = "lastName1";
    private static final String COMPANY_NAME_1 = "Symphony";
    private static final String USER_EMAIL_1 = "userEmail1@symphony.com";

    private static final String FILE_ID_1 = "fileId1";
    private static final String FILE_NAME_1 = "fileName1";
    private static final String CONTENT_TYPE_1 = "docx";

    private static final String STREAM_TYPE = "ROOM";
    private static final String STREAM_NAME = "stream1";
    private static final int FROM_POD = 1;

    private static final String WRAPPED_CONTENT_KEY = "wrapped-content-key";
    private static final String WRAPPED_FILE_KEY = "wrapped-file-key";

    private static final String MALWARE_SCAN_RLP_SERVICE_NAME = "scanAttachmentForMalwareService";

    @Captor
    private ArgumentCaptor<Optional<RLPService>> rlpServiceCaptor;

    @Mock
    private ContainerConnector containerConnector;

    @Mock
    private SymproxMetricReportCache symproxMetricReportCache;

    @Mock
    private MalwareScanValidationService malwareScanValidationService;

    @Mock
    private ContainerConnectorConfiguration containerConnectorConfiguration;

    @Mock
    private MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;

    private ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter;

    private ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter;

    private ProtoDtoConverter<AttachmentData.AttachmentMeta, AttachmentMetaDto> attachmentMetaProtoDtoConverter;

    private MalwareScanOperationService malwareOperationService;

    @Before
    public void before() {
        attachmentMetaProtoDtoConverter = new AttachmentMetaProtoDtoConverter();
        malwareScanRequestProtoDtoConverter = new MalwareScanRequestProtoDtoConverter(attachmentMetaProtoDtoConverter);
        malwareScanResponseProtoDtoConverter = new MalwareScanResponseProtoDtoConverter();

        malwareOperationService = new MalwareScanOperationService(
            containerConnector, symproxMetricReportCache, containerConnectorConfiguration, malwareScanValidationService,
            malwareScanOperationPersistenceService, malwareScanRequestProtoDtoConverter, malwareScanResponseProtoDtoConverter
        );

        when(containerConnector.getConnectionIds()).thenReturn(ImmutableSet.of(SYMRPOXY_CONNECTION));
    }

    @Test
    public void scan_validateMalwareScanProcessorFails_failed() throws Exception {
        final User user = User.builder().userId(USER_ID_1).firstName(USER_FIRST_NAME_1).lastName(USER_LAST_NAME_1).companyName(COMPANY_NAME_1).email(USER_EMAIL_1).build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder().fileId(FILE_ID_1).name(FILE_NAME_1).contentType(CONTENT_TYPE_1).build();
        final MalwareScanRequestDto malwareScanRequestDto = MalwareScanRequestDto.builder().fromPod(FROM_POD).messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
            .streamId(Arrays.toString(Thread.currentThread().toString().getBytes())).user(user).attachmentMetaDto(attachmentMetaDto)
            .streamName(STREAM_NAME).streamType(STREAM_TYPE).encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
            .wrappedContentKey(WRAPPED_CONTENT_KEY).wrappedFileKey(WRAPPED_FILE_KEY).build();

        when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class))).thenReturn(MalwareScanResponseDto.builder().status(Status.FAILED).error("Error").build());

        final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareOperationService.scan(ImmutableList.of(malwareScanRequestDto));

        assertThat(malwareScanResponseDtos.size()).isEqualTo(1);
        assertThat(malwareScanResponseDtos.get(0).getStatus()).isEqualTo(Status.FAILED);
        assertThat(malwareScanResponseDtos.get(0).getError()).isEqualTo("Error");
        assertThat(malwareScanResponseDtos.get(0).getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

        // Make sure that malware scan validation was not called
        verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

        // Make sure that malware scan status persistence create was not called
        verify(malwareScanOperationPersistenceService, times(0)).create(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.PENDING), eq(Actor.SYMPHONY));

        // Make sure that container connector was not called
        verify(containerConnector, times(0)).call(any(ConnectionIdUsageScenario.class), any(RLPUsageScenario.class),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), Matchers.any(),
            Matchers.any(), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class)
        );

        // Make sure that malware scan status persistence update was not called
        verify(malwareScanOperationPersistenceService, times(0)).update(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
    }

    @Test
    public void scan_createStateMalwareScanProcessorFails_failed() throws Exception {
        final User user = User.builder().userId(USER_ID_1).firstName(USER_FIRST_NAME_1).lastName(USER_LAST_NAME_1).companyName(COMPANY_NAME_1).email(USER_EMAIL_1).build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder().fileId(FILE_ID_1).name(FILE_NAME_1).contentType(CONTENT_TYPE_1).build();
        final MalwareScanRequestDto malwareScanRequestDto = MalwareScanRequestDto.builder().fromPod(FROM_POD).messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
            .streamId(Arrays.toString(Thread.currentThread().toString().getBytes())).user(user).attachmentMetaDto(attachmentMetaDto)
            .streamName(STREAM_NAME).streamType(STREAM_TYPE).encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
            .wrappedContentKey(WRAPPED_CONTENT_KEY).wrappedFileKey(WRAPPED_FILE_KEY).build();

        when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class))).thenReturn(MalwareScanResponseDto.builder().status(Status.OK).error("").build());

        when(malwareScanOperationPersistenceService.create(malwareScanRequestDto, MalwareScanFileState.Status.PENDING, Actor.SYMPHONY)).thenReturn(
            MalwareScanResponseDto.builder().status(Status.FAILED).error("Error").build()
        );

        final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareOperationService.scan(ImmutableList.of(malwareScanRequestDto));

        assertThat(malwareScanResponseDtos.size()).isEqualTo(1);
        assertThat(malwareScanResponseDtos.get(0).getStatus()).isEqualTo(Status.FAILED);
        assertThat(malwareScanResponseDtos.get(0).getError()).isEqualTo("Error");
        assertThat(malwareScanResponseDtos.get(0).getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

        // Make sure that malware scan validation was not called
        verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

        // Make sure that malware scan status persistence create was called
        verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.PENDING), eq(Actor.SYMPHONY));

        // Make sure that container connector was not called
        verify(containerConnector, times(0)).call(any(ConnectionIdUsageScenario.class), any(RLPUsageScenario.class),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), Matchers.any(),
            Matchers.any(), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class)
        );

        // Make sure that malware scan status persistence update was not called
        verify(malwareScanOperationPersistenceService, times(0)).update(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
    }

    @Test
    public void scan_sendRequestMalwareScanProcessorFails_failed() throws Exception {
        final User user = User.builder().userId(USER_ID_1).firstName(USER_FIRST_NAME_1).lastName(USER_LAST_NAME_1).companyName(COMPANY_NAME_1).email(USER_EMAIL_1).build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder().fileId(FILE_ID_1).name(FILE_NAME_1).contentType(CONTENT_TYPE_1).build();
        final MalwareScanRequestDto malwareScanRequestDto = MalwareScanRequestDto.builder().fromPod(FROM_POD).messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
            .streamId(Arrays.toString(Thread.currentThread().toString().getBytes())).user(user).attachmentMetaDto(attachmentMetaDto)
            .streamName(STREAM_NAME).streamType(STREAM_TYPE).encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
            .wrappedContentKey(WRAPPED_CONTENT_KEY).wrappedFileKey(WRAPPED_FILE_KEY).build();

        when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class))).thenReturn(MalwareScanResponseDto.builder().status(Status.OK).error("").build());

        when(malwareScanOperationPersistenceService.create(malwareScanRequestDto, MalwareScanFileState.Status.PENDING, Actor.SYMPHONY)).thenReturn(
            MalwareScanResponseDto.builder().status(Status.OK).error("").build()
        );

        when(containerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE), eq(RLPUsageScenario.USE_RLP_SERVICE),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), rlpServiceCaptor.capture(),
            eq(Optional.absent()), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class))
        ).thenReturn(new ContainerResponse<>(
            RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.ERROR).build(),
            MalwareScanResponse.newBuilder().setStatus(Status.FAILED).setError("Error").build())
        );

        final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareOperationService.scan(ImmutableList.of(malwareScanRequestDto));

        assertThat(malwareScanResponseDtos.size()).isEqualTo(1);
        assertThat(malwareScanResponseDtos.get(0).getStatus()).isEqualTo(Status.FAILED);
        assertThat(malwareScanResponseDtos.get(0).getError()).contains("Failed to send the malware scan request");
        assertThat(malwareScanResponseDtos.get(0).getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

        assertThat(rlpServiceCaptor.getValue().isPresent()).isTrue();
        assertThat(rlpServiceCaptor.getValue().get().getVal()).isEqualTo(MALWARE_SCAN_RLP_SERVICE_NAME);

        // Make sure that malware scan validation was not called
        verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

        // Make sure that malware scan status persistence create was called
        verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.PENDING), eq(Actor.SYMPHONY));

        // Make sure that container connector was called
        verify(containerConnector, times(1)).call(any(ConnectionIdUsageScenario.class), any(RLPUsageScenario.class),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), Matchers.any(),
            Matchers.any(), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class)
        );

        // Make sure that malware scan status persistence update was not called
        verify(malwareScanOperationPersistenceService, times(0)).update(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
    }

    @Test
    public void scan_updateStateMalwareScanProcessorFails_success() throws Exception {
        final User user = User.builder().userId(USER_ID_1).firstName(USER_FIRST_NAME_1).lastName(USER_LAST_NAME_1).companyName(COMPANY_NAME_1).email(USER_EMAIL_1).build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder().fileId(FILE_ID_1).name(FILE_NAME_1).contentType(CONTENT_TYPE_1).build();
        final MalwareScanRequestDto malwareScanRequestDto = MalwareScanRequestDto.builder().fromPod(FROM_POD).messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
            .streamId(Arrays.toString(Thread.currentThread().toString().getBytes())).user(user).attachmentMetaDto(attachmentMetaDto)
            .streamName(STREAM_NAME).streamType(STREAM_TYPE).encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
            .wrappedContentKey(WRAPPED_CONTENT_KEY).wrappedFileKey(WRAPPED_FILE_KEY).build();

        when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class))).thenReturn(MalwareScanResponseDto.builder().status(Status.OK).error("").build());

        when(malwareScanOperationPersistenceService.create(malwareScanRequestDto, MalwareScanFileState.Status.PENDING, Actor.SYMPHONY)).thenReturn(
            MalwareScanResponseDto.builder().status(Status.OK).error("").build()
        );

        when(containerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE), eq(RLPUsageScenario.USE_RLP_SERVICE),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), rlpServiceCaptor.capture(),
            eq(Optional.absent()), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class))
        ).thenReturn(new ContainerResponse<>(
            RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.OK).build(),
            MalwareScanResponse.newBuilder().setStatus(Status.OK).setError("").build())
        );

        when(malwareScanOperationPersistenceService.update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY)).thenReturn(
            MalwareScanResponseDto.builder().status(Status.FAILED).error("Error").build()
        );

        final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareOperationService.scan(ImmutableList.of(malwareScanRequestDto));

        assertThat(malwareScanResponseDtos.size()).isEqualTo(1);
        assertThat(malwareScanResponseDtos.get(0).getStatus()).isEqualTo(Status.FAILED);
        assertThat(malwareScanResponseDtos.get(0).getError()).contains("Error");
        assertThat(malwareScanResponseDtos.get(0).getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

        assertThat(rlpServiceCaptor.getValue().isPresent()).isTrue();
        assertThat(rlpServiceCaptor.getValue().get().getVal()).isEqualTo(MALWARE_SCAN_RLP_SERVICE_NAME);

        // Make sure that malware scan validation was not called
        verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

        // Make sure that malware scan status persistence create was called
        verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.PENDING), eq(Actor.SYMPHONY));

        // Make sure that container connector was called
        verify(containerConnector, times(1)).call(any(ConnectionIdUsageScenario.class), any(RLPUsageScenario.class),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), Matchers.any(),
            Matchers.any(), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class)
        );

        // Make sure that malware scan status persistence update was not called
        verify(malwareScanOperationPersistenceService, times(1)).update(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
    }

    @Test
    public void scan_noFails_success() throws Exception {
        final User user = User.builder().userId(USER_ID_1).firstName(USER_FIRST_NAME_1).lastName(USER_LAST_NAME_1).companyName(COMPANY_NAME_1).email(USER_EMAIL_1).build();
        final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder().fileId(FILE_ID_1).name(FILE_NAME_1).contentType(CONTENT_TYPE_1).build();
        final MalwareScanRequestDto malwareScanRequestDto = MalwareScanRequestDto.builder().fromPod(FROM_POD).messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
            .streamId(Arrays.toString(Thread.currentThread().toString().getBytes())).user(user).attachmentMetaDto(attachmentMetaDto)
            .streamName(STREAM_NAME).streamType(STREAM_TYPE).encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
            .wrappedContentKey(WRAPPED_CONTENT_KEY).wrappedFileKey(WRAPPED_FILE_KEY).build();

        when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class))).thenReturn(MalwareScanResponseDto.builder().status(Status.OK).error("").build());

        when(malwareScanOperationPersistenceService.create(malwareScanRequestDto, MalwareScanFileState.Status.PENDING, Actor.SYMPHONY)).thenReturn(
            MalwareScanResponseDto.builder().status(Status.OK).error("").build()
        );

        when(containerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE), eq(RLPUsageScenario.USE_RLP_SERVICE),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), rlpServiceCaptor.capture(),
            eq(Optional.absent()), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class))
        ).thenReturn(new ContainerResponse<>(
            RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.OK).build(),
            MalwareScanResponse.newBuilder().setStatus(Status.OK).setError("").build())
        );

        when(malwareScanOperationPersistenceService.update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY)).thenReturn(
            MalwareScanResponseDto.builder().status(Status.OK).error("").build()
        );

        final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareOperationService.scan(ImmutableList.of(malwareScanRequestDto));

        assertThat(malwareScanResponseDtos.size()).isEqualTo(1);
        assertThat(malwareScanResponseDtos.get(0).getStatus()).isEqualTo(Status.OK);
        assertThat(malwareScanResponseDtos.get(0).getError()).contains("");
        assertThat(malwareScanResponseDtos.get(0).getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

        assertThat(rlpServiceCaptor.getValue().isPresent()).isTrue();
        assertThat(rlpServiceCaptor.getValue().get().getVal()).isEqualTo(MALWARE_SCAN_RLP_SERVICE_NAME);

        // Make sure that malware scan validation was not called
        verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

        // Make sure that malware scan status persistence create was called
        verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.PENDING), eq(Actor.SYMPHONY));

        // Make sure that container connector was called
        verify(containerConnector, times(1)).call(any(ConnectionIdUsageScenario.class), any(RLPUsageScenario.class),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), Matchers.any(),
            Matchers.any(), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class)
        );

        // Make sure that malware scan status persistence update was not called
        verify(malwareScanOperationPersistenceService, times(1)).update(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
    }

}
