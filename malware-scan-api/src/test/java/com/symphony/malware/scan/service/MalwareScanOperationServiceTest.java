package com.symphony.malware.scan.service;

import static com.symphony.malware.scan.connector.config.MalwareScanContainerConnectorConfigProvider.ConnectionRequestType;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.symphony.circuitbreaker.CommandConfig;
import com.symphony.container.connector.ConnectionIdUsageScenario;
import com.symphony.container.connector.ContainerResponse;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.connector.MalwareScanContainerConnector;
import com.symphony.malware.scan.connector.MalwareScanRlpCallExecutor;
import com.symphony.malware.scan.connector.config.MalwareScanContainerConnectorConfig;
import com.symphony.malware.scan.connector.config.MalwareScanContainerConnectorConfigProvider;
import com.symphony.malware.scan.converter.AttachmentMetaProtoDtoConverter;
import com.symphony.malware.scan.converter.MalwareScanRequestProtoDtoConverter;
import com.symphony.malware.scan.converter.MalwareScanResponseProtoDtoConverter;
import com.symphony.malware.scan.metrics.MalwareScanningMetrics;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.model.User;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.persistence.exception.MalwareScanStatusTransferException;
import com.symphony.proto320.Message;
import com.symphony.remoteservice.longpoll.RemoteServiceMetric;
import com.symphony.remoteservice.longpoll.client.RLPService;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;
import com.symphony.services.rlp.RLP;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Answers;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.Arrays;
import java.util.UUID;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanOperationServiceTest {

  private static final long USER_ID_1 = 1L;
  private static final String USER_FIRST_NAME_1 = "firstName1";
  private static final String USER_LAST_NAME_1 = "lastName1";
  private static final String COMPANY_NAME_1 = "Symphony";
  private static final String USER_EMAIL_1 = "userEmail1@symphony.com";

  private static final String FILE_ID_1 = "fileId1";
  private static final String FILE_NAME_1 = "fileName1";
  private static final String CONTENT_TYPE_1 = "docx";

  private static final String STREAM_TYPE = "ROOM";
  private static final String STREAM_NAME = "stream1";
  private static final int FROM_POD = 1;

  private static final String WRAPPED_CONTENT_KEY = "wrapped-content-key";
  private static final String WRAPPED_FILE_KEY = "wrapped-file-key";

  private static final String MALWARE_SCAN_RLP_SERVICE_NAME = "scanAttachmentForMalwareService";

  @Mock
  private MalwareScanContainerConnector malwareScanContainerConnector;

  @Mock
  private SymproxMetricReportCache symproxMetricReportCache;

  @Mock
  private MalwareScanRlpCallExecutor malwareScanRlpCallExecutor;

  @Mock
  private MalwareScanContainerConnectorConfigProvider malwareScanContainerConnectorConfigProvider;

  @Mock
  private MalwareScanContainerConnectorConfig malwareScanContainerConnectorConfig;

  @Mock
  private MalwareScanValidationService malwareScanValidationService;

  @Captor
  private ArgumentCaptor<RLPService> rlpServiceCaptor;

  @Mock
  private CommandConfig commandConfig;

  @Mock
  private MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;

  @Mock(answer = Answers.RETURNS_DEEP_STUBS)
  private MalwareScanningMetrics malwareScanningMetrics;

  private MalwareScanOperationService malwareOperationService;

  private String traceId;

  @Before
  public void before() {
    when(malwareScanContainerConnectorConfigProvider.getContainerConnectorConfig(ConnectionRequestType.MALWARE_SCAN))
        .thenReturn(malwareScanContainerConnectorConfig);

    final AttachmentMetaProtoDtoConverter attachmentMetaProtoDtoConverter = new AttachmentMetaProtoDtoConverter();
    final MalwareScanRequestProtoDtoConverter malwareScanRequestProtoDtoConverter = new MalwareScanRequestProtoDtoConverter(attachmentMetaProtoDtoConverter);
    final MalwareScanResponseProtoDtoConverter malwareScanResponseProtoDtoConverter = new MalwareScanResponseProtoDtoConverter();

    malwareOperationService = new MalwareScanOperationService(malwareScanContainerConnector,
        symproxMetricReportCache, malwareScanRlpCallExecutor, malwareScanContainerConnectorConfigProvider,
        malwareScanValidationService, malwareScanOperationPersistenceService, malwareScanningMetrics,
        malwareScanRequestProtoDtoConverter, malwareScanResponseProtoDtoConverter
    );

    traceId = UUID.randomUUID().toString();
  }

  @Test
  public void scan_validateMalwareScanProcessorFails_failed() throws Exception {
    final MalwareScanRequestDto malwareScanRequestDto = getMalwareScanRequestDto();

    when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class)))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.FAIL_VALIDATION).error("Error").build());

    final MalwareScanResponseDto malwareScanResponseDto = malwareOperationService.scan(malwareScanRequestDto);

    assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.FAIL_VALIDATION);
    assertThat(malwareScanResponseDto.getError()).isEqualTo("Error");
    assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

    // Make sure that malware scan validation was not called
    verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

    // Make sure that malware scan status persistence create was not called
    verify(malwareScanOperationPersistenceService, times(0))
        .create(any(MalwareScanRequestDto.class));

    // Make sure that container connector was not called
    verify(malwareScanContainerConnector, times(0)).call(any(ConnectionIdUsageScenario.class),
        any(RLPUsageScenario.class), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(Message.class), any(), any(), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    );

    // Make sure that malware scan status persistence update was not called
    verify(malwareScanOperationPersistenceService, times(0)).update(any(MalwareScanRequestDto.class),
        eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
  }

  @Test
  public void scan_createStateMalwareScanProcessorGetsFailUpdateStateResponse_failed() throws Exception {
    final MalwareScanRequestDto malwareScanRequestDto = getMalwareScanRequestDto();

    when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class)))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanOperationPersistenceService.create(malwareScanRequestDto))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.FAIL_CREATE_STATE).error("Error").build());

    final MalwareScanResponseDto malwareScanResponseDto = malwareOperationService.scan(malwareScanRequestDto);

    assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.FAIL_CREATE_STATE);
    assertThat(malwareScanResponseDto.getError()).isEqualTo("Error");
    assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

    // Make sure that malware scan validation was not called
    verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

    // Make sure that malware scan status persistence create was called
    verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class));

    // Make sure that container connector was not called
    verify(malwareScanContainerConnector, times(0)).call(any(ConnectionIdUsageScenario.class),
        any(RLPUsageScenario.class), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(Message.class), any(), any(), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    );

    // Make sure that malware scan status persistence update was not called
    verify(malwareScanOperationPersistenceService, times(0)).update(any(MalwareScanRequestDto.class),
        eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
  }

  @Test
  public void scan_sendRequestMalwareScanProcessorFails_failed() throws Exception {
    final MalwareScanRequestDto malwareScanRequestDto = getMalwareScanRequestDto();

    when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class)))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanOperationPersistenceService.create(malwareScanRequestDto))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanContainerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
        eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(Message.class), any(), eq(null), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    )).thenReturn(new ContainerResponse<>(
        RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.ERROR).build(),
        MalwareScanResponse.newBuilder().setStatus(Status.FAILED).setError("Error").build())
    );

    try {
      malwareOperationService.scan(malwareScanRequestDto);
    } catch (MalwareScanException e) {

    // Verify call to the container connector and capture arguments
    verify(malwareScanContainerConnector).call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
        eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(MalwareScanResponse.class), rlpServiceCaptor.capture(), eq(null), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    );

      // Make sure that malware scan validation was not called
      verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

    assertThat(rlpServiceCaptor.getValue()).isNotNull();
    assertThat(rlpServiceCaptor.getValue().getVal()).isEqualTo(MALWARE_SCAN_RLP_SERVICE_NAME);

      // Make sure that malware scan status persistence create was called
      verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class));

    // Make sure that container connector was called
    verify(malwareScanContainerConnector, times(1)).call(any(ConnectionIdUsageScenario.class),
        any(RLPUsageScenario.class), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(Message.class), any(), any(), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    );

      // Make sure that malware scan status persistence update was not called
      verify(malwareScanOperationPersistenceService, times(0)).update(any(MalwareScanRequestDto.class),
              eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));

      verify(malwareScanningMetrics, times(0)).countOfSuccessfulRequests();
      verify(malwareScanningMetrics, times(1)).countOfFailedToSubmitRequests();
    }
  }

  @Test
  public void scan_updateStateMalwareScanProcessorGetsFailUpdateStateResponse_success() throws Exception {
    final MalwareScanRequestDto malwareScanRequestDto = getMalwareScanRequestDto();

    when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class)))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanOperationPersistenceService.create(malwareScanRequestDto))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanContainerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
        eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(Message.class), any(), eq(null), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    )).thenReturn(new ContainerResponse<>(
        RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.OK).build(),
        MalwareScanResponse.newBuilder().setStatus(Status.OK).setError("").build())
    );

    when(malwareScanOperationPersistenceService.update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.FAIL_UPDATE_STATE).error("Error").build());

    final MalwareScanResponseDto malwareScanResponseDto = malwareOperationService.scan(malwareScanRequestDto);

    // Verify call to the container connector and capture arguments
    verify(malwareScanContainerConnector).call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
        eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(MalwareScanResponse.class), rlpServiceCaptor.capture(), eq(null), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    );

    assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.FAIL_UPDATE_STATE);
    assertThat(malwareScanResponseDto.getError()).contains("Error");
    assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

    assertThat(rlpServiceCaptor.getValue()).isNotNull();
    assertThat(rlpServiceCaptor.getValue().getVal()).isEqualTo(MALWARE_SCAN_RLP_SERVICE_NAME);

    // Make sure that malware scan validation was not called
    verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

    // Make sure that malware scan status persistence create was called
    verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class));

    // Make sure that container connector was called
    verify(malwareScanContainerConnector, times(1)).call(any(ConnectionIdUsageScenario.class),
        any(RLPUsageScenario.class), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(Message.class), any(), any(), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    );

    // Make sure that malware scan status persistence update was not called
    verify(malwareScanOperationPersistenceService, times(1)).update(any(MalwareScanRequestDto.class),
        eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));

    verify(malwareScanningMetrics, times(1)).countOfSuccessfulRequests();
    verify(malwareScanningMetrics, times(0)).countOfFailedToSubmitRequests();
  }

  @Test
  public void scan_updateStateMalwareScanProcessorCatchesMalwareScanStatusTransferException_success() throws Exception {
    final MalwareScanRequestDto malwareScanRequestDto = getMalwareScanRequestDto();

    when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class)))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanOperationPersistenceService.create(malwareScanRequestDto))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanContainerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE), eq(RLPUsageScenario.USE_RLP_SERVICE),
        any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), any(),
        eq(null), any(RemoteServiceMetric.class), any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    )).thenReturn(new ContainerResponse<>(
        RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.OK).build(),
        MalwareScanResponse.newBuilder().setStatus(Status.OK).setError("").build())
    );

    when(malwareScanOperationPersistenceService.update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY))
        .thenThrow(new MalwareScanStatusTransferException("Transfer from OK status to SUBMITTED status is not allowed"));

    final MalwareScanResponseDto malwareScanResponseDto = malwareOperationService.scan(malwareScanRequestDto);

    // Verify call to the container connector and capture arguments
    verify(malwareScanContainerConnector).call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
        eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(MalwareScanResponse.class), rlpServiceCaptor.capture(), eq(null), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    );

    assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.SUCCESS);
    assertThat(malwareScanResponseDto.getError()).isEmpty();
    assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

    assertThat(rlpServiceCaptor.getValue()).isNotNull();
    assertThat(rlpServiceCaptor.getValue().getVal()).isEqualTo(MALWARE_SCAN_RLP_SERVICE_NAME);

    // Make sure that malware scan validation was not called
    verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));

    // Make sure that malware scan status persistence create was called
    verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class));

    // Make sure that container connector was called
    verify(malwareScanContainerConnector, times(1)).call(any(ConnectionIdUsageScenario.class),
        any(RLPUsageScenario.class), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(Message.class), any(), any(), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    );

    // Make sure that malware scan status persistence update was not called
    verify(malwareScanOperationPersistenceService, times(1)).update(any(MalwareScanRequestDto.class),
        eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));

    verify(malwareScanningMetrics, times(1)).countOfSuccessfulRequests();
    verify(malwareScanningMetrics, times(0)).countOfFailedToSubmitRequests();
  }

  @Test
  public void scan_allOk_success() throws Exception {
    final MalwareScanRequestDto malwareScanRequestDto = getMalwareScanRequestDto();

    when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class)))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanOperationPersistenceService.create(malwareScanRequestDto))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanContainerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
        eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(MalwareScanResponse.class), any(), eq(null), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    )).thenReturn(new ContainerResponse<>(
        RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.OK).build(),
        MalwareScanResponse.newBuilder().setStatus(Status.OK).setError("").build())
    );

    when(malwareScanOperationPersistenceService.update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    final MalwareScanResponseDto malwareScanResponseDto = malwareOperationService.scan(malwareScanRequestDto);

    // Verify call to the container connector and capture arguments
    verify(malwareScanContainerConnector).call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
        eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(MalwareScanResponse.class), rlpServiceCaptor.capture(), eq(null), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), eq(malwareScanRlpCallExecutor)
    );

    assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.SUCCESS);
    assertThat(malwareScanResponseDto.getError()).contains("");
    assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

    assertThat(rlpServiceCaptor.getValue()).isNotNull();
    assertThat(rlpServiceCaptor.getValue().getVal()).isEqualTo(MALWARE_SCAN_RLP_SERVICE_NAME);

    // Make sure that malware scan validation was called
    verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));
    // Make sure that malware scan status persistence create was called
    verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class));

    // Make sure that malware scan status persistence update was called
    verify(malwareScanOperationPersistenceService, times(1)).update(any(MalwareScanRequestDto.class),
        eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));

    verify(malwareScanningMetrics, times(1)).countOfSuccessfulRequests();
    verify(malwareScanningMetrics, times(0)).countOfFailedToSubmitRequests();
  }

  /**
   * If there is already an ongoing request for the same file, then no call to RLP nor update
   * to the State should be done.
   *
   * @throws Exception
   */
  @Test
  public void scan_alreadyProcessing() throws Exception {
    final MalwareScanRequestDto malwareScanRequestDto = getMalwareScanRequestDto();

    when(malwareScanValidationService.validate(any(MalwareScanRequestDto.class)))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build());

    when(malwareScanOperationPersistenceService.create(malwareScanRequestDto))
        .thenReturn(MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.STATE_PRESENT).error("").build());

    final MalwareScanResponseDto malwareScanResponseDto = malwareOperationService.scan(malwareScanRequestDto);

    assertThat(malwareScanResponseDto.getStatus()).isEqualTo(MalwareScanResponseDto.Status.STATE_PRESENT);
    assertThat(malwareScanResponseDto.getError()).contains("");
    assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isEqualTo(malwareScanRequestDto);

    // Make sure that malware scan validation was called
    verify(malwareScanValidationService, times(1)).validate(any(MalwareScanRequestDto.class));
    // Make sure that malware scan status persistence create was called
    verify(malwareScanOperationPersistenceService, times(1)).create(any(MalwareScanRequestDto.class));

    // Make sure that container connector was not called
    verify(malwareScanContainerConnector, never()).call(any(ConnectionIdUsageScenario.class),
        any(RLPUsageScenario.class), any(String.class), any(String.class), any(MalwareScanRequest.class),
        any(Message.class), any(), any(), any(RemoteServiceMetric.class),
        any(MalwareScanContainerConnectorConfig.class), any(MalwareScanRlpCallExecutor.class)
    );

    // Make sure that malware scan status persistence update was not called
    verify(malwareScanOperationPersistenceService, never()).update(any(MalwareScanRequestDto.class),
        eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));

    verify(malwareScanningMetrics, times(0)).countOfSuccessfulRequests();
    verify(malwareScanningMetrics, times(0)).countOfFailedToSubmitRequests();
  }

  private MalwareScanRequestDto getMalwareScanRequestDto() {
    final User user = User.builder()
        .userId(USER_ID_1)
        .firstName(USER_FIRST_NAME_1)
        .lastName(USER_LAST_NAME_1)
        .companyName(COMPANY_NAME_1)
        .email(USER_EMAIL_1)
        .build();

    final AttachmentMetaDto attachmentMetaDto = AttachmentMetaDto.builder()
        .fileId(FILE_ID_1)
        .name(FILE_NAME_1)
        .contentType(CONTENT_TYPE_1)
        .build();

    return MalwareScanRequestDto.builder()
        .fromPod(FROM_POD)
        .messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
        .streamId(Arrays.toString(Thread.currentThread().toString().getBytes()))
        .user(user)
        .attachmentMetaDto(attachmentMetaDto)
        .streamName(STREAM_NAME)
        .streamType(STREAM_TYPE)
        .encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
        .wrappedContentKey(WRAPPED_CONTENT_KEY)
        .wrappedFileKey(WRAPPED_FILE_KEY)
        .traceId(traceId)
        .build();
  }
}
