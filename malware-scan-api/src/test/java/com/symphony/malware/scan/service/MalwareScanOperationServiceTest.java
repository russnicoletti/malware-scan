package com.symphony.malware.scan.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.symphony.circuitbreaker.CommandConfig;
import com.symphony.container.connector.ConnectionIdUsageScenario;
import com.symphony.container.connector.ContainerConnector;
import com.symphony.container.connector.ContainerResponse;
import com.symphony.container.connector.config.ContainerConnectorConfiguration;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.AttachmentData;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.converter.AttachmentMetaProtoDtoConverter;
import com.symphony.malware.scan.converter.MalwareScanRequestProtoDtoConverter;
import com.symphony.malware.scan.converter.MalwareScanResponseProtoDtoConverter;
import com.symphony.malware.scan.converter.ProtoDtoConverter;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.model.User;
import com.symphony.proto320.Message;
import com.symphony.remoteservice.longpoll.RemoteServiceMetric;
import com.symphony.remoteservice.longpoll.client.RLPService;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;
import com.symphony.services.rlp.RLP;

import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Matchers;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanOperationServiceTest {

    private static final String SYMRPOXY_CONNECTION = "MalwareScanRequest~:5b3272f8b9d82100013333b5";

    private static final long USER_ID_1 = 1L;
    private static final String USER_FIRST_NAME_1 = "firstName1";
    private static final String USER_LAST_NAME_1 = "lastName1";
    private static final String COMPANY_NAME_1 = "Symphony";
    private static final String USER_EMAIL_1 = "userEmail1@symphony.com";

    private static final String FILE_ID_1 = "fileId1";
    private static final String FILE_NAME_1 = "fileName1";
    private static final long CREATOR_ID_1 = 777L;
    private static final String CONTENT_TYPE_1 = "docx";

    private static final String STREAM_TYPE = "ROOM";
    private static final String STREAM_NAME = "stream1";
    private static final int FROM_POD = 1;

    private static final String MALWARE_SCAN_RLP_SERVICE_NAME = "scanAttachmentForMalwareService";

    @Captor
    private ArgumentCaptor<Optional<RLPService>> rlpServiceCaptor;

    @Mock
    private ContainerConnector containerConnector;

    @Mock
    private SymproxMetricReportCache symproxMetricReportCache;

    @Mock
    private MalwareScanValidationService malwareScanValidationService;

    @Mock
    private ContainerConnectorConfiguration containerConnectorConfiguration;

    @Mock
    private MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;

    private ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter;

    private ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter;

    private ProtoDtoConverter<AttachmentData.AttachmentMeta, AttachmentMetaDto> attachmentMetaProtoDtoConverter;

    private MalwareScanOperationService malwareOperationService;

    @Before
    public void before() {
        attachmentMetaProtoDtoConverter = new AttachmentMetaProtoDtoConverter();
        malwareScanRequestProtoDtoConverter = new MalwareScanRequestProtoDtoConverter(attachmentMetaProtoDtoConverter);
        malwareScanResponseProtoDtoConverter = new MalwareScanResponseProtoDtoConverter();

        malwareOperationService = new MalwareScanOperationService(
            containerConnector, symproxMetricReportCache, containerConnectorConfiguration, malwareScanValidationService,
            malwareScanOperationPersistenceService, malwareScanRequestProtoDtoConverter, malwareScanResponseProtoDtoConverter
        );

        when(containerConnector.getConnectionIds()).thenReturn(ImmutableSet.of(SYMRPOXY_CONNECTION));
    }

    @Test
    public void scan_malwareScanRequestValidationFailed_failed() throws Exception {
        final User user = createUser(USER_ID_1, "", "", COMPANY_NAME_1, USER_EMAIL_1);
        final AttachmentMetaDto attachmentMetaDto = createAttachmentMeta(FILE_ID_1, null, null, CONTENT_TYPE_1);
        final MalwareScanRequestDto malwareScanRequestDto = createMalwareScanRequestDto(user, attachmentMetaDto);

        final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareOperationService.scan(ImmutableList.of(malwareScanRequestDto));
        for (MalwareScanResponseDto malwareScanResponseDto : malwareScanResponseDtos) {
            assertThat(malwareScanResponseDto.getStatus()).isEqualTo(Status.FAILED);
            assertThat(malwareScanResponseDto.getError()).contains("attachmentMetaDto.name must not be blank");
            assertThat(malwareScanResponseDto.getError()).contains("attachmentMetaDto.creatorId must not be null");
            assertThat(malwareScanResponseDto.getError()).contains("user.firstName must not be blank");
            assertThat(malwareScanResponseDto.getError()).contains("user.lastName must not be blank");
            assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isNotNull();
        }

        // Make sure that container connector was not called
        verify(containerConnector, times(0)).call(any(ConnectionIdUsageScenario.class), any(RLPUsageScenario.class),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), Matchers.any(),
            Matchers.any(), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class)
        );

        // Make sure that malware scan status persistence update was not called
        verify(malwareScanOperationPersistenceService, times(0)).update(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
    }

    @Test
    public void scan_persistPendingFailed_failed() throws Exception {
        final User user = createUser(USER_ID_1, USER_FIRST_NAME_1, USER_LAST_NAME_1, COMPANY_NAME_1, USER_EMAIL_1);
        final AttachmentMetaDto attachmentMetaDto = createAttachmentMeta(FILE_ID_1, FILE_NAME_1, CREATOR_ID_1, CONTENT_TYPE_1);
        final MalwareScanRequestDto malwareScanRequestDto = createMalwareScanRequestDto(user, attachmentMetaDto);

        when(malwareScanOperationPersistenceService.create(malwareScanRequestDto, MalwareScanFileState.Status.PENDING, Actor.SYMPHONY)).thenReturn(
            MalwareScanResponseDto.builder().status(Status.FAILED).error("ERROR").build()
        );

        final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareOperationService.scan(ImmutableList.of(malwareScanRequestDto));
        for (MalwareScanResponseDto malwareScanResponseDto : malwareScanResponseDtos) {
            assertThat(malwareScanResponseDto.getStatus()).isEqualTo(Status.FAILED);
            assertThat(malwareScanResponseDto.getError()).isEqualTo("ERROR");
            assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isNotNull();
        }

        // Make sure that container connector was not called
        verify(containerConnector, times(0)).call(any(ConnectionIdUsageScenario.class), any(RLPUsageScenario.class),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), Matchers.any(),
            Matchers.any(), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class)
        );

        // Make sure that malware scan status persistence update was not called
        verify(malwareScanOperationPersistenceService, times(0)).update(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
    }

    @Test
    public void scan_rlpFailed_failed() throws Exception {
        final User user = createUser(USER_ID_1, USER_FIRST_NAME_1, USER_LAST_NAME_1, COMPANY_NAME_1, USER_EMAIL_1);
        final AttachmentMetaDto attachmentMetaDto = createAttachmentMeta(FILE_ID_1, FILE_NAME_1, CREATOR_ID_1, CONTENT_TYPE_1);
        final MalwareScanRequestDto malwareScanRequestDto = createMalwareScanRequestDto(user, attachmentMetaDto);

        when(malwareScanOperationPersistenceService.create(malwareScanRequestDto, MalwareScanFileState.Status.PENDING, Actor.SYMPHONY)).thenReturn(
            MalwareScanResponseDto.builder().status(Status.OK).error("").build()
        );

        when(containerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE), eq(RLPUsageScenario.USE_RLP_SERVICE),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), rlpServiceCaptor.capture(),
            eq(Optional.absent()), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class))
        ).thenReturn(new ContainerResponse<>(
            RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.ERROR).build(),
            MalwareScanResponse.newBuilder().setStatus(Status.FAILED).setError("ERROR").build())
        );

        final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareOperationService.scan(ImmutableList.of(malwareScanRequestDto));
        for (MalwareScanResponseDto malwareScanResponseDto : malwareScanResponseDtos) {
            assertThat(malwareScanResponseDto.getStatus()).isEqualTo(Status.FAILED);
            assertThat(malwareScanResponseDto.getError()).contains("Failed to send the malware scan request");
            assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isNotNull();
        }

        assertThat(rlpServiceCaptor.getValue().isPresent()).isTrue();
        assertThat(rlpServiceCaptor.getValue().get().getVal()).isEqualTo(MALWARE_SCAN_RLP_SERVICE_NAME);

        // Make sure that malware scan status persistence update was not called
        verify(malwareScanOperationPersistenceService, times(0)).update(any(MalwareScanRequestDto.class), eq(MalwareScanFileState.Status.SUBMITTED), eq(Actor.SYMPHONY));
    }

    @Test
    public void scan_persistUpdateFailed_success() throws Exception {
        final User user = createUser(USER_ID_1, USER_FIRST_NAME_1, USER_LAST_NAME_1, COMPANY_NAME_1, USER_EMAIL_1);
        final AttachmentMetaDto attachmentMetaDto = createAttachmentMeta(FILE_ID_1, FILE_NAME_1, CREATOR_ID_1, CONTENT_TYPE_1);
        final MalwareScanRequestDto malwareScanRequestDto = createMalwareScanRequestDto(user, attachmentMetaDto);

        when(malwareScanOperationPersistenceService.create(malwareScanRequestDto, MalwareScanFileState.Status.PENDING, Actor.SYMPHONY)).thenReturn(
            MalwareScanResponseDto.builder().status(Status.OK).error("").build()
        );

        when(containerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE), eq(RLPUsageScenario.USE_RLP_SERVICE),
            any(String.class), any(String.class), any(MalwareScanRequest.class), any(Message.class), rlpServiceCaptor.capture(),
            eq(Optional.absent()), any(RemoteServiceMetric.class), anyInt(), any(CommandConfig.class))
        ).thenReturn(new ContainerResponse<>(
            RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.OK).build(),
            MalwareScanResponse.newBuilder().setStatus(Status.OK).setError("").build())
        );

        final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareOperationService.scan(ImmutableList.of(malwareScanRequestDto));
        for (MalwareScanResponseDto malwareScanResponseDto : malwareScanResponseDtos) {
            assertThat(malwareScanResponseDto.getStatus()).isEqualTo(Status.OK);
            assertThat(malwareScanResponseDto.getError()).isEqualTo("");
            assertThat(malwareScanResponseDto.getMalwareScanRequestDto()).isNotNull();
        }

        assertThat(rlpServiceCaptor.getValue().isPresent()).isTrue();
        assertThat(rlpServiceCaptor.getValue().get().getVal()).isEqualTo(MALWARE_SCAN_RLP_SERVICE_NAME);
    }

    private User createUser(long id, String firstName, String lastName, String companyName, String email) {
        return User.builder().userId(id)
            .firstName(firstName)
            .lastName(lastName)
            .companyName(companyName)
            .email(email)
            .build();
    }

    private AttachmentMetaDto createAttachmentMeta(String fieldId, String name, Long creatorId, String contentType) {
        return AttachmentMetaDto.builder()
            .fileId(fieldId)
            .name(name)
            .creatorId(creatorId)
            .contentType(contentType)
            .build();
    }

    private MalwareScanRequestDto createMalwareScanRequestDto(final User user, final AttachmentMetaDto attachmentMetaDto) {
        return MalwareScanRequestDto.builder()
            .fromPod(FROM_POD)
            .messageId(Long.toString(UUID.randomUUID().getLeastSignificantBits()))
            .creationTime(Instant.now().getEpochSecond())
            .streamId(Arrays.toString(Thread.currentThread().toString().getBytes()))
            .user(user)
            .attachmentMetaDto(attachmentMetaDto)
            .streamName(STREAM_NAME)
            .streamType(STREAM_TYPE)
            .encryptionType(MalwareScanRequest.EncryptionType.UNKNOWN)
            .wrappedContentKey("wrapped-content-key")
            .wrappedFileKey("wrapped-file-key")
            .build();
    }

}
