package com.symphony.malware.scan.workflow;

import com.codahale.metrics.Meter;
import com.codahale.metrics.Timer;
import com.symphony.container.connector.ConnectionIdUsageScenario;
import com.symphony.container.connector.ContainerResponse;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.connector.MalwareScanContainerConnector;
import com.symphony.malware.scan.connector.MalwareScanRlpCallExecutor;
import com.symphony.malware.scan.connector.config.MalwareScanContainerConnectorConfigProvider;
import com.symphony.malware.scan.converter.AttachmentMetaProtoDtoConverter;
import com.symphony.malware.scan.converter.MalwareScanRequestProtoDtoConverter;
import com.symphony.malware.scan.converter.MalwareScanResponseProtoDtoConverter;
import com.symphony.malware.scan.metrics.MalwareScanningMetrics;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.model.User;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.persistence.service.MalwareScanPersistenceService;
import com.symphony.malware.scan.service.MalwareScanOperationPersistenceService;
import com.symphony.malware.scan.service.MalwareScanOperationService;
import com.symphony.malware.scan.service.MalwareScanValidationService;
import com.symphony.remoteservice.longpoll.RemoteServiceMetric;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;
import com.symphony.remoteservice.longpoll.client.TimedOutException;
import com.symphony.services.rlp.RLP;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import util.TimestampMillisSupplier;

import java.util.Arrays;
import java.util.Optional;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanSubmissionWorkflowTest {

    @Mock
    private MalwareScanPersistenceService malwareScanPersistenceService;
    @Mock
    private MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;
    @Mock
    private MalwareScanSubmissionWorkflowConfigCache malwareScanSubmissionWorkflowConfigCache;
    @Mock
    private MalwareScanSubmissionWorkflowConfig malwareScanSubmissionWorkflowConfig;
    @Mock
    private MalwareScanStatusPublisher malwareScanStatusPublisher;
    @Mock
    private MalwareScanningMetrics malwareScanningMetrics;
    @Mock
    private Timer timeBetweenInitialFailedRequestAndSuccessfulRetryTimer;
    @Mock
    private Timer timeBetweenSubmittingRequestAndGettingResponseFromSymproxyTimer;
    @Mock
    Timer.Context timerContext;
    @Mock
    private Meter countOfFailedToUpdateAfterRetryExhaustedMeter;
    @Mock
    private Meter countOfFailedToSubmitAfterRetryExhaustedMeter;
    @Mock
    private Meter countOfRequestFailedDueToExceptionMeter;
    @Mock
    private Meter countOfRetrySubmissionMeter;
    @Mock
    private Meter countOfSuccessfulRequestsMeter;
    @Mock
    private Meter countOfFailedToSubmitRequestsMeter;
    @Mock
    private TimestampMillisSupplier timestampMillisSupplier;
    @Mock
    MalwareScanContainerConnector malwareScanContainerConnector;
    @Mock
    SymproxMetricReportCache symproxMetricReportCache;
    @Mock
    MalwareScanRlpCallExecutor malwareScanRlpCallExecutor;
    @Mock
    MalwareScanContainerConnectorConfigProvider malwareScanContainerConnectorConfigProvider;
    @Mock
    MalwareScanValidationService malwareScanValidationService;

    private MalwareScanOperationService malwareScanOperationService;
    private MalwareScanSubmissionWorkflow malwareScanSubmissionWorkflow;
    private MalwareScanRequestDto malwareScanRequestDto;
    private RetryingDecisionHelper retryingDecisionHelper;

    private static final String ID_OF_FILE_TO_SUBMIT = "fileId";
    private static final String MESSAGE_ID = "messageId";
    private static final String STREAM_ID = "streamId";
    private static final String STREAM_NAME = "streamName";
    private static final String STREAM_TYPE = "streamType";
    private static final Integer FROM_POD = 0;
    @Mock
    User user;
    private MalwareScanRequest.EncryptionType ENCRYPTION_TYPE = MalwareScanRequest.EncryptionType.WRAPPED_CONTENT_KEY;
    private static final String WRAPPEND_CONTENT_KEY = "wrappedContentKey";
    private static final String WRAPPEND_FILE_KEY = "wrappedFileKey";
    private static final String TRACE_ID = "traceId";

    private static final String ATTACHMENT_NAME = "attachmentName";
    private static final String CONTENT_TYPE = "contentType";
    private static final Long SIZE_IN_BYTES = 1L;

    @Before
    public void setUp() throws Exception {
        final AttachmentMetaProtoDtoConverter attachmentMetaProtoDtoConverter = new AttachmentMetaProtoDtoConverter();
        final MalwareScanRequestProtoDtoConverter malwareScanRequestProtoDtoConverter = new MalwareScanRequestProtoDtoConverter(attachmentMetaProtoDtoConverter);
        final MalwareScanResponseProtoDtoConverter malwareScanResponseProtoDtoConverter = new MalwareScanResponseProtoDtoConverter();

        when(malwareScanningMetrics.timeBetweenInitialFailedRequestAndSuccessfulRetry()).thenReturn(timeBetweenInitialFailedRequestAndSuccessfulRetryTimer);

        when(malwareScanningMetrics.timeBetweenSubmittingRequestAndGettingResponseFromSymproxy()).thenReturn(timeBetweenSubmittingRequestAndGettingResponseFromSymproxyTimer);
        when(timeBetweenSubmittingRequestAndGettingResponseFromSymproxyTimer.time()).thenReturn(timerContext);
        when(timerContext.stop()).thenReturn(1L);
        when(malwareScanningMetrics.countOfFailedToUpdateAfterRetryExhausted()).thenReturn(countOfFailedToUpdateAfterRetryExhaustedMeter);
        when(malwareScanningMetrics.countOfFailedToSubmitAfterRetryExhausted()).thenReturn(countOfFailedToSubmitAfterRetryExhaustedMeter);
        when(malwareScanningMetrics.countOfRequestFailedDueToException()).thenReturn(countOfRequestFailedDueToExceptionMeter);
        when(malwareScanningMetrics.countOfRetrySubmission()).thenReturn(countOfRetrySubmissionMeter);
        when(malwareScanningMetrics.countOfSuccessfulRequests()).thenReturn(countOfSuccessfulRequestsMeter);
        when(malwareScanningMetrics.countOfFailedToSubmitRequests()).thenReturn(countOfFailedToSubmitRequestsMeter);

        malwareScanOperationService = new MalwareScanOperationService(
                malwareScanContainerConnector,
                symproxMetricReportCache,
                malwareScanRlpCallExecutor,
                malwareScanContainerConnectorConfigProvider,
                malwareScanValidationService,
                malwareScanOperationPersistenceService,
                malwareScanningMetrics,
                malwareScanRequestProtoDtoConverter,
                malwareScanResponseProtoDtoConverter);

        when(malwareScanSubmissionWorkflowConfigCache.get()).thenReturn(malwareScanSubmissionWorkflowConfig);

        malwareScanSubmissionWorkflow = new MalwareScanSubmissionWorkflow(
                malwareScanPersistenceService,
                malwareScanOperationService,
                malwareScanOperationPersistenceService,
                malwareScanSubmissionWorkflowConfigCache,
                malwareScanStatusPublisher,
                malwareScanningMetrics,
                timestampMillisSupplier
        );

        malwareScanRequestDto = MalwareScanRequestDto.builder()
                .streamId(STREAM_ID)
                .streamName(STREAM_NAME)
                .streamType(STREAM_TYPE)
                .messageId(MESSAGE_ID)
                .fromPod(FROM_POD)
                .user(user)
                .encryptionType(ENCRYPTION_TYPE)
                .wrappedContentKey(WRAPPEND_CONTENT_KEY)
                .wrappedFileKey(WRAPPEND_FILE_KEY)
                .attachmentMetaDto(AttachmentMetaDto.builder()
                        .name(ATTACHMENT_NAME)
                        .fileId(ID_OF_FILE_TO_SUBMIT)
                        .contentType(CONTENT_TYPE)
                        .sizeInBytes(SIZE_IN_BYTES)
                        .build())
                .traceId(TRACE_ID) .build();

        when(malwareScanContainerConnector.call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
                eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
                any(MalwareScanResponse.class), any(), eq(null), any(RemoteServiceMetric.class),
                any(), any(MalwareScanRlpCallExecutor.class)
        )).thenReturn(new ContainerResponse<>(
                RLP.ResponseHeader.newBuilder().setResult(RLP.ResponseHeader.Result.OK).build(),
                MalwareScanResponse.newBuilder().setStatus(Status.OK).setError("").build())
        );
        when(malwareScanValidationService.validate(malwareScanRequestDto)).thenReturn(createMalwareScanResponseDto(MalwareScanResponseDto.Status.SUCCESS));
        when(malwareScanOperationPersistenceService.create(malwareScanRequestDto)).thenReturn(createMalwareScanResponseDto(MalwareScanResponseDto.Status.SUCCESS));
        when(malwareScanOperationPersistenceService.update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY)).thenReturn(createMalwareScanResponseDto(MalwareScanResponseDto.Status.SUCCESS));
        when(malwareScanOperationPersistenceService.prepareForReScan(malwareScanRequestDto)).thenReturn(createMalwareScanResponseDto(MalwareScanResponseDto.Status.SUCCESS));

        retryingDecisionHelper = new RetryingDecisionHelper(malwareScanSubmissionWorkflowConfig, timestampMillisSupplier);
    }

    @Test
    public void requestSubmittedInDifferentMessage() throws Exception {
        MalwareScanFileState notSameMessageAsRequestMalwareScanFileState =
                MalwareScanFileState.builder()
                        .originalMessageId("differentMessageId")
                        .build();
        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(Optional.of(notSameMessageAsRequestMalwareScanFileState));


        assertTrue(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));
        verify(malwareScanOperationPersistenceService, times(1)).insertMapping(any(MalwareScanRequestDto.class));
        verifyNoInteractions(malwareScanStatusPublisher);
        verifyNoInteractions(malwareScanSubmissionWorkflowConfig);
    }

    @Test
    public void initialSubmissionSuccess() throws Exception {

        // File has not been scanned previously
        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(Optional.empty());

        // Don't acknowledge message so that it will replay in order to ensure the scanner updates the status of the file
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        // Should have submitted the malwareScanRequest for scanning
        verify(malwareScanOperationPersistenceService).update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);
        verify(malwareScanningMetrics, times(0)).countOfRetrySubmission();
    }

    @Test
    public void scanAttemptException() throws Exception {

        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(Optional.empty());
        doThrow(TimedOutException.class).when(malwareScanContainerConnector).call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
                eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
                any(MalwareScanResponse.class), any(), eq(null), any(RemoteServiceMetric.class),
                any(), any(MalwareScanRlpCallExecutor.class)
        );

        // Don't ack message, let it replay to see if the error corrects itself
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        verify(malwareScanningMetrics, times(1)).countOfRequestFailedDueToException();
        verify(malwareScanOperationPersistenceService,times(0)).update(any(MalwareScanRequestDto.class), any(MalwareScanFileState.Status.class), any(Actor.class));
    }

    @Test
    public void retryScanAttemptException() throws Exception {

        Long createTimestamp = retryingDecisionHelper.setUpShouldRetry(true);

        // File in PENDING state
        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(
                createMalwareScanFileState(createTimestamp, MalwareScanFileState.Status.PENDING));
        doThrow(TimedOutException.class).when(malwareScanContainerConnector).call(eq(ConnectionIdUsageScenario.NOT_APPLICABLE),
                eq(RLPUsageScenario.USE_RLP_SERVICE), any(String.class), any(String.class), any(MalwareScanRequest.class),
                any(MalwareScanResponse.class), any(), eq(null), any(RemoteServiceMetric.class),
                any(), any(MalwareScanRlpCallExecutor.class)
        );

        // Don't ack message, let it replay to see if the error corrects itself
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        verify(malwareScanningMetrics, times(1)).countOfRequestFailedDueToException();
        verify(malwareScanningMetrics, times(1)).countOfFailedToSubmitRequests();
        verify(malwareScanningMetrics, times(1)).countOfRetrySubmission();
        verify(malwareScanOperationPersistenceService,times(0)).update(any(MalwareScanRequestDto.class), any(MalwareScanFileState.Status.class), any(Actor.class));
    }

    @Test
    public void scanAttemptCreateStateException() throws Exception {

        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(Optional.empty());
        doThrow(MalwareScanException.class).when(malwareScanOperationPersistenceService).create(any(MalwareScanRequestDto.class));

        // Don't ack message, let it replay to see if the error corrects itself
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        verify(malwareScanningMetrics, times(1)).countOfRequestFailedDueToException();
    }

    @Test
    public void scanAttemptError() throws Exception {

        // Error submitting file for scanning
        when(malwareScanOperationPersistenceService.create(malwareScanRequestDto)).thenReturn(
                createMalwareScanResponseDto(MalwareScanResponseDto.Status.STATE_PRESENT));

        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(Optional.empty());

        // Don't ack message, let it replay to see if the error corrects itself
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        verify(malwareScanningMetrics, times(0)).countOfRequestFailedDueToException();
        verify(malwareScanningMetrics, times(0)).countOfRetrySubmission();
        verify(malwareScanOperationPersistenceService,times(0)).update(any(MalwareScanRequestDto.class), any(MalwareScanFileState.Status.class), any(Actor.class));
    }

    @Test
    public void updateToFinalFailedStateException() throws Exception {
        Long createTimestamp = retryingDecisionHelper.setUpRetryDurationExceeded(true);

        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(
                createMalwareScanFileState(createTimestamp, MalwareScanFileState.Status.PENDING));

        doThrow(PersistentException.class).when(malwareScanOperationPersistenceService).update(malwareScanRequestDto, MalwareScanFileState.Status.FAILED_SUBMIT, Actor.SYMPHONY);

        // The message should not be ack'd because the exception condition may correct itself.
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));
        verify(malwareScanningMetrics, times(1)).countOfRequestFailedDueToException();
    }

    @Test
    public void retrySuccess() throws Exception {
        Long createTimestamp = retryingDecisionHelper.setUpShouldRetry(true);

        // File in PENDING state
        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(
                createMalwareScanFileState(createTimestamp, MalwareScanFileState.Status.PENDING));

        // Should not ack message, let it replay to check if scanner has updated the state
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        verify(malwareScanOperationPersistenceService,times(1)).update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);
        verify(malwareScanningMetrics, times(1)).countOfRetrySubmission();
    }

    @Test
    public void giveUpRetryingFailedSubmit() throws Exception {
        verifyGiveUpScenario(MalwareScanFileState.Status.PENDING, MalwareScanFileState.Status.FAILED_SUBMIT);
        verify(malwareScanningMetrics, times(1)).countOfFailedToSubmitAfterRetryExhausted();
    }

    @Test
    public void giveUpRetryingFailedUpdate() throws Exception {
        verifyGiveUpScenario(MalwareScanFileState.Status.SUBMITTED, MalwareScanFileState.Status.FAILED_UPDATE);
        verify(malwareScanningMetrics, times(1)).countOfFailedToUpdateAfterRetryExhausted();
        verify(countOfFailedToUpdateAfterRetryExhaustedMeter, times(1)).mark();
    }

    @Test
    public void fileInFinalState() throws Exception {
        Long createTimestamp = retryingDecisionHelper.setUpRetryDurationExceeded(false);

        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(
                createMalwareScanFileState(createTimestamp, MalwareScanFileState.Status.OK));

        assertTrue(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));
    }

    private void verifyGiveUpScenario(MalwareScanFileState.Status initialState, MalwareScanFileState.Status finalState) throws Exception {

        Long createTimestamp = retryingDecisionHelper.setUpRetryDurationExceeded(true);

        when(malwareScanPersistenceService.getMalwareScanFileState(ID_OF_FILE_TO_SUBMIT)).thenReturn(
                createMalwareScanFileState(createTimestamp, initialState), createMalwareScanFileState(createTimestamp, finalState));

        // Should ack message, file will be in a final state
        assertTrue(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        // Should have not retried the scan for the original malwareScanRequest
        // (retry, update state to "final state", publish state "final state"
        ArgumentCaptor<MalwareScanFileState.Status> updateStatusArgumentCaptor = ArgumentCaptor.forClass(MalwareScanFileState.Status.class);
        ArgumentCaptor<MalwareScanRequestDto> malwareScanRequestDtoArgumentCaptor = ArgumentCaptor.forClass(MalwareScanRequestDto.class);
        ArgumentCaptor<Actor> actorArgumentCaptor = ArgumentCaptor.forClass(Actor.class);
        verify(malwareScanOperationPersistenceService).update(malwareScanRequestDtoArgumentCaptor.capture(), updateStatusArgumentCaptor.capture(), actorArgumentCaptor.capture());
        assertEquals(malwareScanRequestDtoArgumentCaptor.getValue().getAttachmentMetaDto().getFileId(), ID_OF_FILE_TO_SUBMIT);
        assertEquals(updateStatusArgumentCaptor.getValue(), finalState);

        ArgumentCaptor<MalwareScanFileState> publishStateArgumentCaptor = ArgumentCaptor.forClass(MalwareScanFileState.class);
        verify(malwareScanStatusPublisher).publish(publishStateArgumentCaptor.capture());
        MalwareScanFileState state = publishStateArgumentCaptor.getValue();
        assertEquals(state.getStatus(), finalState);
    }

    private MalwareScanResponseDto createMalwareScanResponseDto(MalwareScanResponseDto.Status status) {
        return MalwareScanResponseDto.builder().status(status)
                .malwareScanRequestDto(MalwareScanRequestDto.builder()
                        .attachmentMetaDto(AttachmentMetaDto.builder()
                                .fileId(ID_OF_FILE_TO_SUBMIT)
                                .build()).build())
                .build();
    }

    private Optional<MalwareScanFileState> createMalwareScanFileState(Long createTimestamp, MalwareScanFileState.Status status) {

        return MalwareScanWorflowTestHelper.createMalwareScanFileState(createTimestamp, MESSAGE_ID, status);
    }
}

