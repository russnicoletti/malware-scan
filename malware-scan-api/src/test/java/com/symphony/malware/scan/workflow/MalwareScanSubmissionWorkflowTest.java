package com.symphony.malware.scan.workflow;

import com.codahale.metrics.Meter;
import com.codahale.metrics.Timer;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.metrics.MalwareScanningMetrics;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.persistence.service.MalwareScanPersistenceService;
import com.symphony.malware.scan.service.MalwareScanOperationPersistenceService;
import com.symphony.malware.scan.service.MalwareScanOperationService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import util.TimestampMillisSupplier;

import java.util.Arrays;
import java.util.Optional;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanSubmissionWorkflowTest {

    @Mock
    private MalwareScanPersistenceService malwareScanPersistenceService;
    @Mock
    private MalwareScanOperationService malwareScanOperationService;
    @Mock
    private MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;
    @Mock
    private MalwareScanSubmissionWorkflowConfig malwareScanSubmissionWorkflowConfig;
    @Mock
    private MalwareScanStatusPublisher malwareScanStatusPublisher;
    @Mock
    private MalwareScanningMetrics malwareScanningMetrics;
    @Mock
    private Timer timeBetweenInitialFailedRequestAndSuccessfulRetryTimer;
    @Mock
    private Meter countOfFailedToUpdateAfterRetryExhaustedMeter;
    @Mock
    private Meter countOfFailedToSubmitAfterRetryExhaustedMeter;
    @Mock
    private Meter countOfRequestFailedDueToExceptionMeter;
    @Mock
    private Meter countOfRetrySubmissionMeter;
    @Mock
    private TimestampMillisSupplier timestampMillisSupplier;

    private MalwareScanSubmissionWorkflow malwareScanSubmissionWorkflow;
    private MalwareScanRequestDto malwareScanRequestDto;
    private RetryingDecisionHelper retryingDecisionHelper;

    private static final String idOfFileToSubmit = "fileId";
    private static final String messageId = "messageId";

    @Before
    public void setUp() throws Exception {
        malwareScanSubmissionWorkflow = new MalwareScanSubmissionWorkflow(
                malwareScanPersistenceService,
                malwareScanOperationService,
                malwareScanOperationPersistenceService,
                malwareScanSubmissionWorkflowConfig,
                malwareScanStatusPublisher,
                malwareScanningMetrics,
                timestampMillisSupplier
        );

        malwareScanRequestDto = MalwareScanRequestDto.builder()
                .messageId(messageId)
                .attachmentMetaDto(AttachmentMetaDto.builder()
                        .fileId(idOfFileToSubmit)
                        .build())
                .build();

        when(malwareScanningMetrics.timeBetweenInitialFailedRequestAndSuccessfulRetry()).thenReturn(timeBetweenInitialFailedRequestAndSuccessfulRetryTimer);
        when(malwareScanningMetrics.countOfFailedToUpdateAfterRetryExhausted()).thenReturn(countOfFailedToUpdateAfterRetryExhaustedMeter);
        when(malwareScanningMetrics.countOfFailedToSubmitAfterRetryExhausted()).thenReturn(countOfFailedToSubmitAfterRetryExhaustedMeter);
        when(malwareScanningMetrics.countOfRequestFailedDueToException()).thenReturn(countOfRequestFailedDueToExceptionMeter);
        when(malwareScanningMetrics.countOfRetrySubmission()).thenReturn(countOfRetrySubmissionMeter);

        retryingDecisionHelper = new RetryingDecisionHelper(malwareScanSubmissionWorkflowConfig, timestampMillisSupplier);
    }

    @Test
    public void requestSubmittedInDifferentMessage() throws Exception {
        MalwareScanFileState notSameMessageAsRequestMalwareScanFileState =
                MalwareScanFileState.builder()
                        .originalMessageId("differentMessageId")
                        .build();
        when(malwareScanPersistenceService.getMalwareScanFileState(idOfFileToSubmit)).thenReturn(Optional.of(notSameMessageAsRequestMalwareScanFileState));

        assertTrue(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));
        verifyNoInteractions(malwareScanOperationPersistenceService);
        verifyNoInteractions(malwareScanOperationService);
        verifyNoInteractions(malwareScanStatusPublisher);
        verifyNoInteractions(malwareScanSubmissionWorkflowConfig);
    }

    @Test
    public void initialSubmissionSuccess() throws Exception {

        // File has not been scanned previously
        when(malwareScanPersistenceService.getMalwareScanFileState(idOfFileToSubmit)).thenReturn(Optional.empty());

        when(malwareScanOperationService.scan(malwareScanRequestDto)).thenReturn(createMalwareScanResponseDto(MalwareScanResponseDto.Status.SUCCESS));

        // Don't acknowledge message so that it will replay in order to ensure the scanner updates the status of the file
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        // Should have submitted the malwareScanRequest for scanning
        ArgumentCaptor<MalwareScanRequestDto> malwareScanRequestDtoArgumentCaptor = ArgumentCaptor.forClass(MalwareScanRequestDto.class);
        verify(malwareScanOperationService).scan(malwareScanRequestDtoArgumentCaptor.capture());
        assertEquals(malwareScanRequestDtoArgumentCaptor.getValue().getAttachmentMetaDto().getFileId(), idOfFileToSubmit);
    }

    @Test
    public void scanAttemptException() throws Exception {

        // Exception submitting file for scanning
        doThrow(MalwareScanException.class).when(malwareScanOperationService).scan(any(MalwareScanRequestDto.class));

        when(malwareScanPersistenceService.getMalwareScanFileState(idOfFileToSubmit)).thenReturn(Optional.empty());

        // Don't ack message, let it replay to see if the error corrects itself
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        verify(malwareScanOperationService, times(1)).scan(any(MalwareScanRequestDto.class));
        verify(malwareScanningMetrics, times(1)).countOfRequestFailedDueToException();
        verify(malwareScanOperationPersistenceService,times(0)).update(any(MalwareScanRequestDto.class), any(MalwareScanFileState.Status.class), any(Actor.class));
    }

    @Test
    public void retryScanAttemptException() throws Exception {

        Long createTimestamp = retryingDecisionHelper.setUpShouldRetry(true);

        // File in PENDING state
        when(malwareScanPersistenceService.getMalwareScanFileState(idOfFileToSubmit)).thenReturn(
                createMalwareScanFileState(createTimestamp, MalwareScanFileState.Status.PENDING));

        // Exception submitting file for scanning
        doThrow(MalwareScanException.class).when(malwareScanOperationService).retryScan(any(MalwareScanRequestDto.class));

        // Don't ack message, let it replay to see if the error corrects itself
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        verify(malwareScanOperationService, times(1)).retryScan(any(MalwareScanRequestDto.class));
        verify(malwareScanningMetrics, times(1)).countOfRequestFailedDueToException();
        verify(malwareScanOperationPersistenceService,times(0)).update(any(MalwareScanRequestDto.class), any(MalwareScanFileState.Status.class), any(Actor.class));

        // Verify metric was recorded
        verify(malwareScanningMetrics, times(1)).countOfRetrySubmission();
    }

    @Test
    public void scanAttemptError() throws Exception {

        // Error submitting file for scanning
        when(malwareScanOperationService.scan(malwareScanRequestDto)).thenReturn(
                createMalwareScanResponseDto(MalwareScanResponseDto.Status.STATE_PRESENT));

        when(malwareScanPersistenceService.getMalwareScanFileState(idOfFileToSubmit)).thenReturn(Optional.empty());

        // Don't ack message, let it replay to see if the error corrects itself
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        verify(malwareScanOperationService, times(1)).scan(any(MalwareScanRequestDto.class));
        verify(malwareScanningMetrics, times(0)).countOfRequestFailedDueToException();
        verify(malwareScanOperationPersistenceService,times(0)).update(any(MalwareScanRequestDto.class), any(MalwareScanFileState.Status.class), any(Actor.class));
    }

    @Test
    public void updateToFinalFailedStateException() throws Exception {
        Long createTimestamp = retryingDecisionHelper.setUpRetryDurationExceeded(true);

        when(malwareScanPersistenceService.getMalwareScanFileState(idOfFileToSubmit)).thenReturn(
                createMalwareScanFileState(createTimestamp, MalwareScanFileState.Status.PENDING));

        doThrow(PersistentException.class).when(malwareScanOperationPersistenceService).update(malwareScanRequestDto, MalwareScanFileState.Status.FAILED_SUBMIT, Actor.SYMPHONY);

        // The message should not be ack'd because the exception condition may correct itself.
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));
        verify(malwareScanningMetrics, times(1)).countOfRequestFailedDueToException();
    }

    @Test
    public void retrySuccess() throws Exception {
        Long createTimestamp = retryingDecisionHelper.setUpShouldRetry(true);

        // File in PENDING state
        when(malwareScanPersistenceService.getMalwareScanFileState(idOfFileToSubmit)).thenReturn(
                createMalwareScanFileState(createTimestamp, MalwareScanFileState.Status.PENDING));

        when(malwareScanOperationService.retryScan(malwareScanRequestDto)).thenReturn(createMalwareScanResponseDto(MalwareScanResponseDto.Status.SUCCESS));

        // Should not ack message, let it replay to check if scanner has updated the state
        assertFalse(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        // Should have retried the scan for the original malwareScanRequest
        ArgumentCaptor<MalwareScanRequestDto> malwareScanRequestDtoArgumentCaptor = ArgumentCaptor.forClass(MalwareScanRequestDto.class);
        verify(malwareScanOperationService).retryScan(malwareScanRequestDtoArgumentCaptor.capture());
        assertEquals(malwareScanRequestDtoArgumentCaptor.getValue().getAttachmentMetaDto().getFileId(), idOfFileToSubmit);

        // Verify metric was recorded
        verify(malwareScanningMetrics, times(1)).countOfRetrySubmission();

        verifyNoInteractions(malwareScanStatusPublisher);
    }

    @Test
    public void giveUpRetryingFailedSubmit() throws Exception {
        verifyGiveUpScenario(MalwareScanFileState.Status.PENDING, MalwareScanFileState.Status.FAILED_SUBMIT);
        verify(malwareScanningMetrics, times(1)).countOfFailedToSubmitAfterRetryExhausted();
    }

    @Test
    public void giveUpRetryingFailedUpdate() throws Exception {
        verifyGiveUpScenario(MalwareScanFileState.Status.SUBMITTED, MalwareScanFileState.Status.FAILED_UPDATE);
        verify(malwareScanningMetrics, times(1)).countOfFailedToUpdateAfterRetryExhausted();
    }

    @Test
    public void fileInFinalState() throws Exception {
        Long createTimestamp = retryingDecisionHelper.setUpRetryDurationExceeded(false);

        when(malwareScanPersistenceService.getMalwareScanFileState(idOfFileToSubmit)).thenReturn(
                createMalwareScanFileState(createTimestamp, MalwareScanFileState.Status.OK));

        assertTrue(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        // Verify  there was no attempt to submit or re-submit for scanning
        verify(malwareScanOperationService, times(0)).scan(any(MalwareScanRequestDto.class));
        verify(malwareScanOperationService, times(0)).retryScan(any(MalwareScanRequestDto.class));
    }

    private void verifyGiveUpScenario(MalwareScanFileState.Status initialState, MalwareScanFileState.Status finalState) throws Exception {

        Long createTimestamp = retryingDecisionHelper.setUpRetryDurationExceeded(true);

        when(malwareScanPersistenceService.getMalwareScanFileState(idOfFileToSubmit)).thenReturn(
                createMalwareScanFileState(createTimestamp, initialState), createMalwareScanFileState(createTimestamp, finalState));

        // Should ack message, file will be in a final state
        assertTrue(malwareScanSubmissionWorkflow.process(Arrays.asList(malwareScanRequestDto)));

        // Should have not retried the scan for the original malwareScanRequest
        // (retry, update state to "final state", publish state "final state"
        ArgumentCaptor<MalwareScanFileState.Status> updateStatusArgumentCaptor = ArgumentCaptor.forClass(MalwareScanFileState.Status.class);
        ArgumentCaptor<MalwareScanRequestDto> malwareScanRequestDtoArgumentCaptor = ArgumentCaptor.forClass(MalwareScanRequestDto.class);
        ArgumentCaptor<Actor> actorArgumentCaptor = ArgumentCaptor.forClass(Actor.class);
        verify(malwareScanOperationPersistenceService).update(malwareScanRequestDtoArgumentCaptor.capture(), updateStatusArgumentCaptor.capture(), actorArgumentCaptor.capture());
        assertEquals(malwareScanRequestDtoArgumentCaptor.getValue().getAttachmentMetaDto().getFileId(), idOfFileToSubmit);
        assertEquals(updateStatusArgumentCaptor.getValue(), finalState);

        ArgumentCaptor<MalwareScanFileState> publishStateArgumentCaptor = ArgumentCaptor.forClass(MalwareScanFileState.class);
        verify(malwareScanStatusPublisher).publish(publishStateArgumentCaptor.capture());
        MalwareScanFileState state = publishStateArgumentCaptor.getValue();
        assertEquals(state.getStatus(), finalState);
    }

    private MalwareScanResponseDto createMalwareScanResponseDto(MalwareScanResponseDto.Status status) {
        return MalwareScanResponseDto.builder().status(status)
                .malwareScanRequestDto(MalwareScanRequestDto.builder()
                        .attachmentMetaDto(AttachmentMetaDto.builder()
                                .fileId(idOfFileToSubmit)
                                .build()).build())
                .build();
    }

    private Optional<MalwareScanFileState> createMalwareScanFileState(Long createTimestamp, MalwareScanFileState.Status status) {

        return MalwareScanWorflowTestHelper.createMalwareScanFileState(createTimestamp, messageId, status);
    }
}

