package com.symphony.malwarescan;

import static com.symphony.malwarescan.Status.FAILED;
import static com.symphony.malwarescan.Status.OK;

import com.symphony.dlp.efsymproxyconnector.ConnectionIdUsageScenario;
import com.symphony.dlp.efsymproxyconnector.ContainerConnector;
import com.symphony.dlp.efsymproxyconnector.ContainerRpcController;
import com.symphony.dlp.efsymproxyconnector.RLPBlockingRpcChannel;
import com.symphony.dlp.efsymproxyconnector.connectorconfig.ConnectionRequestType;
import com.symphony.dlp.efsymproxyconnector.connectorconfig.ContainerConnectorConfiguration;
import com.symphony.dlp.efsymproxyconnector.metric.SymproxMetricReportCache;
import com.symphony.msgpack.internal.types.Attachment;
import com.symphony.msgpack.internal.types.SocialMessage;
import com.symphony.msgpack.user.User;
import com.symphony.proto320.ServiceException;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;
import com.symphony.services.malware.AttachmentData;

import com.google.common.base.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

/**
 * Malware scanning operations
 * Created by sergii.oliinyk
 */
public class MalwareScanOperationImpl implements MalwareScanOperation {
  private static final Logger LOGGER = LoggerFactory.getLogger(MalwareScanOperationImpl.class);

  private final ContainerConnector connector;
  private final SymproxMetricReportCache metricReportCache;
  private final ContainerConnectorConfiguration connectorConfiguration;

  public MalwareScanOperationImpl(ContainerConnector connector,
      SymproxMetricReportCache metricReportCache,
      ContainerConnectorConfiguration connectorConfiguration) {
    this.connector = connector;
    this.metricReportCache = metricReportCache;
    this.connectorConfiguration = connectorConfiguration;
  }

  /**
   * Builds and sends a request to symproxy for malware scanning for each attachment respectively
   * @param sm
   * @return List<MalwareScanResponse>
   */
  public List<MalwareScanResponse> scan(SocialMessage sm) {
    MalwareScanRequest malwareRQ = getMalwareScanRequest(sm);
    List<MalwareScanResponse> malwareScanRespons = new ArrayList<>();
    for (Attachment attachment : sm.getAttachments()) {
      AttachmentData.AttachmentMeta attachmentMeta = getAttachmentMeta(attachment);
      MalwareScanResponse response = sendReq(malwareRQ, attachmentMeta);
      //TODO save malware scanned entity per attachment to database
      malwareScanRespons.add(response);
    }
    return malwareScanRespons;
  }

  /**
   * Sends a request per attachment in social message
   * @param malwareRQ, attachmentMeta
   * @return List<MalwareScanResponse>
   */
  private MalwareScanResponse sendReq(MalwareScanRequest malwareRQ,
      AttachmentData.AttachmentMeta attachmentMeta) {
    MalwareScanResponse response;
    malwareRQ = malwareRQ.toBuilder().setAttachmentMeta(attachmentMeta).build();
    try {
      LOGGER.info("Sending request for malware scanning: " + malwareRQ);
      response = sendRLPRequest(malwareRQ);
      response = response.toBuilder().setStatus(OK).build();
    } catch (ServiceException e) {
      response = MalwareScanResponse.newBuilder()
          .setStatus(FAILED)
          .setError(e.getLocalizedMessage())
          .build();
      String errMsg = String.format(
          "Failed to send the attachment %s for MalWare scanning with stream id %s",
          malwareRQ.getAttachmentMeta(),
          malwareRQ.getStreamId());
      LOGGER.error(errMsg, e);
    }
    LOGGER.info("Got response from malware scanning: " + response);
    return response;
  }

  //TODO Add stream name, type, scope comes from StreamService in SBE
  /**
   * Creates a message level context for each attachment in a message
   * @param sm
   * @return MalwareScanRequest
   */
  private MalwareScanRequest getMalwareScanRequest(SocialMessage sm) {
    MalwareScanRequest.Builder malwareRequest = MalwareScanRequest.newBuilder();
    malwareRequest.setMessageId(sm.getUniqueMessageId());
    malwareRequest.setSendingPod(sm.getFromPod());
    malwareRequest.setCreationTime(sm.getActualIngestionDate());
    malwareRequest.setStreamId(sm.getThreadIdString());
    User user = sm.getActualFromUser();
    Sender sender = getSender(user);
    malwareRequest.setSender(sender);
    return malwareRequest.build();
  }

  /**
   * Creates a sender details in a message level context
   * @param user
   * @return Sender
   */
  private Sender getSender(User user) {
    return Sender.newBuilder()
        .setId(user.getId())
        .setEmail(user.getEmail())
        .setFirstName(user.getFirstName())
        .setLastName(user.getSurname())
        .setCompanyName(user.getCompanyName()).build();
  }

  /**
   * Creates an attachment meta
   * @param attachment
   * @return Sender
   */
  private AttachmentData.AttachmentMeta getAttachmentMeta(Attachment attachment) {
    return AttachmentData.AttachmentMeta.newBuilder()
        .setName(attachment.getName())
        .setFileId(attachment.getFileId())
        .setContentType(attachment.getContentType())
        .setCreatorId(attachment.getCreatorId())
        .setEncrypted(attachment.isEncrypted())
        .setSizeInBytes(attachment.getSizeInBytes())
        .build();
  }

  /**
   * Sends a request to the random symproxy for malware scanning
   * @param request
   * @return
   * @throws ServiceException
   */
  private MalwareScanResponse sendRLPRequest(MalwareScanRequest request) throws
      ServiceException {
    //create the rpc channel using specified connectionId
    RLPBlockingRpcChannel rpcChannel = new RLPBlockingRpcChannel(
        ConnectionIdUsageScenario.VALID,
        RLPUsageScenario.USE_RLP_SERVICE,
        connector, metricReportCache,
        Optional.absent(),
        Optional.absent(),
        connectorConfiguration, ConnectionRequestType.TEXT_ONLY);
    com.symphony.malwarescan.MalwareScanService.BlockingInterface symproxyMalWare =
        com.symphony.malwarescan.MalwareScanService.newBlockingStub(rpcChannel);
    return symproxyMalWare.performScanning(new ContainerRpcController(), request);
  }
}
