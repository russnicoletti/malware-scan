package com.symphony.malware.scan.workflow;

import com.codahale.metrics.Timer;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import util.TimestampMillisSupplier;

import java.util.Date;
import java.util.concurrent.TimeUnit;

class RetrySubmissionWorkflow {
    private static final Logger LOGGER = LoggerFactory.getLogger(RetrySubmissionWorkflow.class);
    private final MalwareScanSubmissionWorkflowHelper malwareScanSubmissionWorkflowHelper;
    private final RetryDecider retryDecider;
    private final TimestampMillisSupplier timestampMillisSupplier;

    RetrySubmissionWorkflow(MalwareScanSubmissionWorkflowHelper malwareScanSubmissionWorkflowHelper,
                            RetryDecider retryDecider,
                            TimestampMillisSupplier timestampMillisSupplier) {
        this.malwareScanSubmissionWorkflowHelper = malwareScanSubmissionWorkflowHelper;
        this.retryDecider = retryDecider;
        this.timestampMillisSupplier = timestampMillisSupplier;
    }

    /**
     * Determines if it is time to re-submit a request for scanning and if so re-submits the request
     * for scanning and increments the metric corresponding to the number of times request have
     * been re-submitted for scanning. Otherwise, returns.
     * @param malwareScanRequestDto
     * @param malwareScanFileState
     * @return boolean indicating whether the request was re-submitted
     * @throws MalwareScanException
     */
    boolean resubmit(
        final int retryInterval,
        final MalwareScanRequestDto malwareScanRequestDto,
        final MalwareScanFileState malwareScanFileState) throws MalwareScanException {

        // Is it too soon to retry?
        if (!retryDecider.retryIntervalExceeded(retryInterval, malwareScanFileState.getLastSubmissionAttemptTimestamp())) {
            LOGGER.info("Returning 'false' for {} (don't resubmit this request)", malwareScanFileState.getFileId());
            return false;
        }

        LOGGER.info("ok to re-submit file {} for scanning. {} seconds have elapsed sine the last submission attempt ({}) - current time is {}",
                malwareScanFileState.getFileId(),
                retryInterval,
                new Date(malwareScanFileState.getLastSubmissionAttemptTimestamp()),
                new Date());

        // Re-submit for scanning
        malwareScanSubmissionWorkflowHelper.getMalwareScanningMetrics().countOfRetrySubmission().mark();

        MalwareScanResponseDto malwareScanResponseDto = malwareScanSubmissionWorkflowHelper.retryScan(malwareScanRequestDto);

        if (malwareScanResponseDto.getStatus() == MalwareScanResponseDto.Status.SUCCESS) {

            // Record time taken between initial failed submission and successful retry
            // Note: the Timer metric includes a count of the number of events
            long secondsBetweenInitialFailedRequestAndSuccessfulRetry = (timestampMillisSupplier.now() - malwareScanFileState.getCreateTimestamp()) / 1000;
            Timer timeBetweenInitialFailedRequestAndSuccessfulRetryTimer =
                    malwareScanSubmissionWorkflowHelper.getMalwareScanningMetrics().timeBetweenInitialFailedRequestAndSuccessfulRetry();
            timeBetweenInitialFailedRequestAndSuccessfulRetryTimer.update(secondsBetweenInitialFailedRequestAndSuccessfulRetry, TimeUnit.SECONDS);

            LOGGER.info("secondsBetweenInitialFailedRequestAndSuccessfulRetry: " + secondsBetweenInitialFailedRequestAndSuccessfulRetry);
        }

        return true;
    }
}
