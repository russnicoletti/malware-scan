package com.symphony.malware.scan.service;

import com.symphony.malware.scan.metrics.MalwareScanningMetrics;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;

import lombok.extern.slf4j.Slf4j;

import java.util.Set;
import java.util.stream.Collectors;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;

@Slf4j
public class MalwareScanValidationService {

    private final Validator validator;
    private final MalwareScanningMetrics malwareScanMetrics;

    public MalwareScanValidationService(final MalwareScanningMetrics malwareScanMetrics) {
        this.malwareScanMetrics = malwareScanMetrics;
        this.validator = Validation.buildDefaultValidatorFactory().getValidator();
    }

    public MalwareScanResponseDto validate(final MalwareScanRequestDto malwareScanRequestDto) {
        final Set<ConstraintViolation<MalwareScanRequestDto>> constraintViolations = validator.validate(malwareScanRequestDto);

        if (constraintViolations.isEmpty()) {
            return MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build();
        } else {
            final String error = constraintViolations.stream().map(cv -> cv.getPropertyPath() + " " + cv.getMessage()).collect(Collectors.joining(System.lineSeparator()));
            LOGGER.error("Error encountered {} while validating malware scan request {}", error, malwareScanRequestDto);

            malwareScanMetrics.countOfFailValidationRequests().mark();
            return MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.FAIL_VALIDATION).error(error).build();
        }
    }

}
