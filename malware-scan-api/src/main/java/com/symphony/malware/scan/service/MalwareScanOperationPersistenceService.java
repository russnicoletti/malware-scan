package com.symphony.malware.scan.service;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.MalwareScanFileMapping;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.model.Sender;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.persistence.exception.MalwareScanStatusTransferException;
import com.symphony.malware.scan.persistence.service.MalwareScanPersistenceService;
import com.symphony.malware.scan.metrics.MalwareScanningMetrics;

import com.google.common.base.Preconditions;
import lombok.extern.slf4j.Slf4j;
import util.TimestampMillisSupplier;

import java.util.Date;

/**
 * Creates and updates entries in the persistence layer when malware scan operation is requested
 */
@Slf4j
public class MalwareScanOperationPersistenceService {

    private final MalwareScanPersistenceService malwareScanPersistenceService;
    private final MalwareScanningMetrics malwareScanMetrics;
    private final TimestampMillisSupplier timestampMillisSupplier;

    public MalwareScanOperationPersistenceService(
            final MalwareScanPersistenceService malwareScanPersistenceService,
            final MalwareScanningMetrics malwareScanMetrics,
            final TimestampMillisSupplier timestampMillisSupplier) {
        this.malwareScanPersistenceService = malwareScanPersistenceService;
        this.malwareScanMetrics = malwareScanMetrics;
        this.timestampMillisSupplier = timestampMillisSupplier;
    }

    /**
     * Creates a new MalwareScanFileState in Pending status if there isn't one for the given
     * request.
     * Creates the entry on behalf of the Actor.SYMPHONY
     * @param malwareScanRequestDto the request which contains the details for the State
     * @return a response DTO with SUCCESS status if the state was created or PROCESSING if there
     * was already a state. FAIL_CREATE_STATE if there is an exception calling the persistence service.
     */
    public MalwareScanResponseDto create(MalwareScanRequestDto malwareScanRequestDto) throws PersistentException, MalwareScanException {

        final MalwareScanFileState pendingMSFileState = MalwareScanFileState.builder()
            .fileId(malwareScanRequestDto.getAttachmentMetaDto().getFileId())
            .status(MalwareScanFileState.Status.PENDING)
            .contentType(malwareScanRequestDto.getAttachmentMetaDto().getContentType())
            .originalStreamId(malwareScanRequestDto.getStreamId())
            .originalMessageId(malwareScanRequestDto.getMessageId())
            .lastSubmissionAttemptTimestamp(timestampMillisSupplier.now())
            .build();

        try {
            MalwareScanFileState existentState = malwareScanPersistenceService
                .putIfAbsent(pendingMSFileState, Actor.SYMPHONY);

            // No matter if the MalwareScanFileState was already present or not, the mapping
            // is updated for every processed MalwareScanRequest object.
            // It can happen that in Blast scenarios, another thread already updated the state
            // but this one has to update the mapping.
            insertMapping(malwareScanRequestDto);

            if (existentState == null) {
                LOGGER.info("Success to create malware scan information {}", pendingMSFileState);
                return MalwareScanResponseDto.builder()
                    .status(MalwareScanResponseDto.Status.SUCCESS).error("").build();
            } else {
                LOGGER.warn("Found already existing malware scan information with status {} for the "
                    + "attachment with fileId {}", existentState.getStatus(), existentState.getFileId());
                return MalwareScanResponseDto.builder()
                    .status(MalwareScanResponseDto.Status.STATE_PRESENT).error("").build();
            }
        } catch (PersistentException | MalwareScanException e) {
            String errorMsg = String.format("Failed to create malware scan information for the "
                + "attachment %s with stream id %s and message id %s",
                malwareScanRequestDto.getAttachmentMetaDto(), malwareScanRequestDto.getStreamId(),
                malwareScanRequestDto.getMessageId());
            LOGGER.error(errorMsg, e);
            malwareScanMetrics.countOfFailCreateState().mark();
            throw e;
        }
    }

    /**
     * Upates the 'lastSubmissionAttemptTimestamp' of the MalwareScanFileState table record for the
     * file specified in the request and creates another Pending entry in the MalwareScanFileState history
     * table.
     * If the status of the record in the MalwareScanFileState table is not Pending, the method returns
     * FAIL_UPDATE_PENDING (the file should not be resubmitted for scanning if the status of the file
     * has been changed and is no longer Pending).
     * @param malwareScanRequestDto
     * @return
     */
    public MalwareScanResponseDto prepareForReScan(MalwareScanRequestDto malwareScanRequestDto) throws PersistentException, MalwareScanException {

        try {
            MalwareScanFileState malwareScanFileState = getFileState(malwareScanRequestDto);

            Preconditions.checkArgument(
                malwareScanFileState.getStatus() == MalwareScanFileState.Status.PENDING ||
                malwareScanFileState.getStatus() == MalwareScanFileState.Status.SUBMITTED, "invalid status for re-scan: " + malwareScanFileState.getStatus());

            LOGGER.info("Found {} record for {} (version ({}), updating lastSubmissionAttemptTimestamp to {}",
                malwareScanFileState.getStatus(), malwareScanFileState.getFileId(), malwareScanFileState.getVersion(), new Date(timestampMillisSupplier.now()));

            MalwareScanFileState newMalwareScanFileState =
                    malwareScanFileState.toBuilder()
                            .status(MalwareScanFileState.Status.PENDING)
                            .lastSubmissionAttemptTimestamp(timestampMillisSupplier.now())
                            .build();
            malwareScanPersistenceService.putMalwareScanFileState(newMalwareScanFileState, Actor.SYMPHONY);

            LOGGER.info("Updated {} MalwareScanFileState record: {}", newMalwareScanFileState.getStatus(), newMalwareScanFileState);

            return MalwareScanResponseDto.builder()
                    .status(MalwareScanResponseDto.Status.SUCCESS).error("").build();
        } catch (PersistentException | MalwareScanException e) {
            LOGGER.error("Error preparing for re-submission for scanning. Request: {}. Exception: {}", malwareScanRequestDto, e);
            throw e;
        }
    }

    public void insertMapping(final MalwareScanRequestDto malwareScanRequestDto)
        throws PersistentException {
        final MalwareScanFileMapping malwareScanFileMapping = MalwareScanFileMapping.builder()
            .fileId(malwareScanRequestDto.getAttachmentMetaDto().getFileId())
            .streamId(malwareScanRequestDto.getStreamId())
            .messageId(malwareScanRequestDto.getMessageId())
            .streamName(malwareScanRequestDto.getStreamName())
            .streamType(malwareScanRequestDto.getStreamType())
            .sender(java.util.Optional.ofNullable(malwareScanRequestDto.getUser())
                .map(user -> Sender.builder()
                    .id(user.getUserId())
                    .email(user.getEmail())
                    .build())
                .orElse(null)
            ).build();

        malwareScanPersistenceService.putMalwareScanFileMapping(malwareScanFileMapping);
    }

    /**
     * Update an entry in the malware scan file state table with the specified status.
     * Currently, this method is used by `UpdateMalwareScanProcessor` to set the status
     * of a file being submitted for scanning to SUBMITTED as well as by the malware scan
     * submission workflow to update the status of a file to FAILED_SUBMIT or FAILED_UPDATE.
     * To support the 'resubmit submitted' workflow, this method sets the
     * `lastSubmissionAttemptTimestamp`. This is not necessary in the case of FAILED_SUBMIT
     * and FAILED_UPDATE but it is also not harmful.
     * @param malwareScanRequestDto {@link MalwareScanRequestDto} to store
     * @param status {@link MalwareScanFileState.Status} status to persist
     * @param actor {@link Actor} who performed status change
     * @return object which indicates whether information was stored successfully
     */
    public MalwareScanResponseDto update(
        final MalwareScanRequestDto malwareScanRequestDto, final MalwareScanFileState.Status status, final Actor actor
    ) throws PersistentException, MalwareScanException {

        MalwareScanFileState malwareScanFileState = getFileState(malwareScanRequestDto).toBuilder().status(status).lastSubmissionAttemptTimestamp(timestampMillisSupplier.now()).build();
        return doUpdate(malwareScanRequestDto, malwareScanFileState, actor);
    }

    private MalwareScanFileState getFileState(MalwareScanRequestDto malwareScanRequestDto) throws MalwareScanException, PersistentException {
        MalwareScanFileState malwareScanFileState;
        try {
            String fileId = malwareScanRequestDto.getAttachmentMetaDto().getFileId();
            malwareScanFileState = malwareScanPersistenceService.getMalwareScanFileState(fileId)
                .orElseThrow(
                    () -> new MalwareScanException("Existing malware scan state information was not found for file id "
                        + fileId)).toBuilder().build();
        } catch (PersistentException | MalwareScanException e) {
            malwareScanMetrics.countOfFailUpdateState().mark();
            throw e;
        }

        return malwareScanFileState;
    }

    public MalwareScanResponseDto doUpdate(
        final MalwareScanRequestDto malwareScanRequestDto, final MalwareScanFileState malwareScanFileState, final Actor actor
    ) throws PersistentException, MalwareScanException {
        try {
            malwareScanPersistenceService.putMalwareScanFileState(malwareScanFileState, actor);
        } catch (MalwareScanStatusTransferException msste) {
            // Let caller decide what to do, if status transfer fails
            throw msste;
        } catch (PersistentException | MalwareScanException e) {
            final String error = "Failed to update malware scan information for the attachment " + malwareScanRequestDto.getAttachmentMetaDto()
                + ". MalwareScanFileState: " + malwareScanFileState;
            LOGGER.error(error, e);

            malwareScanMetrics.countOfFailUpdateState().mark();
            throw e;
        }

        LOGGER.info("Success to update malware scan state to {} for the attachment {} with stream id {} and message id {}",
            malwareScanFileState, malwareScanRequestDto.getAttachmentMetaDto(), malwareScanRequestDto.getStreamId(), malwareScanRequestDto.getMessageId());
        return MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.SUCCESS).error("").build();
    }
}
