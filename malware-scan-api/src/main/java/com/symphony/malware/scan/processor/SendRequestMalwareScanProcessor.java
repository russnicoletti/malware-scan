package com.symphony.malware.scan.processor;

import com.symphony.container.connector.ConnectionIdUsageScenario;
import com.symphony.container.connector.ContainerConnector;
import com.symphony.container.connector.ContainerRpcController;
import com.symphony.container.connector.GenericRLPBlockingRpcChanel;
import com.symphony.container.connector.NonCircuitBreakingRlpCallExecutor;
import com.symphony.container.connector.config.ConnectionRequestType;
import com.symphony.container.connector.config.ContainerConnectorConfiguration;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.converter.ProtoDtoConverter;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.proto320.BlockingRpcChannel;
import com.symphony.proto320.ServiceException;
import com.symphony.remoteservice.longpoll.client.RLPService;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;

import com.google.common.base.Optional;
import lombok.extern.slf4j.Slf4j;

/**
 * Sends malware scan request to the Symproxy
 */
@Slf4j
public class SendRequestMalwareScanProcessor implements Processor<MalwareScanRequestDto, MalwareScanResponseDto> {

    private static final String MALWARE_SCAN_RLP_SERVICE_NAME = "scanAttachmentForMalwareService";

    private final ContainerConnector containerConnector;
    private final SymproxMetricReportCache symproxMetricReportCache;
    private final ContainerConnectorConfiguration containerConnectorConfiguration;
    private final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter;
    private final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter;

    public SendRequestMalwareScanProcessor(
        final ContainerConnector containerConnector,
        final SymproxMetricReportCache symproxMetricReportCache,
        final ContainerConnectorConfiguration containerConnectorConfiguration,
        final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter,
        final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter
    ) {
        this.containerConnector = containerConnector;
        this.symproxMetricReportCache = symproxMetricReportCache;
        this.containerConnectorConfiguration = containerConnectorConfiguration;
        this.malwareScanRequestProtoDtoConverter = malwareScanRequestProtoDtoConverter;
        this.malwareScanResponseProtoDtoConverter = malwareScanResponseProtoDtoConverter;
    }

    @Override
    public MalwareScanResponseDto process(final MalwareScanRequestDto malwareScanRequestDto) {
        return sendMalwareScanRequest(malwareScanRequestDto).toBuilder().malwareScanRequestDto(malwareScanRequestDto).build();
    }

    /**
     * Sends a malware scan request
     * @param malwareScanRequestDto {@link MalwareScanRequestDto}
     * @return {@link MalwareScanResponseDto}
     */
    private MalwareScanResponseDto sendMalwareScanRequest(final MalwareScanRequestDto malwareScanRequestDto) {
        LOGGER.info("Submit malware scan request {}", malwareScanRequestDto);

        try {
            final MalwareScanRequest malwareScanRequest = malwareScanRequestProtoDtoConverter.toProto(malwareScanRequestDto);
            LOGGER.info("Sending request for malware scanning: {}", malwareScanRequest);
            final MalwareScanResponse malwareScanResponse = sendRLPRequest(malwareScanRequest);
            LOGGER.info("Received response from malware scanning: {}", malwareScanResponse);
            return malwareScanResponseProtoDtoConverter.toDto(malwareScanResponse);
        } catch (Exception e) {
            final String error = "Failed to send the malware scan request " + malwareScanRequestDto + " with stream id "
                + malwareScanRequestDto.getStreamId() + " and message id " + malwareScanRequestDto.getMessageId() + " for malware scanning";
            LOGGER.error(error, e);

            return MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.FAIL_SEND_REQUEST)
                .error(error + System.lineSeparator() + e.getLocalizedMessage()).build();
        }
    }

    /**
     * Sends a request to the symproxy for malware scanning
     * @param malwareScanRequest {@link MalwareScanRequest}
     * @return {@link MalwareScanResponse}
     * @throws ServiceException
     */
    private MalwareScanResponse sendRLPRequest(final MalwareScanRequest malwareScanRequest) throws ServiceException {
        final BlockingRpcChannel blockingRpcChannel = new GenericRLPBlockingRpcChanel(
                ConnectionIdUsageScenario.NOT_APPLICABLE, RLPUsageScenario.USE_RLP_SERVICE, containerConnector,
                symproxMetricReportCache, Optional.of(new RLPService(MALWARE_SCAN_RLP_SERVICE_NAME)), Optional.absent(),
                containerConnectorConfiguration, ConnectionRequestType.TEXT_ONLY, new NonCircuitBreakingRlpCallExecutor());

        com.symphony.malware.scan.MalwareScanService.BlockingInterface symproxyMalware =
            com.symphony.malware.scan.MalwareScanService.newBlockingStub(blockingRpcChannel);

        return symproxyMalware.submitForScanning(new ContainerRpcController(), malwareScanRequest);
    }

}
