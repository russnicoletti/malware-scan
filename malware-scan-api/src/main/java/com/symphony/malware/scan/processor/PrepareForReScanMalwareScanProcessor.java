package com.symphony.malware.scan.processor;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.service.MalwareScanOperationPersistenceService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PrepareForReScanMalwareScanProcessor implements Processor<MalwareScanRequestDto, MalwareScanResponseDto> {

    private final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;
    private final Logger LOGGER = LoggerFactory.getLogger(PrepareForReScanMalwareScanProcessor.class);

    public PrepareForReScanMalwareScanProcessor(MalwareScanOperationPersistenceService malwareScanOperationPersistenceService) {
        this.malwareScanOperationPersistenceService = malwareScanOperationPersistenceService;
    }

    @Override
    public MalwareScanResponseDto process(MalwareScanRequestDto malwareScanRequestDto) throws MalwareScanException {
        try {
            return malwareScanOperationPersistenceService.prepareForReScan(malwareScanRequestDto)
                    .toBuilder().malwareScanRequestDto(malwareScanRequestDto).build();
        } catch (PersistentException e) {
            LOGGER.error("Error preparing file {} for re-submission. Exception: {}",
                    malwareScanRequestDto.getAttachmentMetaDto().getFileId(), e);

            // 'processors' throw MalwareScanException to keep interface clean
            throw new MalwareScanException(e);
        }
    }
}
