package com.symphony.malware.scan.processor;

import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.persistence.exception.MalwareScanStatusTransferException;
import com.symphony.malware.scan.service.MalwareScanOperationPersistenceService;

import lombok.extern.slf4j.Slf4j;

/**
 * Inserts initial malware scan file state with status PENDING
 */
@Slf4j
public class CreateStateMalwareScanProcessor implements Processor<MalwareScanRequestDto, MalwareScanResponseDto> {

    private final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;

    public CreateStateMalwareScanProcessor(
        final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService
    ) {
        this.malwareScanOperationPersistenceService = malwareScanOperationPersistenceService;
    }

    @Override
    public MalwareScanResponseDto process(final MalwareScanRequestDto malwareScanRequestDto) {
        LOGGER.info("Set malware scan state to PENDING for malware scan request {}", malwareScanRequestDto);

        try {
            return malwareScanOperationPersistenceService.create(malwareScanRequestDto, MalwareScanFileState.Status.PENDING, Actor.SYMPHONY)
                .toBuilder().malwareScanRequestDto(malwareScanRequestDto).build();
        } catch (MalwareScanStatusTransferException e) {
            final String error = e.getMessage() + " for the attachment " + malwareScanRequestDto.getAttachmentMetaDto()
                + " with stream id " + malwareScanRequestDto.getStreamId() + " and message id " + malwareScanRequestDto.getMessageId();
            LOGGER.error(error, e);

            return MalwareScanResponseDto.builder().status(MalwareScanResponseDto.Status.FAIL_CREATE_STATE)
                .error(error).malwareScanRequestDto(malwareScanRequestDto).build();
        }
    }
}
