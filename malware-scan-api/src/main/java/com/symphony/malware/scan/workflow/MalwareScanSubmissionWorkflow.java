package com.symphony.malware.scan.workflow;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.metrics.MalwareScanningMetrics;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.persistence.service.MalwareScanPersistenceService;
import com.symphony.malware.scan.service.MalwareScanOperationPersistenceService;
import com.symphony.malware.scan.service.MalwareScanOperationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import util.TimestampMillisSupplier;

import java.util.List;
import java.util.Optional;

public class MalwareScanSubmissionWorkflow {
    private final MalwareScanSubmissionWorkflowHelper malwareScanSubmissionWorkflowHelper;
    private static final Logger LOGGER = LoggerFactory.getLogger(MalwareScanSubmissionWorkflow.class);
    private final InitialSubmissionAttemptWorkflow initialSubmissionAttemptWorkflow;
    private final RetrySubmissionWorkflow retrySubmissionWorkflow;
    private final RetryDecider retryDecider;
    private final MalwareScanSubmissionWorkflowConfigCache malwareScanSubmissionWorkflowConfigCache;

    public MalwareScanSubmissionWorkflow(
            MalwareScanPersistenceService malwareScanPersistenceService,
            MalwareScanOperationService malwareScanOperationService,
            MalwareScanOperationPersistenceService malwareScanOperationPersistenceService,
            MalwareScanSubmissionWorkflowConfigCache malwareScanSubmissionWorkflowConfigCache,
            MalwareScanStatusPublisher malwareScanStatusPublisher,
            MalwareScanningMetrics malwareScanningMetrics,
            TimestampMillisSupplier timestampMillisSupplier) {

        retryDecider = new RetryDecider(timestampMillisSupplier);
        this.malwareScanSubmissionWorkflowConfigCache = malwareScanSubmissionWorkflowConfigCache;

        malwareScanSubmissionWorkflowHelper =
            new MalwareScanSubmissionWorkflowHelper(
                    malwareScanOperationService,
                    malwareScanPersistenceService,
                    malwareScanOperationPersistenceService,
                    malwareScanStatusPublisher,
                    malwareScanningMetrics);

        initialSubmissionAttemptWorkflow = new InitialSubmissionAttemptWorkflow(malwareScanSubmissionWorkflowHelper);
        retrySubmissionWorkflow = new RetrySubmissionWorkflow(
                malwareScanSubmissionWorkflowHelper, retryDecider, timestampMillisSupplier);
    }

    /**
     * Initiates the malware scan submission workflow.
     * @return true if all the attachments in all the requests are in a final state
     *         false otherwise
     */
    public boolean process(final List<MalwareScanRequestDto> malwareScanRequestDtos) {

        // This represents whether all of the attachments in the list of MalwareScanRequest objects
        // are in a final state after the MalwareScanRequests are processed. After processing all the
        // attachments in the request, if any are not in a final state the state of this variable will
        // be 'false'. Only if all the attachments in the request are in a final state should this
        // variable be 'true'.
        // The value defaults to true to make use of the '&=' logical operator.
        boolean attachmentsInFinalState = true;

        // For each MalwareScanRequestDto
        for (MalwareScanRequestDto malwareScanRequestDto: malwareScanRequestDtos) {
            LOGGER.info("Processing fileId {}, messageId {}", malwareScanRequestDto.getAttachmentMetaDto().getFileId(), malwareScanRequestDto.getMessageId());

            try {
                Optional<MalwareScanFileState> malwareScanFileStateOptional =
                   malwareScanSubmissionWorkflowHelper.getState(malwareScanRequestDto.getAttachmentMetaDto().getFileId());

                // Determine if the attachment has already been submitted
                if (malwareScanFileStateOptional.isPresent()) {

                    MalwareScanFileState malwareScanFileState = malwareScanFileStateOptional.get();
                    LOGGER.info("{} has been submitted previously, status is {}", malwareScanFileState.getFileId(), malwareScanFileState.getStatus());
                    LOGGER.info("MalwareScanFileState record loaded in main workflow: {}", malwareScanFileState);

                    // Determine if the attachment in the request is already being processed as part of another message
                    // (message blast scenario where the message with the attachment is sent to multiple streams resulting
                    // in multiple messages being sent potentially resulting in two different nodes processing each message).
                    // If so, do not process the request
                    if (isRequestFromDifferentMessage(malwareScanFileState, malwareScanRequestDto)) {
                        LOGGER.info("{} has been submitted previously with another message, status is {}",
                            malwareScanFileState.getFileId(), malwareScanFileState.getStatus());

                        malwareScanSubmissionWorkflowHelper.handleMessageFromAnotherRequest(malwareScanRequestDto);
                        continue;
                    }

                    // Determine if the file is in a final state. If so, continue processing the other attachments in the request (if any)
                    if (CheckForUpdateWorkflow.inFinalState(malwareScanFileState)) {
                        continue;
                    }

                    // Determine if the maximum retry duration has been exceeded for this request
                    if (retryDecider.shouldStopRetryAttempts(
                            malwareScanSubmissionWorkflowConfigCache.get().getMaxRetryDurationSeconds(),
                            malwareScanFileState.getCreateTimestamp())) {

                        handleUpdateToFailedFinalState(malwareScanRequestDto, malwareScanFileState);
                        continue;
                    }

                    // At this point, the file is not in a final state nor has the maximum amount of time to process the file
                    // been exceeded. Therefore, the request will need to be replayed to ensure the file has been updated to
                    // a final state or to re-submit the file for scanning.
                    attachmentsInFinalState = false;

                    // The message containing the MalwareScanRequest is being replayed and the attachment is not in a final state.
                    // If it has not yet been successfully submitted or it was submitted and the scanner returned an error indicating
                    // an intermittent failure, resubmit it for scanning when the "resubmit not yet submitted"
                    // interval has elapsed since the last submission attempt.
                    if ((MalwareScanFileState.Status.PENDING == malwareScanFileState.getStatus() ||
                        MalwareScanFileState.Status.SCAN_ERROR == malwareScanFileState.getStatus()) &&
                        retrySubmissionWorkflow.resubmit(
                            malwareScanSubmissionWorkflowConfigCache.get().getResubmitNotSubmittedIntervalSeconds(),
                            malwareScanRequestDto,
                            malwareScanFileState)) {
                        continue;
                    }

                    // If the MalwareScanRequest has been successfully submitted (and it has not yet been updated to a final
                    // state -- as is the case when the flow reaches this point) resubmit it for scanning when the "resubmit
                    // submitted interval" has elapsed since the last submission attempt.
                    if (MalwareScanFileState.Status.SUBMITTED == malwareScanFileState.getStatus()) {
                        retrySubmissionWorkflow.resubmit(
                            malwareScanSubmissionWorkflowConfigCache.get().getResubmitSubmittedIntervalSeconds(),
                            malwareScanRequestDto,
                            malwareScanFileState);
                    }

                    // The  workflow is complete for this request
                    continue;
                }

                // The attachment has not yet been submitted.
                LOGGER.info("File {} has not yet been submitted. Submit it now", malwareScanRequestDto.getAttachmentMetaDto().getFileId());
                initialSubmissionAttemptWorkflow.processRequest(malwareScanRequestDto);

                // Replay request to to ensure the file has been updated to a final state or to re-submit the file for scanning
                // if this initial submission did not succeed
                attachmentsInFinalState = false;

            } catch (PersistentException | MalwareScanException | MalwareScanStatusPublisherException e) {
                LOGGER.info("Caught exception processing {} in MalwareScanSubmissionWorkflow: {} -- replay message",
                        malwareScanRequestDto, e);

                // Record metric in order to alert
                malwareScanSubmissionWorkflowHelper.getMalwareScanningMetrics().countOfRequestFailedDueToException().mark();

                // Replay message on exception. The problem could resolve itself. Worst case is the message will replay a few times and then
                // when the retry duration has been exceeded the file will be put into a final state.
                // If the exception occurs while updating the state to the final, failed state after concluding the maximum retry duration has
                // been exceeded, and the exception condition persists, the message will replay until moved to the DLQ. This is acceptable
                // behavior because it should occur very infrequently and not handling that as a special case keeps the code and
                // logic simple.
                attachmentsInFinalState = false;
            } finally {
                LOGGER.info("At the end of the workflow for {}, attachmentsInFinalState: {}", malwareScanRequestDto.getAttachmentMetaDto().getFileId(), attachmentsInFinalState);
            }
        }

        return attachmentsInFinalState;
    }

    /**
     * @param malwareScanFileState
     * @param malwareScanRequestDto
     * @return true if the malware-scan request does not correspond to the same message as the MalwareScanFileState record
     */
    private boolean isRequestFromDifferentMessage(MalwareScanFileState malwareScanFileState, MalwareScanRequestDto malwareScanRequestDto) {
        return !malwareScanFileState.getOriginalMessageId().equals(malwareScanRequestDto.getMessageId());
    }

    /**
     * Updates and publishes the final state for the specified MalwareScanRequest. Does not catch exceptions. Let's the caller
     * decide how to handle the exception(s).
     * @param malwareScanRequestDto
     * @param malwareScanFileState
     * @throws MalwareScanException
     * @throws MalwareScanStatusPublisherException
     * @throws PersistentException
     */
    private void handleUpdateToFailedFinalState(MalwareScanRequestDto malwareScanRequestDto,
                                                MalwareScanFileState malwareScanFileState) throws MalwareScanException, MalwareScanStatusPublisherException, PersistentException {

        malwareScanSubmissionWorkflowHelper.handleGiveUpRetry(malwareScanRequestDto, malwareScanFileState.getStatus());

        // Record metric in order to alert
        malwareScanSubmissionWorkflowHelper.getMalwareScanningMetrics().countOfRequestFailedDueToException().mark();
    }
}
