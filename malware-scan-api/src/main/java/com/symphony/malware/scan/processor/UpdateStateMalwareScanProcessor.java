package com.symphony.malware.scan.processor;

import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.service.MalwareScanOperationPersistenceService;

import lombok.extern.slf4j.Slf4j;

/**
 * Updates existing malware scan file state with status SUBMITTED
 */
@Slf4j
public class UpdateStateMalwareScanProcessor extends MalwareScanProcessor {

    private final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;

    public UpdateStateMalwareScanProcessor(
        final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService
    ) {
        this.malwareScanOperationPersistenceService = malwareScanOperationPersistenceService;
    }

    @Override
    public MalwareScanResponseDto process(final MalwareScanRequestDto malwareScanRequestDto) {
        /*
         * Please mind the fact, that persistence might fail here (e.g. due to storage unavailability),
         * but we ignore it, as it is not critical if status will not transfer from PENDING to SUBMITTED at this point,
         * but we should handle this case, when response from Malware Scanner is received
         */
        final MalwareScanResponseDto malwareScanResponseDto = malwareScanOperationPersistenceService
            .update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY)
            .toBuilder().malwareScanRequestDto(malwareScanRequestDto).build();

        if (MalwareScanResponseDto.Status.PROCESSED.equals(malwareScanResponseDto.getStatus())) {
            return getNext(malwareScanResponseDto).process(malwareScanRequestDto);
        } else {
            LOGGER.error("Error while persisting malware scan request {}", malwareScanResponseDto);
            return malwareScanResponseDto;
        }
    }

}
