package com.symphony.malware.scan.service;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanMapping;
import com.symphony.malware.scan.model.MalwareScanPersistenceResponse;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanState;
import com.symphony.malware.scan.model.Sender;
import com.symphony.malware.scan.persistence.exception.MalwareScanUpdateException;
import com.symphony.malware.scan.persistence.service.MalwarePersistenceService;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MalwareScanPersistenceServiceImpl implements MalwareScanPersistenceService {

    private static final Logger LOGGER = LoggerFactory.getLogger(MalwareScanOperationServiceImpl.class);

    private final MalwarePersistenceService malwarePersistenceService;

    public MalwareScanPersistenceServiceImpl(
        final MalwarePersistenceService malwarePersistenceService
    ) {
        this.malwarePersistenceService = malwarePersistenceService;
    }

    @Override
    public MalwareScanPersistenceResponse create(
        final MalwareScanRequestDto malwareScanRequestDto,
        final AttachmentMetaDto attachmentMetaDto
    ) {
        try {
            final MalwareScanState malwareScanState = MalwareScanState.builder()
                .fileId(attachmentMetaDto.getFileId())
                .status(MalwareScanState.Status.PENDING)
                .sizeInBytes(attachmentMetaDto.getSizeInBytes())
                .contentType(attachmentMetaDto.getContentType())
                // TODO We might decide not to store filename, as we might need to ecnrypt it before storing
//                    .fileName(attachmentMetaDto.getName())
                .creatorId(Long.toString(attachmentMetaDto.getCreatorId()))
                // TODO Not sure what to put into original stream id field
                .originalStreamId(null)
                // TODO Not sure what to put into original message id field
                .originalMessageId(null)
                .build();

            final MalwareScanMapping malwareScanMapping = MalwareScanMapping.builder()
                .fileId(attachmentMetaDto.getFileId())
                .streamId(malwareScanRequestDto.getStreamId())
                .messageId(malwareScanRequestDto.getMessageId())
                .streamName(malwareScanRequestDto.getStreamName())
                .streamType(malwareScanRequestDto.getStreamType())
                .sendingPod(Integer.toString(malwareScanRequestDto.getFromPod()))
                .sender(java.util.Optional.ofNullable(malwareScanRequestDto.getUser())
                        .map(user -> Sender.builder()
                            .id(user.getUserId())
                            // TODO We might decide not to store user email, as it is a sensitive information
//                            .email(user.getEmail())
                            // TODO We might decide not to store user first name, as it is a sensitive information
//                            .firstName(user.getFirstName())
                            // TODO We might decide not to store user last name, as it is a sensitive information
//                            .lastName(user.getLastName())
                            .build())
                        .orElse(null)
                ).build();

            malwarePersistenceService.putMalwareScanState(malwareScanState, Actor.MALWARE_SCANNER);
            malwarePersistenceService.putMalwareScanMapping(malwareScanMapping);
        } catch (PersistentException | MalwareScanUpdateException e) {
            final String error = "Failed to create malware scan information for the attachment " + attachmentMetaDto
                + " with stream id " + malwareScanRequestDto.getStreamId() + " and message id " + malwareScanRequestDto.getMessageId();
            LOGGER.error(error, e);

            return MalwareScanPersistenceResponse.builder().status(Status.FAILED).error(error).build();
        }

        LOGGER.info("Success to create malware scan information for the attachment {} with stream id {} and message id {}",
            attachmentMetaDto, malwareScanRequestDto.getStreamId(), malwareScanRequestDto.getMessageId());
        return MalwareScanPersistenceResponse.builder().status(Status.OK).build();
    }

    @Override
    public MalwareScanPersistenceResponse update(
        final MalwareScanRequestDto malwareScanRequestDto,
        final AttachmentMetaDto attachmentMetaDto
    ) {
        try {
            final MalwareScanState malwareScanState = malwarePersistenceService.getMalwareScanState(attachmentMetaDto.getFileId())
                .orElseThrow(() -> new MalwareScanUpdateException("Existing malware scan state information was not found for file id " + attachmentMetaDto.getFileId()))
                .toBuilder().status(MalwareScanState.Status.SUBMITTED).build();

            malwarePersistenceService.putMalwareScanState(malwareScanState, Actor.MALWARE_SCANNER);
        } catch (PersistentException | MalwareScanUpdateException e) {
            final String error = "Failed to update malware scan information for the attachment " + attachmentMetaDto
                + " with stream id " + malwareScanRequestDto.getStreamId() + " and message id " + malwareScanRequestDto.getMessageId();
            LOGGER.error(error, e);

            return MalwareScanPersistenceResponse.builder().status(Status.FAILED).error(error).build();
        }

        LOGGER.info("Success to update malware scan information for the attachment {} with stream id {} and message id {}",
            attachmentMetaDto, malwareScanRequestDto.getStreamId(), malwareScanRequestDto.getMessageId());
        return MalwareScanPersistenceResponse.builder().status(Status.OK).build();
    }

}
