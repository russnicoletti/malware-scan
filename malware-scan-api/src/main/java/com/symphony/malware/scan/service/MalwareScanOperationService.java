package com.symphony.malware.scan.service;

import com.symphony.container.connector.ContainerConnector;
import com.symphony.container.connector.config.ContainerConnectorConfiguration;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.converter.ProtoDtoConverter;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.processor.CreateStateMalwareScanProcessor;
import com.symphony.malware.scan.processor.Processor;
import com.symphony.malware.scan.processor.SendRequestMalwareScanProcessor;
import com.symphony.malware.scan.processor.UpdateStateMalwareScanProcessor;
import com.symphony.malware.scan.processor.ValidateMalwareScanProcessor;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * Sends {@link MalwareScanRequestDto} to symproxy for the processing via the RLP
 * Serves as an entry point for attachments malware scan
 */
@Slf4j
public class MalwareScanOperationService {

    private final List<Processor<MalwareScanRequestDto, MalwareScanResponseDto>> malwareScanProcessors = new LinkedList<>();

    public MalwareScanOperationService(
        final ContainerConnector containerConnector,
        final SymproxMetricReportCache symproxMetricReportCache,
        final ContainerConnectorConfiguration containerConnectorConfiguration,
        final MalwareScanValidationService malwareScanValidationService,
        final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService,
        final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter,
        final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter
    ) {
        malwareScanProcessors.add(new ValidateMalwareScanProcessor(malwareScanValidationService));
        malwareScanProcessors.add(new CreateStateMalwareScanProcessor(malwareScanOperationPersistenceService));
        malwareScanProcessors.add(new SendRequestMalwareScanProcessor(
            containerConnector, symproxMetricReportCache, containerConnectorConfiguration,
            malwareScanRequestProtoDtoConverter, malwareScanResponseProtoDtoConverter
        ));
        malwareScanProcessors.add(new UpdateStateMalwareScanProcessor(malwareScanOperationPersistenceService));
    }

    /**
     * Builds and sends a request to symproxy for malware scanning for each malware scan request respectively
     * @param malwareScanRequestDtos {@link List} of {@link MalwareScanRequestDto}s
     * @return {@link List} of {@link MalwareScanResponseDto}s
     */
    public List<MalwareScanResponseDto> scan(final List<MalwareScanRequestDto> malwareScanRequestDtos) {
        final List<MalwareScanResponseDto> malwareScanResponseDtos = new ArrayList<>();
        for (MalwareScanRequestDto malwareScanRequestDto : malwareScanRequestDtos) {
            // Go through all processors
            MalwareScanResponseDto malwareScanResponseDto = null;
            for (Processor<MalwareScanRequestDto, MalwareScanResponseDto> malwareScanProcessor : malwareScanProcessors) {
                malwareScanResponseDto = malwareScanProcessor.process(malwareScanRequestDto);

                // If processing was not successful, break the loop
                if (!MalwareScanResponseDto.Status.PROCESSED.equals(malwareScanResponseDto.getStatus())) {
                    break;
                }
            }
            malwareScanResponseDtos.add(malwareScanResponseDto);
        }

        return malwareScanResponseDtos;
    }

}
