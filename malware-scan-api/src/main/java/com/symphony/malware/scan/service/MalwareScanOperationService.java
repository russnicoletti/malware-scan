package com.symphony.malware.scan.service;

import static com.symphony.malware.scan.Status.FAILED;

import com.symphony.container.connector.ConnectionIdUsageScenario;
import com.symphony.container.connector.ContainerConnector;
import com.symphony.container.connector.ContainerRpcController;
import com.symphony.container.connector.GenericRLPBlockingRpcChanel;
import com.symphony.container.connector.config.ConnectionRequestType;
import com.symphony.container.connector.config.ContainerConnectorConfiguration;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.converter.ProtoDtoConverter;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.proto320.BlockingRpcChannel;
import com.symphony.proto320.ServiceException;
import com.symphony.remoteservice.longpoll.client.RLPService;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;

import com.google.common.base.Optional;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;

/**
 * Sends {@link MalwareScanRequestDto} to symproxy for the processing via the RLP
 * Serves as an entry point for attachments malware scan
 */
@Slf4j
public class MalwareScanOperationService {

    private static final String MALWARE_SCAN_RLP_SERVICE_NAME = "scanAttachmentForMalwareService";

    private final ContainerConnector containerConnector;
    private final SymproxMetricReportCache symproxMetricReportCache;
    private final ContainerConnectorConfiguration containerConnectorConfiguration;
    private final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;
    private final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter;
    private final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter;
    private final Validator validator;

    public MalwareScanOperationService(
        final ContainerConnector containerConnector,
        final SymproxMetricReportCache symproxMetricReportCache,
        final ContainerConnectorConfiguration containerConnectorConfiguration,
        final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService,
        final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter,
        final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter
    ) {
        this.containerConnector = containerConnector;
        this.symproxMetricReportCache = symproxMetricReportCache;
        this.containerConnectorConfiguration = containerConnectorConfiguration;
        this.malwareScanOperationPersistenceService = malwareScanOperationPersistenceService;
        this.malwareScanRequestProtoDtoConverter = malwareScanRequestProtoDtoConverter;
        this.malwareScanResponseProtoDtoConverter = malwareScanResponseProtoDtoConverter;
        this.validator = Validation.buildDefaultValidatorFactory().getValidator();
    }

    /**
     * Builds and sends a request to symproxy for malware scanning for each malware scan request respectively
     * @param malwareScanRequestDtos {@link List} of {@link MalwareScanRequestDto}s
     * @return {@link List} of {@link MalwareScanResponseDto}s
     */
    public List<MalwareScanResponseDto> scan(final List<MalwareScanRequestDto> malwareScanRequestDtos) {
        final List<MalwareScanResponseDto> malwareScanResponseDtos = new ArrayList<>();
        for (MalwareScanRequestDto malwareScanRequestDto : malwareScanRequestDtos) {
            // Validate malware scan request before processing it
            final Set<ConstraintViolation<MalwareScanRequestDto>> constraintViolations = validator.validate(malwareScanRequestDto);

            MalwareScanResponseDto malwareScanResponseDto;
            if (!constraintViolations.isEmpty()) {
                // If malware scan request is not valid, do not send it to symproxy
                malwareScanResponseDto = MalwareScanResponseDto.builder().status(FAILED)
                    .error(constraintViolations.stream().map(cv -> cv.getPropertyPath() + " " + cv.getMessage()).collect(Collectors.joining(System.lineSeparator()))).build();
            } else {
                // Insert initial malware scan information with status PENDING
                malwareScanResponseDto = malwareScanOperationPersistenceService.create(malwareScanRequestDto, MalwareScanFileState.Status.PENDING, Actor.SYMPHONY);

                if (Status.OK.equals(malwareScanResponseDto.getStatus())) {
                    // Send rlp call to symproxy
                    malwareScanResponseDto = sendMalwareScanRequest(malwareScanRequestDto);

                    if (Status.OK.equals(malwareScanResponseDto.getStatus())) {
                        /*
                         * Update existing malware scan information to status SUBMITTED
                         *
                         * Please mind the fact, that persistence might fail here (e.g. due to storage unavailability),
                         * but we ignore it, as it is not critical if status will not transfer from PENDING to SUBMITTED at this point,
                         * but we should handle this case, when response from Malware Scanner is received
                         */
                        malwareScanOperationPersistenceService.update(malwareScanRequestDto, MalwareScanFileState.Status.SUBMITTED, Actor.SYMPHONY);
                    }
                }
            }

            malwareScanResponseDtos.add(malwareScanResponseDto.toBuilder().malwareScanRequestDto(malwareScanRequestDto).build());
        }

        return malwareScanResponseDtos;
    }

    /**
     * Sends a malware scan request
     * @param malwareScanRequestDto {@link MalwareScanRequestDto}
     * @return {@link MalwareScanResponseDto}
     */
    private MalwareScanResponseDto sendMalwareScanRequest(final MalwareScanRequestDto malwareScanRequestDto) {
        try {
            final MalwareScanRequest malwareScanRequest = malwareScanRequestProtoDtoConverter.toProto(malwareScanRequestDto);
            LOGGER.info("Sending request for malware scanning: {}", malwareScanRequest);
            final MalwareScanResponse malwareScanResponse = sendRLPRequest(malwareScanRequest);
            LOGGER.info("Received response from malware scanning: {}", malwareScanResponse);
            return malwareScanResponseProtoDtoConverter.toDto(malwareScanResponse);
        } catch (ServiceException e) {
            final String error = "Failed to send the malware scan request " + malwareScanRequestDto + " with stream id "
                + malwareScanRequestDto.getStreamId() + " and message id " + malwareScanRequestDto.getMessageId() + " for malware scanning";
            LOGGER.error(error, e);

            return MalwareScanResponseDto.builder().status(FAILED).error(error + System.lineSeparator() + e.getLocalizedMessage()).build();
        }
    }

    /**
     * Sends a request to the symproxy for malware scanning
     * @param malwareScanRequest {@link MalwareScanRequest}
     * @return {@link MalwareScanResponse}
     * @throws ServiceException
     */
    private MalwareScanResponse sendRLPRequest(final MalwareScanRequest malwareScanRequest) throws ServiceException {
        final BlockingRpcChannel blockingRpcChannel = new GenericRLPBlockingRpcChanel(
            ConnectionIdUsageScenario.NOT_APPLICABLE, RLPUsageScenario.USE_RLP_SERVICE, containerConnector, symproxMetricReportCache,
            Optional.of(new RLPService(MALWARE_SCAN_RLP_SERVICE_NAME)), Optional.absent(), containerConnectorConfiguration, ConnectionRequestType.TEXT_ONLY);

        com.symphony.malware.scan.MalwareScanService.BlockingInterface symproxyMalware =
            com.symphony.malware.scan.MalwareScanService.newBlockingStub(blockingRpcChannel);

        return symproxyMalware.submitForScanning(new ContainerRpcController(), malwareScanRequest);
    }

}
