package com.symphony.malware.scan.service;

import static com.symphony.malware.scan.Status.FAILED;

import com.symphony.container.connector.ConnectionIdUsageScenario;
import com.symphony.container.connector.ContainerConnector;
import com.symphony.container.connector.ContainerRpcController;
import com.symphony.container.connector.GenericRLPBlockingRpcChanel;
import com.symphony.container.connector.config.ConnectionRequestType;
import com.symphony.container.connector.config.ContainerConnectorConfiguration;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.converter.ProtoDtoConverter;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.proto320.BlockingRpcChannel;
import com.symphony.proto320.ServiceException;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;

import com.google.common.base.Optional;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;

/**
 * Sends {@link MalwareScanRequestDto} to symproxy for the processing via the RLP
 * Serves as an entry point for attachments malware scan
 */
@Slf4j
public class MalwareScanOperationService {

    private final ContainerConnector containerConnector;
    private final SymproxMetricReportCache symproxMetricReportCache;
    private final ContainerConnectorConfiguration containerConnectorConfiguration;
    private final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService;
    private final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter;
    private final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter;

    public MalwareScanOperationService(
        final ContainerConnector containerConnector,
        final SymproxMetricReportCache symproxMetricReportCache,
        final ContainerConnectorConfiguration containerConnectorConfiguration,
        final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService,
        final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter,
        final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter
    ) {
        this.containerConnector = containerConnector;
        this.symproxMetricReportCache = symproxMetricReportCache;
        this.containerConnectorConfiguration = containerConnectorConfiguration;
        this.malwareScanOperationPersistenceService = malwareScanOperationPersistenceService;
        this.malwareScanRequestProtoDtoConverter = malwareScanRequestProtoDtoConverter;
        this.malwareScanResponseProtoDtoConverter = malwareScanResponseProtoDtoConverter;
    }

    /**
     * Builds and sends a request to symproxy for malware scanning for each malware scan request respectively
     * @param malwareScanRequestDtos {@link List} of {@link MalwareScanRequestDto}s
     * @return {@link List} of {@link MalwareScanResponseDto}s
     */
    public List<MalwareScanResponseDto> scan(final List<MalwareScanRequestDto> malwareScanRequestDtos) {
        final List<MalwareScanResponseDto> malwareScanResponseDtos = new ArrayList<>();
        for (MalwareScanRequestDto malwareScanRequestDto : malwareScanRequestDtos) {
            // Insert initial malware scan information with status PENDING
            MalwareScanResponseDto malwareScanResponseDto = malwareScanOperationPersistenceService.create(malwareScanRequestDto);

            if (Status.OK.equals(malwareScanResponseDto.getStatus())) {
                // Send rlp call to symproxy
                malwareScanResponseDto = sendMalwareScanRequest(malwareScanRequestDto);

                if (Status.OK.equals(malwareScanResponseDto.getStatus())) {
                    /*
                     * Update existing malware scan information to status SUBMITTED
                     *
                     * Please mind the fact, that persistence might fail here (e.g. due to storage unavailability),
                     * but we ignore it, as it is not critical if status will not transfer from PENDING to SUBMITTED at this point,
                     * but we should handle this case, when response from Malware Scanner is received
                     */
                    malwareScanOperationPersistenceService.update(malwareScanRequestDto);
                }
            }

            malwareScanResponseDtos.add(malwareScanResponseDto.toBuilder().malwareScanRequestDto(malwareScanRequestDto).build());
        }

        return malwareScanResponseDtos;
    }

    /**
     * Sends a malware scan request
     * @param malwareScanRequestDto {@link MalwareScanRequestDto}
     * @return {@link MalwareScanResponseDto}
     */
    private MalwareScanResponseDto sendMalwareScanRequest(final MalwareScanRequestDto malwareScanRequestDto) {
        try {
            final MalwareScanRequest malwareScanRequest = malwareScanRequestProtoDtoConverter.toProto(malwareScanRequestDto);
            LOGGER.info("Sending request for malware scanning: {}", malwareScanRequest);
            final MalwareScanResponse malwareScanResponse = sendRLPRequest(malwareScanRequest);
            LOGGER.info("Received response from malware scanning: {}", malwareScanResponse);
            return malwareScanResponseProtoDtoConverter.toDto(malwareScanResponse);
        } catch (ServiceException e) {
            final String error = "Failed to send the malware scan request " + malwareScanRequestDto + " with stream id "
                + malwareScanRequestDto.getStreamId() + " and message id " + malwareScanRequestDto.getMessageId() + " for malware scanning";
            LOGGER.error(error, e);

            return MalwareScanResponseDto.builder().status(FAILED).error(error + System.lineSeparator() + e.getLocalizedMessage()).build();
        }
    }

    /**
     * Sends a request to the symproxy for malware scanning
     * @param malwareScanRequest {@link MalwareScanRequest}
     * @return {@link MalwareScanResponse}
     * @throws ServiceException
     */
    private MalwareScanResponse sendRLPRequest(final MalwareScanRequest malwareScanRequest) throws ServiceException {
        // Create the rpc channel using specified connectionId
        final BlockingRpcChannel blockingRpcChannel = new GenericRLPBlockingRpcChanel(ConnectionIdUsageScenario.VALID,
            RLPUsageScenario.USE_RLP_SERVICE, containerConnector, symproxMetricReportCache, Optional.absent(),
            Optional.absent(), containerConnectorConfiguration, ConnectionRequestType.TEXT_ONLY);

        com.symphony.malware.scan.MalwareScanService.BlockingInterface symproxyMalware =
            com.symphony.malware.scan.MalwareScanService.newBlockingStub(blockingRpcChannel);

        return symproxyMalware.submitForScanning(new ContainerRpcController(), malwareScanRequest);
    }

}
