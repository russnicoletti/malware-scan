package com.symphony.malware.scan.service;

import com.symphony.container.connector.ContainerConnector;
import com.symphony.container.connector.config.ContainerConnectorConfiguration;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.logging.TraceIdProvider;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.converter.ProtoDtoConverter;
import com.symphony.malware.scan.metrics.MalwareScanningMetricsImpl;
import com.symphony.malware.scan.metrics.MetricReport;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.malware.scan.processor.CreateStateMalwareScanProcessor;
import com.symphony.malware.scan.processor.Processor;
import com.symphony.malware.scan.processor.SendRequestMalwareScanProcessor;
import com.symphony.malware.scan.processor.UpdateStateMalwareScanProcessor;
import com.symphony.malware.scan.processor.ValidateMalwareScanProcessor;
import com.symphony.malware.scan.proto.MalwareScanServiceProtobufFactoryImpl;

import lombok.extern.slf4j.Slf4j;

import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Sends {@link MalwareScanRequestDto} to symproxy for the processing via the RLP
 * Serves as an entry point for attachments malware scan
 */
@Slf4j
public class MalwareScanOperationService {

    private static final String METRICS_INSTANCE_ID = "MALWARE-SCANNING-CLOUD";

    private final Processor<MalwareScanRequestDto, MalwareScanResponseDto> validateMalwareScanProcessor;
    private final List<Processor<MalwareScanRequestDto, MalwareScanResponseDto>> malwareScanProcessors;

    public MalwareScanOperationService(
        final ContainerConnector containerConnector,
        final SymproxMetricReportCache symproxMetricReportCache,
        final ContainerConnectorConfiguration containerConnectorConfiguration,
        final MalwareScanValidationService malwareScanValidationService,
        final MalwareScanOperationPersistenceService malwareScanOperationPersistenceService,
        final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter,
        final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter
    ) {
      MalwareScanServiceProtobufFactoryImpl malwareScanServiceFactory =
          new MalwareScanServiceProtobufFactoryImpl(containerConnector, symproxMetricReportCache,
              containerConnectorConfiguration);

      validateMalwareScanProcessor = new ValidateMalwareScanProcessor(malwareScanValidationService);

      malwareScanProcessors = new LinkedList<>();
      malwareScanProcessors.add(new CreateStateMalwareScanProcessor(malwareScanOperationPersistenceService));
      malwareScanProcessors.add(new SendRequestMalwareScanProcessor(malwareScanServiceFactory,
            malwareScanRequestProtoDtoConverter, malwareScanResponseProtoDtoConverter,
          new MalwareScanningMetricsImpl(new MetricReport(METRICS_INSTANCE_ID))));
        malwareScanProcessors.add(new UpdateStateMalwareScanProcessor(malwareScanOperationPersistenceService));
    }

    /**
     * Builds and sends a request to symproxy for malware scanning for each malware scan request respectively
     * @param malwareScanRequestDtos {@link List} of {@link MalwareScanRequestDto}s
     * @return {@link List} of {@link MalwareScanResponseDto}s
     */
    public List<MalwareScanResponseDto> scan(final List<MalwareScanRequestDto> malwareScanRequestDtos) {
        try (final TraceIdProvider traceIdProvider = new TraceIdProvider()) {
            // Initially, put all malware scan requests through the validation processor and get list of initial malware scan responses
            final List<MalwareScanResponseDto> malwareScanResponseDtos = malwareScanRequestDtos.stream()
                .map(malwareScanRequestDto -> {
                    final String traceId = traceIdProvider.getOrGenerate(malwareScanRequestDto.getTraceId());
                    return malwareScanRequestDto.toBuilder().traceId(traceId).build();
                })
                .map(validateMalwareScanProcessor::process).collect(Collectors.toList());

            for (Processor<MalwareScanRequestDto, MalwareScanResponseDto> malwareScanProcessor : malwareScanProcessors) {
                for (int i = 0; i < malwareScanResponseDtos.size(); i++) {
                    // Make sure that previous processor did not fail before going further to the next processor
                    if (MalwareScanResponseDto.Status.SUCCESS.equals(malwareScanResponseDtos.get(i).getStatus())) {
                        // Update malware scan response with the response from current processor
                        malwareScanResponseDtos.set(i, malwareScanProcessor.process(malwareScanResponseDtos.get(i).getMalwareScanRequestDto()));
                    }
                }
            }

            return malwareScanResponseDtos;
        }
    }

}
