package com.symphony.malware.scan.service;

import static com.symphony.malware.scan.Status.FAILED;

import com.symphony.container.connector.ConnectionIdUsageScenario;
import com.symphony.container.connector.ContainerConnector;
import com.symphony.container.connector.ContainerRpcController;
import com.symphony.container.connector.GenericRLPBlockingRpcChanel;
import com.symphony.container.connector.config.ConnectionRequestType;
import com.symphony.container.connector.config.ContainerConnectorConfiguration;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.AttachmentData;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.converter.ProtoDtoConverter;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.malware.scan.model.MalwareScanResponseDto;
import com.symphony.proto320.BlockingRpcChannel;
import com.symphony.proto320.ServiceException;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;

import com.google.common.base.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

public class MalwareScanOperationServiceImpl implements MalwareScanOperationService {
    private static final Logger LOGGER = LoggerFactory.getLogger(MalwareScanOperationServiceImpl.class);

    private final ContainerConnector containerConnector;
    private final SymproxMetricReportCache symproxMetricReportCache;
    private final ContainerConnectorConfiguration containerConnectorConfiguration;
    private final MalwareScanPersistenceService malwareScanPersistenceService;
    private final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter;
    private final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter;
    private final ProtoDtoConverter<AttachmentData.AttachmentMeta, AttachmentMetaDto> attachmentMetaProtoDtoConverter;

    public MalwareScanOperationServiceImpl(
        final ContainerConnector containerConnector,
        final SymproxMetricReportCache symproxMetricReportCache,
        final ContainerConnectorConfiguration containerConnectorConfiguration,
        final MalwareScanPersistenceService malwareScanPersistenceService,
        final ProtoDtoConverter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestProtoDtoConverter,
        final ProtoDtoConverter<MalwareScanResponse, MalwareScanResponseDto> malwareScanResponseProtoDtoConverter,
        final ProtoDtoConverter<AttachmentData.AttachmentMeta, AttachmentMetaDto> attachmentMetaProtoDtoConverter
    ) {
        this.containerConnector = containerConnector;
        this.symproxMetricReportCache = symproxMetricReportCache;
        this.containerConnectorConfiguration = containerConnectorConfiguration;
        this.malwareScanPersistenceService = malwareScanPersistenceService;
        this.malwareScanRequestProtoDtoConverter = malwareScanRequestProtoDtoConverter;
        this.malwareScanResponseProtoDtoConverter = malwareScanResponseProtoDtoConverter;
        this.attachmentMetaProtoDtoConverter = attachmentMetaProtoDtoConverter;
    }

    /**
     * Builds and sends a request to symproxy for malware scanning for each attachment respectively
     * @param malwareScanRequestDto
     * @return List<MalwareScanResponse>
     */
    @Override
    public List<MalwareScanResponseDto> scan(final MalwareScanRequestDto malwareScanRequestDto) {
        final List<MalwareScanResponseDto> malwareScanResponseDtos = new ArrayList<>();
        for (AttachmentMetaDto attachmentMetaDto : malwareScanRequestDto.getAttachmentMetaDtos()) {
            // Insert initial malware scan information with status PENDING
            final MalwareScanResponseDto persistenceMalwareScanResponseDto = malwareScanPersistenceService.create(malwareScanRequestDto, attachmentMetaDto);

            if (Status.OK.equals(persistenceMalwareScanResponseDto.getStatus())) {
                // Send rlp call to symproxy
                final MalwareScanResponseDto malwareScanResponseDto = sendMalwareScanRequest(malwareScanRequestDto, attachmentMetaDto);
                malwareScanResponseDtos.add(malwareScanResponseDto);

                if (Status.OK.equals(malwareScanResponseDto.getStatus())) {
                    /*
                     * Update existing malware scan information to status SUBMITTED
                     *
                     * Please mind the fact, that persistence might fail here (e.g. due to storage unavailability),
                     * but we ignore it, as it is not critical if status will not transfer from PENDING to SUBMITTED at this point,
                     * but we should handle this case, when response from Malware Scanner is received
                     */
                    malwareScanPersistenceService.update(malwareScanRequestDto, attachmentMetaDto);
                }
            } else {
                malwareScanResponseDtos.add(MalwareScanResponseDto.builder().status(persistenceMalwareScanResponseDto.getStatus())
                    .error(persistenceMalwareScanResponseDto.getError()).build());
            }
        }

        return malwareScanResponseDtos;
    }

    /**
     * Sends a request per attachment in social message
     * @param malwareScanRequestDto malware scan request dto
     * @param attachmentMetaDto attachment meta dto
     * @return
     */
    private MalwareScanResponseDto sendMalwareScanRequest(
        final MalwareScanRequestDto malwareScanRequestDto, final AttachmentMetaDto attachmentMetaDto
    ) {
        try {
            final MalwareScanRequest malwareScanRequest = malwareScanRequestProtoDtoConverter.toProto(malwareScanRequestDto)
                .toBuilder().setAttachmentMeta(attachmentMetaProtoDtoConverter.toProto(attachmentMetaDto)).build();
            LOGGER.info("Sending request for malware scanning: " + malwareScanRequest);
            final MalwareScanResponse malwareScanResponse = sendRLPRequest(malwareScanRequest);
            LOGGER.info("Received response from malware scanning: " + malwareScanResponse);
            return malwareScanResponseProtoDtoConverter.toDto(malwareScanResponse);
        } catch (ServiceException e) {
            final String error = "Failed to send the attachment " + attachmentMetaDto + " with stream id "
                + malwareScanRequestDto.getStreamId() + " and message id " + malwareScanRequestDto.getMessageId() + " for malware scanning";
            LOGGER.error(error, e);

            return MalwareScanResponseDto.builder().status(FAILED).error(error + System.lineSeparator() + e.getLocalizedMessage()).build();
        }
    }

    /**
     * Sends a request to the random symproxy for malware scanning
     * @param malwareScanRequest
     * @return
     * @throws ServiceException
     */
    private MalwareScanResponse sendRLPRequest(final MalwareScanRequest malwareScanRequest) throws ServiceException {
        // Create the rpc channel using specified connectionId
        final BlockingRpcChannel blockingRpcChannel = new GenericRLPBlockingRpcChanel(ConnectionIdUsageScenario.VALID,
            RLPUsageScenario.USE_RLP_SERVICE, containerConnector, symproxMetricReportCache, Optional.absent(),
            Optional.absent(), containerConnectorConfiguration, ConnectionRequestType.TEXT_ONLY);

        com.symphony.malware.scan.MalwareScanService.BlockingInterface symproxyMalware =
            com.symphony.malware.scan.MalwareScanService.newBlockingStub(blockingRpcChannel);

        return symproxyMalware.performScanning(new ContainerRpcController(), malwareScanRequest);
    }

}
