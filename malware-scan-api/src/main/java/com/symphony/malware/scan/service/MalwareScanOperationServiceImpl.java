package com.symphony.malware.scan.service;

import static com.symphony.malware.scan.Status.FAILED;

import com.symphony.container.connector.ConnectionIdUsageScenario;
import com.symphony.container.connector.ContainerConnector;
import com.symphony.container.connector.ContainerRpcController;
import com.symphony.container.connector.GenericRLPBlockingRpcChanel;
import com.symphony.container.connector.config.ConnectionRequestType;
import com.symphony.container.connector.config.ContainerConnectorConfiguration;
import com.symphony.container.connector.metric.SymproxMetricReportCache;
import com.symphony.malware.scan.AttachmentData;
import com.symphony.malware.scan.MalwareScanRequest;
import com.symphony.malware.scan.MalwareScanResponse;
import com.symphony.malware.scan.Status;
import com.symphony.malware.scan.converter.Converter;
import com.symphony.malware.scan.model.AttachmentMetaDto;
import com.symphony.malware.scan.model.MalwareScanPersistenceResponse;
import com.symphony.malware.scan.model.MalwareScanRequestDto;
import com.symphony.proto320.BlockingRpcChannel;
import com.symphony.proto320.ServiceException;
import com.symphony.remoteservice.longpoll.client.RLPUsageScenario;

import com.google.common.base.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

public class MalwareScanOperationServiceImpl implements MalwareScanOperationService {
    private static final Logger LOGGER = LoggerFactory.getLogger(MalwareScanOperationServiceImpl.class);

    private final ContainerConnector containerConnector;
    private final SymproxMetricReportCache symproxMetricReportCache;
    private final ContainerConnectorConfiguration containerConnectorConfiguration;
    private final MalwareScanPersistenceService malwareScanPersistenceService;
    private final Converter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestConverter;
    private final Converter<AttachmentData.AttachmentMeta, AttachmentMetaDto> attachmentMetaConverter;

    public MalwareScanOperationServiceImpl(
        final ContainerConnector containerConnector,
        final SymproxMetricReportCache symproxMetricReportCache,
        final ContainerConnectorConfiguration containerConnectorConfiguration,
        final MalwareScanPersistenceService malwareScanPersistenceService,
        final Converter<MalwareScanRequest, MalwareScanRequestDto> malwareScanRequestConverter,
        final Converter<AttachmentData.AttachmentMeta, AttachmentMetaDto> attachmentMetaConverter
    ) {
        this.containerConnector = containerConnector;
        this.symproxMetricReportCache = symproxMetricReportCache;
        this.containerConnectorConfiguration = containerConnectorConfiguration;
        this.malwareScanPersistenceService = malwareScanPersistenceService;
        this.malwareScanRequestConverter = malwareScanRequestConverter;
        this.attachmentMetaConverter = attachmentMetaConverter;
    }

    /**
     * Builds and sends a request to symproxy for malware scanning for each attachment respectively
     * @param malwareScanRequestDto
     * @return List<MalwareScanResponse>
     */
    @Override
    public List<MalwareScanResponse> scan(final MalwareScanRequestDto malwareScanRequestDto) {
        final MalwareScanRequest malwareScanRequest = malwareScanRequestConverter.toProto(malwareScanRequestDto);

        final List<MalwareScanResponse> malwareScanResponses = new ArrayList<>();
        for (AttachmentMetaDto attachmentMetaDto : malwareScanRequestDto.getAttachmentMetaDtos()) {
            // Insert initial malware scan information with status PENDING
            final MalwareScanPersistenceResponse malwareScanPersistenceResponse = malwareScanPersistenceService.create(malwareScanRequestDto, attachmentMetaDto);

            if (Status.OK.equals(malwareScanPersistenceResponse.getStatus())) {
                // Send rlp call to symproxy
                final AttachmentData.AttachmentMeta attachmentMeta = attachmentMetaConverter.toProto(attachmentMetaDto);
                final MalwareScanResponse malwareScanResponse = sendMalwareScanRequest(malwareScanRequest.toBuilder().setAttachmentMeta(attachmentMeta).build());
                malwareScanResponses.add(malwareScanResponse);

                if (Status.OK.equals(malwareScanResponse.getStatus())) {
                    /*
                     * Update existing malware scan information to status SUBMITTED
                     *
                     * Please mind the fact, that persistence might fail here (e.g. due to storage unavailability),
                     * but we ignore it, as it is not critical if status will not transfer from PENDING to SUBMITTED at this point,
                     * but we should handle this case, when response from Malware Scanner is received
                     */
                    malwareScanPersistenceService.update(malwareScanRequestDto, attachmentMetaDto);
                }
            } else {
                malwareScanResponses.add(MalwareScanResponse.newBuilder().setStatus(malwareScanPersistenceResponse.getStatus())
                    .setError(malwareScanPersistenceResponse.getError()).build());
            }
        }

        return malwareScanResponses;
    }

    /**
     * Sends a request per attachment in social message
     * @param malwareScanRequest, attachmentMeta
     * @return List<MalwareScanResponse>
     */
    private MalwareScanResponse sendMalwareScanRequest(final MalwareScanRequest malwareScanRequest) {
        try {
            LOGGER.info("Sending request for malware scanning: " + malwareScanRequest);
            final MalwareScanResponse malwareScanResponse = sendRLPRequest(malwareScanRequest);
            LOGGER.info("Received response from malware scanning: " + malwareScanResponse);
            return malwareScanResponse;
        } catch (ServiceException e) {
            LOGGER.error("Failed to send the attachment {} with stream id {} for malware scanning", malwareScanRequest.getAttachmentMeta(), malwareScanRequest.getStreamId(), e);
            return MalwareScanResponse.newBuilder().setStatus(FAILED).setError(e.getLocalizedMessage()).build();
        }
    }

    /**
     * Sends a request to the random symproxy for malware scanning
     * @param malwareScanRequest
     * @return
     * @throws ServiceException
     */
    private MalwareScanResponse sendRLPRequest(final MalwareScanRequest malwareScanRequest) throws ServiceException {
        // Create the rpc channel using specified connectionId
        final BlockingRpcChannel blockingRpcChannel = new GenericRLPBlockingRpcChanel(ConnectionIdUsageScenario.VALID,
            RLPUsageScenario.USE_RLP_SERVICE, containerConnector, symproxMetricReportCache, Optional.absent(),
            Optional.absent(), containerConnectorConfiguration, ConnectionRequestType.TEXT_ONLY);

        com.symphony.malware.scan.MalwareScanService.BlockingInterface symproxyMalware =
            com.symphony.malware.scan.MalwareScanService.newBlockingStub(blockingRpcChannel);

        return symproxyMalware.performScanning(new ContainerRpcController(), malwareScanRequest);
    }

}
