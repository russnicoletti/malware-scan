package com.symphony.malware.scan.workflow;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import util.TimestampMillisSupplier;

import java.util.Date;

class RetryDecider {

    private final TimestampMillisSupplier timestampMillisSupplier;
    private static Logger LOGGER = LoggerFactory.getLogger(RetryDecider.class);

    RetryDecider(TimestampMillisSupplier timestampMillisSupplier) {
        this.timestampMillisSupplier = timestampMillisSupplier;
    }

    /**
     * Determines if the retry period has been exceeded
     * @param maximumRetryDurationSeconds
     * @param initialAttemptTimestamp
     * @return true if the retry period has been exceeded, false otherwise
     */
    boolean shouldStopRetryAttempts(Integer maximumRetryDurationSeconds, Long initialAttemptTimestamp) {
        Date now = new Date(timestampMillisSupplier.now());

        Date initialAttempDateTime = new Date(initialAttemptTimestamp);
        Date maximumRetryAttemptDateTime = new Date(initialAttempDateTime.getTime() + (maximumRetryDurationSeconds * 1000));
        LOGGER.info("initial attempt timestamp                {}", initialAttempDateTime);
        LOGGER.info("maximum seconds to wait                  {}", maximumRetryDurationSeconds);
        LOGGER.info("maximum retry attempt duration timestamp {}", maximumRetryAttemptDateTime);
        LOGGER.info("now                                      {}", now);

        // If the current time is not before (that is, it is equal to or later) the maximum retry attempt timestamp,
        // the maximum retry duration has been exceeded
        if (!now.before(maximumRetryAttemptDateTime)) {
            return true;
        }

        return false;
    }

    /**
     * Determines whether or not the minimum retry attempt interval has been exceeded. That is,
     * whether the current time is after the last submission attempt plus the minimum retry
     * interval in seconds.
     * @param minimumSecondsBetweenRetryAttempts
     * @param lastSubmissionAttemptTimestamp
     * @return true if the current time is after the last submission attempt plus the minimum retry
     * interval in seconds. Otherwise, false.
     */
    boolean retryIntervalExceeded(Integer minimumSecondsBetweenRetryAttempts, Long lastSubmissionAttemptTimestamp) {

        Date minimumNextRetryAttemptDateTime = new Date(lastSubmissionAttemptTimestamp + (minimumSecondsBetweenRetryAttempts * 1000));

        Date now = new Date(timestampMillisSupplier.now());

        LOGGER.info("lastSubmissionAttemptTimestamp       {}", lastSubmissionAttemptTimestamp);
        LOGGER.info("minimum seconds before retry attempt {}", minimumSecondsBetweenRetryAttempts);
        LOGGER.info("minimumNextRetryAttemptTimestamp     {}", minimumNextRetryAttemptDateTime);
        LOGGER.info("now                                  {}", now);

        if (now.after(minimumNextRetryAttemptDateTime)) {
            return true;
        }

        LOGGER.info("{} seconds have not elapsed sine the last submission attempt ({}) - current time is {}",
                minimumSecondsBetweenRetryAttempts,
                new Date(lastSubmissionAttemptTimestamp),
                now);

        return false;
    }
}
