package com.symphony.malware.scan.persistence.repository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.symphony.data.infrastructure.IPersistenceInfra;
import com.symphony.data.mapper.IKeyValueTable;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.model.MalwareScanFileState;

import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.lang3.CharEncoding;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.Closeable;
import java.nio.charset.Charset;
import java.util.function.Supplier;

import javax.persistence.OptimisticLockException;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanFileStateRepositoryTest {

  private static final Charset CHARSET = Charset.forName(CharEncoding.UTF_8);
  private static final String MALWARE_SCAN_FILE_STATE_TABLE = "malwareScanFileState";

  private static final String FILE_ID = "fileId0001";

  @Mock
  private IPersistenceInfra persistenceInfra;
  @Mock
  private Supplier<ObjectMapper> objectMapperSupplier;
  @Mock
  private IKeyValueTable keyValueTable;
  @Mock
  private Closeable closeable;

  private MalwareScanFileStateRepository malwareScanFileStateRepository;
  private ObjectMapper objectMapper;

  @Before
  public void before() throws PersistentException {
    objectMapper = spy(new ObjectMapper());
    when(objectMapperSupplier.get()).thenReturn(objectMapper);
    when(persistenceInfra.getKeyValueTable(MALWARE_SCAN_FILE_STATE_TABLE))
        .thenReturn(keyValueTable);

    malwareScanFileStateRepository = new MalwareScanFileStateRepository(persistenceInfra, objectMapperSupplier);
  }

  private MalwareScanFileState createMalwareScanFileState() {
    return MalwareScanFileState.builder()
        .version(1)
        .fileId(FILE_ID).build();
  }

  @Test
  public void safe_save_insert_noException() throws Exception {
    MalwareScanFileState malwareScanFileState = createMalwareScanFileState();

    when(keyValueTable.checkAndPut(eq(FILE_ID.getBytes(CHARSET)), isNull(), any(byte[].class))).thenReturn(true);

    malwareScanFileStateRepository.save(FILE_ID, null, malwareScanFileState);

    ArgumentCaptor<byte[]> stateArgumentCaptor = ArgumentCaptor.forClass(byte[].class);

    verify(keyValueTable, times(1))
        .checkAndPut(eq(FILE_ID.getBytes(CHARSET)), isNull(), stateArgumentCaptor.capture());
    assertThat(stateArgumentCaptor.getValue()).isEqualTo(objectMapper.writeValueAsString(malwareScanFileState).getBytes(CHARSET));
  }

  @Test
  public void safe_save_insert_alreadyExists() throws Exception {
    MalwareScanFileState malwareScanFileState = createMalwareScanFileState();

    when(keyValueTable.checkAndPut(eq(FILE_ID.getBytes(CHARSET)), isNull(), any(byte[].class)))
        .thenReturn(false);

    assertThatThrownBy(() -> malwareScanFileStateRepository.save(FILE_ID, null, malwareScanFileState))
        .isInstanceOf(PersistentException.class)
        .hasCauseInstanceOf(OptimisticLockException.class)
        .hasMessageContaining("updated by another thread");

    verify(keyValueTable, times(1))
        .checkAndPut(eq(FILE_ID.getBytes(CHARSET)), isNull(), any(byte[].class));
  }

  @Test
  public void safe_save_versionNumberDontMatch() throws Exception {
    final MalwareScanFileState currentState = MalwareScanFileState.builder()
        .fileId(FILE_ID).version(2).build();
    final MalwareScanFileState newState = MalwareScanFileState.builder()
        .fileId(FILE_ID).version(2).build();

    assertThatThrownBy(() -> malwareScanFileStateRepository.save(FILE_ID, currentState, newState))
        .isInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Invalid call to save");

    verify(keyValueTable, never())
        .checkAndPut(eq(FILE_ID.getBytes(CHARSET)), any(byte[].class), any(byte[].class));
  }

  @Test
  public void safe_save_update_checkFails() throws Exception {
    final MalwareScanFileState currentState = MalwareScanFileState.builder()
        .fileId(FILE_ID).version(1).build();
    final MalwareScanFileState newState = MalwareScanFileState.builder()
        .fileId(FILE_ID).version(2).build();

    when(keyValueTable.checkAndPut(eq(FILE_ID.getBytes(CHARSET)), any(byte[].class), any(byte[].class)))
        .thenReturn(false);

    assertThatThrownBy(() -> malwareScanFileStateRepository.save(FILE_ID, currentState, newState))
        .isInstanceOf(PersistentException.class)
        .hasCauseInstanceOf(OptimisticLockException.class)
        .hasMessageContaining("updated by another thread");
    verify(keyValueTable, times(1))
        .checkAndPut(eq(FILE_ID.getBytes(CHARSET)), any(byte[].class), any(byte[].class));
  }

  @Test
  public void safe_save_update_noException() throws Exception {
    final MalwareScanFileState currentState = MalwareScanFileState.builder()
        .fileId(FILE_ID).version(2).build();
    final MalwareScanFileState newState = MalwareScanFileState.builder()
        .fileId(FILE_ID).version(3).build();

    when(keyValueTable.checkAndPut(eq(FILE_ID.getBytes(CHARSET)), any(byte[].class), any(byte[].class)))
        .thenReturn(true);

    malwareScanFileStateRepository.save(FILE_ID, currentState, newState);

    verify(keyValueTable, times(1))
        .checkAndPut(eq(FILE_ID.getBytes(CHARSET)), any(byte[].class), any(byte[].class));
  }

  @Test
  public void load_malwareScanFileStateReturned() throws Exception {
    MalwareScanFileState malwareScanFileState = createMalwareScanFileState();

    final byte[] loadedBytes = ("{\"fileId\":\"" + FILE_ID + "\"}").getBytes(CHARSET);
    when(keyValueTable.load(FILE_ID.getBytes(CHARSET))).thenReturn(loadedBytes);
    when(objectMapper.readValue(loadedBytes, MalwareScanFileState.class)).thenReturn(malwareScanFileState);

    MalwareScanFileState returnedMalwareScanFileState = malwareScanFileStateRepository.load(FILE_ID);
    assertThat(returnedMalwareScanFileState).isNotNull();
    assertThat(returnedMalwareScanFileState.getFileId()).isEqualTo(malwareScanFileState.getFileId());

    verify(keyValueTable, times(1)).load(FILE_ID.getBytes(CHARSET));
  }

  @Test
  public void load_noFileStateFound_returnsNull() throws Exception {
    when(keyValueTable.load(FILE_ID.getBytes(CHARSET))).thenReturn(null);

    final MalwareScanFileState returnedMalwareScanFileState = malwareScanFileStateRepository.load(FILE_ID);
    assertThat(returnedMalwareScanFileState).isNull();

    verify(keyValueTable, times(1)).load(FILE_ID.getBytes(CHARSET));
  }

  @Test
  public void load_jsonProcessingException_persistentExceptionThrown() throws Exception {
    final byte[] malwareScanFileStateBytes = ("{\"fileId\":\"" + FILE_ID + "\"}").getBytes(CHARSET);

    when(keyValueTable.load(FILE_ID.getBytes(CHARSET))).thenReturn(malwareScanFileStateBytes);
    when(objectMapper.readValue(malwareScanFileStateBytes, MalwareScanFileState.class))
        .thenThrow(new JsonMappingException(closeable, "JSON Mapping Exception"));

    assertThatThrownBy(() -> malwareScanFileStateRepository.load(FILE_ID))
        .isInstanceOf(PersistentException.class)
        .hasMessage("com.fasterxml.jackson.databind.JsonMappingException: JSON Mapping Exception");

    verify(keyValueTable, times(1)).load(FILE_ID.getBytes(CHARSET));
  }

  @Test
  public void load_persistentException_persistentExceptionRethrown() throws Exception {
    when(keyValueTable.load(FILE_ID.getBytes(CHARSET))).thenThrow(new PersistentException("Failed to load", ""));

    assertThatThrownBy(() -> new MalwareScanFileStateRepository(persistenceInfra, objectMapperSupplier)
        .load(FILE_ID)).isInstanceOf(PersistentException.class)
        .hasMessage("Failed to load");

    verify(keyValueTable, times(1)).load(FILE_ID.getBytes(CHARSET));
    verify(objectMapper, times(0)).readValue(any(byte[].class), eq(MalwareScanFileState.class));
  }
}
