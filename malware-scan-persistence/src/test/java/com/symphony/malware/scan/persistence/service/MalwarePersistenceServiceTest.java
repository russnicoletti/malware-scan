package com.symphony.malware.scan.persistence.service;

import static com.symphony.malware.scan.dto.MalwareScanState.Status;
import static com.symphony.malware.scan.persistence.repository.MalwareScanMappingRangePersistenceRepository.RangeKey;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.symphony.malware.scan.dto.Actor;
import com.symphony.malware.scan.dto.MalwareScanMapping;
import com.symphony.malware.scan.dto.MalwareScanState;
import com.symphony.malware.scan.persistence.exception.MalwareScanUpdateException;
import com.symphony.malware.scan.persistence.repository.PersistenceRepository;
import com.symphony.malware.scan.persistence.repository.RangePersistenceRepository;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import util.TemporalSupplier;

import java.time.Instant;
import java.util.List;

@RunWith(MockitoJUnitRunner.class)
public class MalwarePersistenceServiceTest {

  private static final String FILE_ID = "fileId0001";
  private static final String STREAM_ID = "streamId0001";
  private static final String MESSAGE_ID = "messageId0001";

  private static final Instant EPOCH_MILLI_0 = Instant.ofEpochMilli(0L);
  private static final Instant EPOCH_MILLI_1 = Instant.ofEpochMilli(1L);

  @Mock
  private PersistenceRepository<String, MalwareScanState> malwareScanStatePersistenceRepository;

  @Mock
  private RangePersistenceRepository<String, Instant, MalwareScanState> malwareScanStateHistoRangePersistenceRepository;

  @Mock
  private RangePersistenceRepository<String, RangeKey, MalwareScanMapping> malwareScanMappingRangePersistenceRepository;

  @Mock
  private TemporalSupplier<Instant> instantSupplier;

  private MalwarePersistenceService malwarePersistenceService;

  @Before
  public void before() {
    when(instantSupplier.now()).thenReturn(EPOCH_MILLI_1);

    malwarePersistenceService = new MalwarePersistenceService(malwareScanStatePersistenceRepository, malwareScanStateHistoRangePersistenceRepository,
        malwareScanMappingRangePersistenceRepository, instantSupplier);
  }

  @Test
  public void putMalwareScanState_newMalwareScanStateActorIsSymphony_malwareScanStatePut() throws Exception {
    final MalwareScanState malwareScanState = MalwareScanState.builder().fileId(FILE_ID).status(Status.PENDING).build();

    when(malwareScanStatePersistenceRepository.load(FILE_ID)).thenReturn(null);

    malwarePersistenceService.putMalwareScanState(malwareScanState, Actor.SYMPHONY);

    final ArgumentCaptor<MalwareScanState> malwareScanStatePersist = ArgumentCaptor.forClass(MalwareScanState.class);
    verify(malwareScanStatePersistenceRepository, times(1)).save(eq(FILE_ID), malwareScanStatePersist.capture());
    assertThat(malwareScanStatePersist.getValue().getFileId()).isEqualTo(FILE_ID);
    assertThat(malwareScanStatePersist.getValue().getStatus()).isEqualTo(Status.PENDING);
    assertThat(malwareScanStatePersist.getValue().getCreateTimestamp()).isEqualTo(EPOCH_MILLI_1);
    assertThat(malwareScanStatePersist.getValue().getCreatedBy()).isEqualTo(Actor.SYMPHONY);
    assertThat(malwareScanStatePersist.getValue().getLastUpdateTimestamp()).isEqualTo(EPOCH_MILLI_1);
    assertThat(malwareScanStatePersist.getValue().getLastUpdatedBy()).isEqualTo(Actor.SYMPHONY);

    final ArgumentCaptor<MalwareScanState> malwareScanStateHistoPersist = ArgumentCaptor.forClass(MalwareScanState.class);
    verify(malwareScanStateHistoRangePersistenceRepository, times(1)).save(eq(FILE_ID), eq(EPOCH_MILLI_1), malwareScanStateHistoPersist.capture());
    assertThat(malwareScanStateHistoPersist.getValue().getFileId()).isEqualTo(FILE_ID);
    assertThat(malwareScanStateHistoPersist.getValue().getStatus()).isEqualTo(Status.PENDING);
    assertThat(malwareScanStateHistoPersist.getValue().getCreateTimestamp()).isEqualTo(EPOCH_MILLI_1);
    assertThat(malwareScanStateHistoPersist.getValue().getCreatedBy()).isEqualTo(Actor.SYMPHONY);
    assertThat(malwareScanStateHistoPersist.getValue().getLastUpdateTimestamp()).isEqualTo(EPOCH_MILLI_1);
    assertThat(malwareScanStateHistoPersist.getValue().getLastUpdatedBy()).isEqualTo(Actor.SYMPHONY);
  }

  @Test
  public void putMalwareScanState_newMalwareScanStateActorIsMalwareScanner_exceptonThrown() throws Exception {
    final MalwareScanState malwareScanState = MalwareScanState.builder().fileId(FILE_ID).status(Status.PENDING).build();

    when(malwareScanStatePersistenceRepository.load(FILE_ID)).thenReturn(null);

    assertThatThrownBy(() -> malwarePersistenceService.putMalwareScanState(malwareScanState, Actor.MALWARE_SCANNER))
        .isInstanceOf(MalwareScanUpdateException.class)
        .hasMessage("Transfer to PENDING status is not allowed for MALWARE_SCANNER actor");

    verify(malwareScanStatePersistenceRepository, times(0)).save(any(String.class), any(MalwareScanState.class));
    verify(malwareScanStateHistoRangePersistenceRepository, times(0)).save(any(String.class), any(Instant.class), any(MalwareScanState.class));
  }

  @Test
  public void putMalwareScanState_existingMalwareScanStatePendingToSubmittedActorIsSymphony_malwareScanStatePut() throws Exception {
    final MalwareScanState malwareScanState = MalwareScanState.builder().fileId(FILE_ID).status(Status.SUBMITTED).build();

    when(malwareScanStatePersistenceRepository.load(FILE_ID)).thenReturn(malwareScanState.toBuilder().status(Status.PENDING)
        .createTimestamp(EPOCH_MILLI_0).createdBy(Actor.SYMPHONY).build());

    malwarePersistenceService.putMalwareScanState(malwareScanState, Actor.SYMPHONY);

    final ArgumentCaptor<MalwareScanState> malwareScanStatePersist = ArgumentCaptor.forClass(MalwareScanState.class);
    verify(malwareScanStatePersistenceRepository, times(1)).save(eq(FILE_ID), malwareScanStatePersist.capture());
    assertThat(malwareScanStatePersist.getValue().getFileId()).isEqualTo(FILE_ID);
    assertThat(malwareScanStatePersist.getValue().getStatus()).isEqualTo(Status.SUBMITTED);
    assertThat(malwareScanStatePersist.getValue().getCreateTimestamp()).isEqualTo(EPOCH_MILLI_0);
    assertThat(malwareScanStatePersist.getValue().getCreatedBy()).isEqualTo(Actor.SYMPHONY);
    assertThat(malwareScanStatePersist.getValue().getLastUpdateTimestamp()).isEqualTo(EPOCH_MILLI_1);
    assertThat(malwareScanStatePersist.getValue().getLastUpdatedBy()).isEqualTo(Actor.SYMPHONY);

    final ArgumentCaptor<MalwareScanState> malwareScanStateHistoPersist = ArgumentCaptor.forClass(MalwareScanState.class);
    verify(malwareScanStateHistoRangePersistenceRepository, times(1)).save(eq(FILE_ID), eq(EPOCH_MILLI_1), malwareScanStateHistoPersist.capture());
    assertThat(malwareScanStateHistoPersist.getValue().getFileId()).isEqualTo(FILE_ID);
    assertThat(malwareScanStateHistoPersist.getValue().getStatus()).isEqualTo(Status.SUBMITTED);
    assertThat(malwareScanStateHistoPersist.getValue().getCreateTimestamp()).isEqualTo(EPOCH_MILLI_0);
    assertThat(malwareScanStateHistoPersist.getValue().getCreatedBy()).isEqualTo(Actor.SYMPHONY);
    assertThat(malwareScanStateHistoPersist.getValue().getLastUpdateTimestamp()).isEqualTo(EPOCH_MILLI_1);
    assertThat(malwareScanStateHistoPersist.getValue().getLastUpdatedBy()).isEqualTo(Actor.SYMPHONY);
  }

  @Test
  public void putMalwareScanState_existingMalwareScanStateSubmittedToFailedSubmit_exceptionThrown() throws Exception {
    final MalwareScanState malwareScanState = MalwareScanState.builder().fileId(FILE_ID).status(Status.FAILED_SUBMIT).build();

    when(malwareScanStatePersistenceRepository.load(FILE_ID)).thenReturn(malwareScanState.toBuilder().status(Status.SUBMITTED)
        .createTimestamp(EPOCH_MILLI_0).createdBy(Actor.SYMPHONY).build());

    assertThatThrownBy(() -> malwarePersistenceService.putMalwareScanState(malwareScanState, Actor.SYMPHONY))
        .isInstanceOf(MalwareScanUpdateException.class)
        .hasMessage("Transfer from SUBMITTED status to FAILED_SUBMIT status is not allowed");

    verify(malwareScanStatePersistenceRepository, times(0)).save(any(String.class), any(MalwareScanState.class));
    verify(malwareScanStateHistoRangePersistenceRepository, times(0)).save(any(String.class), any(Instant.class), any(MalwareScanState.class));
  }

  @Test
  public void putMalwareScanState_existingMalwareScanStateSubmittedToOkActorIsSymphony_exceptionThrown() throws Exception {
    final MalwareScanState malwareScanState = MalwareScanState.builder().fileId(FILE_ID).status(Status.OK).build();

    when(malwareScanStatePersistenceRepository.load(FILE_ID)).thenReturn(malwareScanState.toBuilder().status(Status.SUBMITTED)
        .createTimestamp(EPOCH_MILLI_0).createdBy(Actor.SYMPHONY).build());

    assertThatThrownBy(() -> malwarePersistenceService.putMalwareScanState(malwareScanState, Actor.SYMPHONY))
        .isInstanceOf(MalwareScanUpdateException.class)
        .hasMessage("Transfer to OK status is not allowed for SYMPHONY actor");

    verify(malwareScanStatePersistenceRepository, times(0)).save(any(String.class), any(MalwareScanState.class));
    verify(malwareScanStateHistoRangePersistenceRepository, times(0)).save(any(String.class), any(Instant.class), any(MalwareScanState.class));
  }

  @Test
  public void getMalwareScanState_malwareScanStateExists_malwareScanStateReturned() throws Exception {
    when(malwareScanStatePersistenceRepository.load(FILE_ID)).thenReturn(MalwareScanState.builder().fileId(FILE_ID)
        .status(Status.SUBMITTED).createTimestamp(EPOCH_MILLI_0).createdBy(Actor.SYMPHONY).build());

    assertThat(malwarePersistenceService.getMalwareScanState(FILE_ID)).isNotEmpty();

    verify(malwareScanStatePersistenceRepository, times(1)).load(eq(FILE_ID));
  }

  @Test
  public void getMalwareScanState_malwareScanStateDoesNotExist_emptyOptionalReturned() throws Exception {
    when(malwareScanStatePersistenceRepository.load(FILE_ID)).thenReturn(null);

    assertThat(malwarePersistenceService.getMalwareScanState(FILE_ID)).isEmpty();

    verify(malwareScanStatePersistenceRepository, times(1)).load(eq(FILE_ID));
  }

  @Test
  public void getMalwareScanStates_byFileId_malwareScanStatesReturned() throws Exception {
    when(malwareScanStateHistoRangePersistenceRepository.loadRange(FILE_ID)).thenReturn(
        ImmutableList.of(
            MalwareScanState.builder().fileId(FILE_ID).status(Status.SUBMITTED).createTimestamp(EPOCH_MILLI_0).createdBy(Actor.SYMPHONY).build()
        )
    );

    assertThat(malwarePersistenceService.getMalwareScanStates(FILE_ID)).extracting(MalwareScanState::getFileId).containsExactly(FILE_ID);

    verify(instantSupplier, times(0)).now();
    verify(malwareScanStateHistoRangePersistenceRepository, times(1)).loadRange(eq(FILE_ID));
  }

  @Test
  public void getMalwareScanStates_byFileIdAndFrom_malwareScanStatesReturned() throws Exception {
    when(malwareScanStateHistoRangePersistenceRepository.loadRange(FILE_ID, EPOCH_MILLI_0, EPOCH_MILLI_1)).thenReturn(
        ImmutableList.of(
            MalwareScanState.builder().fileId(FILE_ID).status(Status.SUBMITTED).createTimestamp(EPOCH_MILLI_0).createdBy(Actor.SYMPHONY).build()
        )
    );

    assertThat(malwarePersistenceService.getMalwareScanStates(FILE_ID, EPOCH_MILLI_0)).extracting(MalwareScanState::getFileId).containsExactly(FILE_ID);

    verify(instantSupplier, times(1)).now();
    verify(malwareScanStateHistoRangePersistenceRepository, times(1)).loadRange(eq(FILE_ID), eq(EPOCH_MILLI_0), eq(EPOCH_MILLI_1));
  }

  @Test
  public void getMalwareScanStates_byFileIdAndFromAndTo_malwareScanStatesReturned() throws Exception {
    when(malwareScanStateHistoRangePersistenceRepository.loadRange(FILE_ID, EPOCH_MILLI_0, EPOCH_MILLI_1)).thenReturn(
        ImmutableList.of(
            MalwareScanState.builder().fileId(FILE_ID).status(Status.SUBMITTED).createTimestamp(EPOCH_MILLI_0).createdBy(Actor.SYMPHONY).build()
        )
    );

    assertThat(malwarePersistenceService.getMalwareScanStates(FILE_ID, EPOCH_MILLI_0, EPOCH_MILLI_1)).extracting(MalwareScanState::getFileId).containsExactly(FILE_ID);

    verify(instantSupplier, times(0)).now();
    verify(malwareScanStateHistoRangePersistenceRepository, times(1)).loadRange(eq(FILE_ID), eq(EPOCH_MILLI_0), eq(EPOCH_MILLI_1));
  }

  @Test
  public void putMalwareScanMapping_malwareScanMappingPut() throws Exception {
    final MalwareScanMapping malwareScanMapping = MalwareScanMapping.builder().fileId(FILE_ID).streamId(STREAM_ID).messageId(MESSAGE_ID).build();

    malwarePersistenceService.putMalwareScanMapping(malwareScanMapping);

    final ArgumentCaptor<RangeKey> argumentCaptor = ArgumentCaptor.forClass(RangeKey.class);
    verify(malwareScanMappingRangePersistenceRepository, times(1)).save(eq(FILE_ID), argumentCaptor.capture(), eq(malwareScanMapping));

    assertThat(argumentCaptor.getValue().getStreamId()).isEqualTo(STREAM_ID);
    assertThat(argumentCaptor.getValue().getMessageId()).isEqualTo(MESSAGE_ID);
  }

  @Test
  public void getMalwareScanMapping_malwareScanStateInfosReturned() throws Exception {
    when(malwareScanMappingRangePersistenceRepository.loadRange(FILE_ID)).thenReturn(
        ImmutableList.of(
            MalwareScanMapping.builder().fileId(FILE_ID).streamId(STREAM_ID).messageId(MESSAGE_ID).build(),
            MalwareScanMapping.builder().fileId(FILE_ID).streamId(STREAM_ID + "1").messageId(MESSAGE_ID + "1").build(),
            MalwareScanMapping.builder().fileId(FILE_ID).streamId(STREAM_ID + "2").messageId(MESSAGE_ID + "2").build()
        )
    );

    final List<MalwareScanMapping> malwareScanMappings = malwarePersistenceService.getMalwareScanMapping(FILE_ID, STREAM_ID, MESSAGE_ID);

    verify(malwareScanMappingRangePersistenceRepository, times(1)).loadRange(FILE_ID);

    assertThat(malwareScanMappings).hasSize(1);
    assertThat(malwareScanMappings.get(0).getFileId()).isEqualTo(FILE_ID);
    assertThat(malwareScanMappings.get(0).getStreamId()).isEqualTo(STREAM_ID);
    assertThat(malwareScanMappings.get(0).getMessageId()).isEqualTo(MESSAGE_ID);
  }

}
