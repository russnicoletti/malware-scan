package com.symphony.malware.scan.persistence.service;

import static com.symphony.malware.scan.model.MalwareScanFileState.Status;
import static com.symphony.malware.scan.persistence.repository.MalwareScanFileMappingRangeRepository.RangeKey;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.MalwareScanFileMapping;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.model.MalwareScanFileStatusDetails;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.persistence.exception.MalwareScanStatusTransferException;
import com.symphony.malware.scan.persistence.repository.PersistenceRangeRepository;
import com.symphony.malware.scan.persistence.repository.PersistenceRepository;

import com.google.common.collect.ImmutableList;
import com.tngtech.java.junit.dataprovider.DataProvider;
import com.tngtech.java.junit.dataprovider.DataProviderRunner;
import com.tngtech.java.junit.dataprovider.UseDataProvider;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import util.TemporalSupplier;

import java.time.Instant;
import java.util.List;

import javax.persistence.OptimisticLockException;

@RunWith(DataProviderRunner.class)
public class MalwareScanPersistenceServiceTest {

    private static final String FILE_ID = "fileId0001";
    private static final String STREAM_ID = "streamId0001";
    private static final String MESSAGE_ID = "messageId0001";

    private static final Instant EPOCH_MILLI_INSTANT_0 = Instant.ofEpochMilli(0L);
    private static final Instant EPOCH_MILLI_INSTANT_1 = Instant.ofEpochMilli(1L);

    private static final Long EPOCH_MILLI_0 = 0L;
    private static final Long EPOCH_MILLI_1 = 1L;

    @Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Mock
    private PersistenceRepository<String, MalwareScanFileState> malwareScanFileStateRepository;

    @Mock
    private PersistenceRangeRepository<String, Long, MalwareScanFileState> malwareScanFileStateHistoryRangeRepository;

    @Mock
    private PersistenceRangeRepository<String, RangeKey, MalwareScanFileMapping> malwareScanFileMappingRangeRepository;

    @Mock
    private TemporalSupplier<Long> instantSupplier;

    private MalwareScanPersistenceService malwareScanPersistenceService;

    @Before
    public void before() {
        when(instantSupplier.now()).thenReturn(EPOCH_MILLI_1);

        malwareScanPersistenceService = new MalwareScanPersistenceService(malwareScanFileStateRepository, malwareScanFileStateHistoryRangeRepository,
            malwareScanFileMappingRangeRepository, instantSupplier);
    }

    @DataProvider
    public static Object[][] dataProviderStatusTransition() {
        return new Object[][] {
            {Status.PENDING, Status.PENDING, Actor.SYMPHONY},
            {Status.PENDING, Status.OK, Actor.MALWARE_SCANNER},
            {Status.PENDING, Status.BAD, Actor.MALWARE_SCANNER},
            {Status.PENDING, Status.UNSCANNABLE, Actor.MALWARE_SCANNER},
            {Status.PENDING, Status.FAILED_SUBMIT, Actor.SYMPHONY},
            {Status.PENDING, Status.FAILED_RETRY, Actor.SYMPHONY},
            {Status.PENDING, Status.SUBMITTED, Actor.SYMPHONY},
            {Status.SUBMITTED, Status.SUBMITTED, Actor.SYMPHONY},
            {Status.SUBMITTED, Status.OK, Actor.MALWARE_SCANNER},
            {Status.SUBMITTED, Status.BAD, Actor.MALWARE_SCANNER},
            {Status.SUBMITTED, Status.UNSCANNABLE, Actor.MALWARE_SCANNER},
            {Status.OK, Status.OK, Actor.MALWARE_SCANNER},
            {Status.OK, Status.EXPIRED, Actor.MALWARE_SCANNER},
            {Status.OK, Status.BAD, Actor.MALWARE_SCANNER},
            {Status.OK, Status.UNSCANNABLE, Actor.MALWARE_SCANNER},
            {Status.BAD, Status.BAD, Actor.MALWARE_SCANNER},
            {Status.BAD, Status.EXPIRED, Actor.MALWARE_SCANNER},
            {Status.BAD, Status.OK, Actor.MALWARE_SCANNER},
            {Status.BAD, Status.UNSCANNABLE, Actor.MALWARE_SCANNER},
            {Status.UNSCANNABLE, Status.UNSCANNABLE, Actor.MALWARE_SCANNER},
            {Status.UNSCANNABLE, Status.EXPIRED, Actor.MALWARE_SCANNER},
            {Status.UNSCANNABLE, Status.PENDING, Actor.SYMPHONY},
            {Status.UNSCANNABLE, Status.OK, Actor.MALWARE_SCANNER},
            {Status.UNSCANNABLE, Status.BAD, Actor.MALWARE_SCANNER},
            {Status.EXPIRED, Status.EXPIRED, Actor.MALWARE_SCANNER},
            {Status.FAILED_SUBMIT, Status.FAILED_SUBMIT, Actor.SYMPHONY},
            {Status.FAILED_SUBMIT, Status.FAILED_RETRY, Actor.SYMPHONY},
            {Status.FAILED_SUBMIT, Status.SUBMITTED, Actor.SYMPHONY},
            {Status.FAILED_RETRY, Status.FAILED_RETRY, Actor.SYMPHONY},
        };
    }

    @DataProvider
    public static Object[][] dataProviderErrorStatusTransition() {
        return new Object[][] {
            {Status.OK, Status.PENDING, Actor.SYMPHONY}, // DLP-5059: OK to PENDING transfer is not allowed in GA release
            {Status.BAD, Status.PENDING, Actor.SYMPHONY}, // DLP-5059: BAD to PENDING transfer is not allowed in GA release
            {Status.SUBMITTED, Status.PENDING, Actor.SYMPHONY},
            {Status.SUBMITTED, Status.FAILED_SUBMIT, Actor.SYMPHONY},
            {Status.OK, Status.SUBMITTED, Actor.SYMPHONY}
        };
    }

    @Test
    @UseDataProvider("dataProviderStatusTransition")
    public void putMalwareScanFileState_statusTransition_malwareScanFileStatePut(final Status from, final Status to, final Actor actor) throws Exception {
        final MalwareScanFileState malwareScanFileStateFrom = MalwareScanFileState.builder().fileId(FILE_ID).status(from).build();
        when(malwareScanFileStateRepository.load(FILE_ID)).thenReturn(malwareScanFileStateFrom);

        final MalwareScanFileState malwareScanFileStateTo = MalwareScanFileState.builder().fileId(FILE_ID).status(to).build();
        malwareScanPersistenceService.putMalwareScanFileState(malwareScanFileStateTo, actor);

        final ArgumentCaptor<MalwareScanFileState> malwareScanFileStatePersist = ArgumentCaptor.forClass(MalwareScanFileState.class);
        verify(malwareScanFileStateRepository, times(1)).save(eq(FILE_ID), eq(malwareScanFileStateFrom), malwareScanFileStatePersist.capture());
        assertThat(malwareScanFileStatePersist.getValue().getFileId()).isEqualTo(FILE_ID);
        assertThat(malwareScanFileStatePersist.getValue().getStatus()).isEqualTo(to);
        assertThat(malwareScanFileStatePersist.getValue().getCreateTimestamp()).isNull();
        assertThat(malwareScanFileStatePersist.getValue().getCreatedBy()).isNull();
        assertThat(malwareScanFileStatePersist.getValue().getLastUpdateTimestamp()).isEqualTo(
            EPOCH_MILLI_INSTANT_1);
        assertThat(malwareScanFileStatePersist.getValue().getLastUpdatedBy()).isEqualTo(actor);

        final ArgumentCaptor<MalwareScanFileState> malwareScanFileStateHistoPersist = ArgumentCaptor.forClass(MalwareScanFileState.class);
        verify(malwareScanFileStateHistoryRangeRepository, times(1)).save(eq(FILE_ID), eq(
            EPOCH_MILLI_1), malwareScanFileStateHistoPersist.capture());
        assertThat(malwareScanFileStateHistoPersist.getValue()).isSameAs(malwareScanFileStatePersist.getValue());
    }

    @Test
    public void putMalwareScanFileState_newMalwareScanFileStateActorIsSymphony_malwareScanFileStatePut() throws Exception {
        final MalwareScanFileState malwareScanFileState = MalwareScanFileState.builder().fileId(FILE_ID).status(Status.PENDING).build();

        when(malwareScanFileStateRepository.load(FILE_ID)).thenReturn(null);

        malwareScanPersistenceService.putMalwareScanFileState(malwareScanFileState, Actor.SYMPHONY);

        final ArgumentCaptor<MalwareScanFileState> malwareScanFileStatePersist = ArgumentCaptor.forClass(MalwareScanFileState.class);
        verify(malwareScanFileStateRepository, times(1)).save(eq(FILE_ID), isNull(), malwareScanFileStatePersist.capture());
        assertThat(malwareScanFileStatePersist.getValue().getFileId()).isEqualTo(FILE_ID);
        assertThat(malwareScanFileStatePersist.getValue().getStatus()).isEqualTo(Status.PENDING);
        assertThat(malwareScanFileStatePersist.getValue().getCreateTimestamp()).isEqualTo(
            EPOCH_MILLI_INSTANT_1);
        assertThat(malwareScanFileStatePersist.getValue().getCreatedBy()).isEqualTo(Actor.SYMPHONY);
        assertThat(malwareScanFileStatePersist.getValue().getLastUpdateTimestamp()).isEqualTo(
            EPOCH_MILLI_INSTANT_1);
        assertThat(malwareScanFileStatePersist.getValue().getLastUpdatedBy()).isEqualTo(Actor.SYMPHONY);

        final ArgumentCaptor<MalwareScanFileState> malwareScanFileStateHistoPersist = ArgumentCaptor.forClass(MalwareScanFileState.class);
        verify(malwareScanFileStateHistoryRangeRepository, times(1)).save(eq(FILE_ID), eq(
            EPOCH_MILLI_1), malwareScanFileStateHistoPersist.capture());
        assertThat(malwareScanFileStateHistoPersist.getValue()).isSameAs(malwareScanFileStatePersist.getValue());
    }

    @Test
    public void putMalwareScanFileState_newMalwareScanFileStateActorIsMalwareScanner_exceptionThrown() throws Exception {
        final MalwareScanFileState malwareScanFileState = MalwareScanFileState.builder().fileId(FILE_ID).status(Status.PENDING).build();

        when(malwareScanFileStateRepository.load(FILE_ID)).thenReturn(null);

        assertThatThrownBy(() -> malwareScanPersistenceService.putMalwareScanFileState(malwareScanFileState, Actor.MALWARE_SCANNER))
            .isInstanceOf(MalwareScanException.class)
            .hasMessage("Update to PENDING status is not allowed for MALWARE_SCANNER actor");

        verify(malwareScanFileStateRepository, times(0)).save(any(String.class), any(MalwareScanFileState.class), any(MalwareScanFileState.class));
        verify(malwareScanFileStateHistoryRangeRepository, times(0)).save(any(String.class), any(Long.class), any(MalwareScanFileState.class));
    }

    @Test
    public void putMalwareScanFileState_existingMalwareScanFileStateSubmittedToBadWithDetailsActorIsMalwareScanner_malwareScanFileStatePut() throws Exception {
        final String detailsMessage = "details_message";
        final String detailsLinkText = "details_link_text";
        final String detailsLinkUrl = "https://abc.com";
        final com.symphony.malware.scan.model.MalwareScanFileStatusDetails details = new MalwareScanFileStatusDetails(detailsMessage, detailsLinkText, detailsLinkUrl);
        final MalwareScanFileState malwareScanFileState = MalwareScanFileState.builder().fileId(FILE_ID).status(Status.BAD).details(details).build();

        MalwareScanFileState currentValue = malwareScanFileState.toBuilder().status(Status.SUBMITTED)
            .createTimestamp(EPOCH_MILLI_INSTANT_0).createdBy(Actor.SYMPHONY).build();
        when(malwareScanFileStateRepository.load(FILE_ID)).thenReturn(currentValue);

        malwareScanPersistenceService.putMalwareScanFileState(malwareScanFileState, Actor.MALWARE_SCANNER);

        final ArgumentCaptor<MalwareScanFileState> malwareScanFileStatePersist = ArgumentCaptor.forClass(MalwareScanFileState.class);
        verify(malwareScanFileStateRepository, times(1)).save(eq(FILE_ID), eq(currentValue), malwareScanFileStatePersist.capture());
        assertThat(malwareScanFileStatePersist.getValue().getFileId()).isEqualTo(FILE_ID);
        assertThat(malwareScanFileStatePersist.getValue().getStatus()).isEqualTo(Status.BAD);
        assertThat(malwareScanFileStatePersist.getValue().getCreateTimestamp()).isEqualTo(
            EPOCH_MILLI_INSTANT_0);
        assertThat(malwareScanFileStatePersist.getValue().getCreatedBy()).isEqualTo(Actor.SYMPHONY);
        assertThat(malwareScanFileStatePersist.getValue().getLastUpdateTimestamp()).isEqualTo(
            EPOCH_MILLI_INSTANT_1);
        assertThat(malwareScanFileStatePersist.getValue().getLastUpdatedBy()).isEqualTo(Actor.MALWARE_SCANNER);
        assertThat(malwareScanFileStatePersist.getValue().getDetails().getMessage()).isEqualTo(detailsMessage);
        assertThat(malwareScanFileStatePersist.getValue().getDetails().getLink().getText()).isEqualTo(detailsLinkText);
        assertThat(malwareScanFileStatePersist.getValue().getDetails().getLink().getUrl()).isEqualTo(detailsLinkUrl);
    }

    @Test
    @UseDataProvider("dataProviderErrorStatusTransition")
    public void putMalwareScanFileState_stateTransferNotAllowed(final Status from, final Status to, final Actor actor) throws Exception {
        final MalwareScanFileState currentMalwareScanState = MalwareScanFileState
                .builder()
                .fileId(FILE_ID)
                .status(from)
                .createTimestamp(EPOCH_MILLI_INSTANT_0)
                .build();

        when(malwareScanFileStateRepository.load(FILE_ID)).thenReturn(currentMalwareScanState);

        final MalwareScanFileState newMalwareScanState = MalwareScanFileState
                .builder()
                .fileId(FILE_ID)
                .status(to)
                .createdBy(actor)
                .build();

        assertThatThrownBy(() -> malwareScanPersistenceService.putMalwareScanFileState(newMalwareScanState, Actor.SYMPHONY))
                .isInstanceOf(MalwareScanStatusTransferException.class)
                .hasMessage("Transfer from " + from + " status to " + to + " status is not allowed");

        verify(malwareScanFileStateRepository, times(0)).save(any(String.class), any(MalwareScanFileState.class), any(MalwareScanFileState.class));
        verify(malwareScanFileStateHistoryRangeRepository, times(0)).save(any(String.class), any(Long.class), any(MalwareScanFileState.class));
    }

    @Test
    public void putMalwareScanFileState_existingMalwareScanFileStateSubmittedToOkActorIsSymphony_exceptionThrown() throws Exception {
        final MalwareScanFileState malwareScanFileState = MalwareScanFileState.builder().fileId(FILE_ID).status(Status.OK).build();

        when(malwareScanFileStateRepository.load(FILE_ID)).thenReturn(malwareScanFileState.toBuilder().status(Status.SUBMITTED)
            .createTimestamp(EPOCH_MILLI_INSTANT_0).createdBy(Actor.SYMPHONY).build());

        assertThatThrownBy(() -> malwareScanPersistenceService.putMalwareScanFileState(malwareScanFileState, Actor.SYMPHONY))
            .isInstanceOf(MalwareScanException.class)
            .hasMessage("Update to OK status is not allowed for SYMPHONY actor");

        verify(malwareScanFileStateRepository, times(0)).save(any(String.class), any(MalwareScanFileState.class), any(MalwareScanFileState.class));
        verify(malwareScanFileStateHistoryRangeRepository, times(0)).save(any(String.class), any(Long.class), any(MalwareScanFileState.class));
    }

    @Test
    public void getMalwareScanFileState_malwareScanFileStateExists_malwareScanFileStateReturned() throws Exception {
        when(malwareScanFileStateRepository.load(FILE_ID)).thenReturn(MalwareScanFileState.builder().fileId(FILE_ID)
            .status(Status.SUBMITTED).createTimestamp(EPOCH_MILLI_INSTANT_0).createdBy(Actor.SYMPHONY).build());

        assertThat(malwareScanPersistenceService.getMalwareScanFileState(FILE_ID)).isNotEmpty();

        verify(malwareScanFileStateRepository, times(1)).load(eq(FILE_ID));
    }

    @Test
    public void getMalwareScanFileState_malwareScanFileStateDoesNotExist_emptyOptionalReturned() throws Exception {
        when(malwareScanFileStateRepository.load(FILE_ID)).thenReturn(null);

        assertThat(malwareScanPersistenceService.getMalwareScanFileState(FILE_ID)).isEmpty();

        verify(malwareScanFileStateRepository, times(1)).load(eq(FILE_ID));
    }

    @Test
    public void getMalwareScanFileStates_byFileId_malwareScanFileStatesReturned() throws Exception {
        when(malwareScanFileStateHistoryRangeRepository.loadRange(FILE_ID)).thenReturn(
            ImmutableList.of(
                MalwareScanFileState.builder().fileId(FILE_ID).status(Status.SUBMITTED).createTimestamp(
                    EPOCH_MILLI_INSTANT_0).createdBy(Actor.SYMPHONY).build()
            )
        );

        assertThat(malwareScanPersistenceService.getMalwareScanFileStates(FILE_ID)).extracting(MalwareScanFileState::getFileId).containsExactly(FILE_ID);

        verify(instantSupplier, times(0)).now();
        verify(malwareScanFileStateHistoryRangeRepository, times(1)).loadRange(eq(FILE_ID));
    }

    @Test
    public void getMalwareScanFileStates_byFileIdAndFrom_malwareScanFileStatesReturned() throws Exception {
        when(malwareScanFileStateHistoryRangeRepository.loadRange(FILE_ID, EPOCH_MILLI_0,
            EPOCH_MILLI_1)).thenReturn(
            ImmutableList.of(
                MalwareScanFileState.builder().fileId(FILE_ID).status(Status.SUBMITTED).createTimestamp(
                    EPOCH_MILLI_INSTANT_0).createdBy(Actor.SYMPHONY).build()
            )
        );

        assertThat(malwareScanPersistenceService.getMalwareScanFileStates(FILE_ID,
            EPOCH_MILLI_0)).extracting(MalwareScanFileState::getFileId).containsExactly(FILE_ID);

        verify(instantSupplier, times(1)).now();
        verify(malwareScanFileStateHistoryRangeRepository, times(1)).loadRange(eq(FILE_ID), eq(
            EPOCH_MILLI_0), eq(EPOCH_MILLI_1));
    }

    @Test
    public void getMalwareScanFileStates_byFileIdAndFromAndTo_malwareScanFileStatesReturned() throws Exception {
        when(malwareScanFileStateHistoryRangeRepository.loadRange(FILE_ID, EPOCH_MILLI_0,
            EPOCH_MILLI_1)).thenReturn(
            ImmutableList.of(
                MalwareScanFileState.builder().fileId(FILE_ID).status(Status.SUBMITTED).createTimestamp(
                    EPOCH_MILLI_INSTANT_0).createdBy(Actor.SYMPHONY).build()
            )
        );

        assertThat(malwareScanPersistenceService.getMalwareScanFileStates(FILE_ID,
            EPOCH_MILLI_0, EPOCH_MILLI_1)).extracting(MalwareScanFileState::getFileId)
            .containsExactly(FILE_ID);

        verify(instantSupplier, times(0)).now();
        verify(malwareScanFileStateHistoryRangeRepository, times(1)).loadRange(eq(FILE_ID), eq(
            EPOCH_MILLI_0), eq(EPOCH_MILLI_1));
    }

    @Test
    public void putMalwareScanFileMapping_malwareScanFileMappingPut() throws Exception {
        final MalwareScanFileMapping malwareScanFileMapping = MalwareScanFileMapping.builder().fileId(FILE_ID).streamId(STREAM_ID).messageId(MESSAGE_ID).build();

        malwareScanPersistenceService.putMalwareScanFileMapping(malwareScanFileMapping);

        final ArgumentCaptor<RangeKey> argumentCaptor = ArgumentCaptor.forClass(RangeKey.class);
        verify(malwareScanFileMappingRangeRepository, times(1)).save(eq(FILE_ID), argumentCaptor.capture(), eq(malwareScanFileMapping));

        assertThat(argumentCaptor.getValue().getStreamId()).isEqualTo(STREAM_ID);
        assertThat(argumentCaptor.getValue().getMessageId()).isEqualTo(MESSAGE_ID);
    }

    @Test
    public void getMalwareScanFileMapping_malwareScanFileStateInfosReturned() throws Exception {
        when(malwareScanFileMappingRangeRepository.loadRange(FILE_ID)).thenReturn(
            ImmutableList.of(
                MalwareScanFileMapping.builder().fileId(FILE_ID).streamId(STREAM_ID).messageId(MESSAGE_ID).build(),
                MalwareScanFileMapping.builder().fileId(FILE_ID).streamId(STREAM_ID + "1").messageId(MESSAGE_ID + "1").build(),
                MalwareScanFileMapping.builder().fileId(FILE_ID).streamId(STREAM_ID + "2").messageId(MESSAGE_ID + "2").build()
            )
        );

        final List<MalwareScanFileMapping> malwareScanFileMappings = malwareScanPersistenceService.getMalwareScanFileMappings(FILE_ID, STREAM_ID, MESSAGE_ID);

        verify(malwareScanFileMappingRangeRepository, times(1)).loadRange(FILE_ID);

        assertThat(malwareScanFileMappings).hasSize(1);
        assertThat(malwareScanFileMappings.get(0).getFileId()).isEqualTo(FILE_ID);
        assertThat(malwareScanFileMappings.get(0).getStreamId()).isEqualTo(STREAM_ID);
        assertThat(malwareScanFileMappings.get(0).getMessageId()).isEqualTo(MESSAGE_ID);
    }

    @Test
    public void putIfAbsent_saved() throws PersistentException, MalwareScanException {
        final MalwareScanFileState malwareScanFileState = MalwareScanFileState.builder()
            .fileId(FILE_ID).status(Status.PENDING).build();

        doNothing().when(malwareScanFileStateRepository)
            .save(eq(malwareScanFileState.getFileId()), isNull(), any(MalwareScanFileState.class));

        assertThat(malwareScanPersistenceService.putIfAbsent(malwareScanFileState, Actor.SYMPHONY))
            .isNull();

        ArgumentCaptor<MalwareScanFileState> fileMappingCaptor = ArgumentCaptor.forClass(MalwareScanFileState.class);
        verify(malwareScanFileStateRepository, times(1))
            .save(eq(malwareScanFileState.getFileId()), isNull(), fileMappingCaptor.capture());
        verify(malwareScanFileStateHistoryRangeRepository, times(1))
            .save(eq(malwareScanFileState.getFileId()), eq(EPOCH_MILLI_1), fileMappingCaptor.capture());

        assertThat(fileMappingCaptor.getAllValues().get(0).getFileId()).isEqualTo(FILE_ID);
        assertThat(fileMappingCaptor.getAllValues().get(0).getStatus()).isEqualTo(Status.PENDING);
        assertThat(fileMappingCaptor.getAllValues().get(0).getCreateTimestamp()).isEqualTo(
            EPOCH_MILLI_INSTANT_1);
        assertThat(fileMappingCaptor.getAllValues().get(0).getCreatedBy()).isEqualTo(Actor.SYMPHONY);
        assertThat(fileMappingCaptor.getAllValues().get(0).getLastUpdateTimestamp()).isEqualTo(
            EPOCH_MILLI_INSTANT_1);
        assertThat(fileMappingCaptor.getAllValues().get(0).getLastUpdatedBy()).isEqualTo(Actor.SYMPHONY);

        assertThat(fileMappingCaptor.getAllValues().get(0)).isSameAs(fileMappingCaptor.getAllValues().get(1));
    }

    @Test
    public void putIfAbsent_loaded() throws PersistentException, MalwareScanException {
        final MalwareScanFileState newMalwareScanFileState = MalwareScanFileState.builder()
            .fileId(FILE_ID).status(Status.PENDING).build();
        final MalwareScanFileState existentMalwareScanFileState = MalwareScanFileState.builder()
            .fileId(FILE_ID).status(Status.SUBMITTED).build();

        PersistentException pe = mock(PersistentException.class);
        when(pe.getCause()).thenReturn(mock(OptimisticLockException.class));

        doThrow(pe).when(malwareScanFileStateRepository)
            .save(eq(newMalwareScanFileState.getFileId()), isNull(), any(MalwareScanFileState.class));
        doReturn(existentMalwareScanFileState).when(malwareScanFileStateRepository)
            .load(newMalwareScanFileState.getFileId());

        MalwareScanFileState returnedState = malwareScanPersistenceService
            .putIfAbsent(newMalwareScanFileState, Actor.SYMPHONY);

        assertThat(returnedState).isEqualTo(existentMalwareScanFileState);
    }

    @Test
    public void putIfAbsent_actorNotAllowed() {
        final MalwareScanFileState pendingState = MalwareScanFileState.builder()
            .fileId(FILE_ID).status(Status.PENDING).build();

        assertThatThrownBy(() -> malwareScanPersistenceService.putIfAbsent(pendingState, Actor.MALWARE_SCANNER))
            .isInstanceOf(MalwareScanException.class)
            .hasMessage("Update to PENDING status is not allowed for MALWARE_SCANNER actor");

        final MalwareScanFileState okState = MalwareScanFileState.builder()
            .fileId(FILE_ID).status(Status.OK).build();
        assertThatThrownBy(() -> malwareScanPersistenceService.putIfAbsent(okState, Actor.SYMPHONY))
            .isInstanceOf(MalwareScanException.class)
            .hasMessage("Update to OK status is not allowed for SYMPHONY actor");
    }

    @Test
    public void putIfAbsent_persistentException() throws PersistentException {
        final MalwareScanFileState newMalwareScanFileState = MalwareScanFileState.builder()
            .fileId(FILE_ID).status(Status.PENDING).build();

        PersistentException pe = mock(PersistentException.class);

        doThrow(pe).when(malwareScanFileStateRepository)
            .save(eq(newMalwareScanFileState.getFileId()), isNull(), any(MalwareScanFileState.class));
        verify(malwareScanFileStateRepository, never()).load(newMalwareScanFileState.getFileId());

        assertThatThrownBy(() -> malwareScanPersistenceService.putIfAbsent(newMalwareScanFileState, Actor.SYMPHONY))
            .isSameAs(pe);
    }
}
