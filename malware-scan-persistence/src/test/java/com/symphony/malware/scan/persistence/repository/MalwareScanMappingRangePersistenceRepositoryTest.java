package com.symphony.malware.scan.persistence.repository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.symphony.data.infrastructure.IPersistenceInfra;
import com.symphony.data.mapper.IPaginatedIterable;
import com.symphony.data.mapper.IRangeTable;
import com.symphony.data.mapper.IResult;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.model.MalwareScanMapping;
import com.symphony.malware.scan.persistence.repository.MalwareScanMappingRangePersistenceRepository.RangeKey;

import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.lang3.CharEncoding;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import util.TemporalSupplier;

import java.io.Closeable;
import java.nio.charset.Charset;
import java.time.Instant;
import java.util.Iterator;
import java.util.List;
import java.util.function.Supplier;

@RunWith(MockitoJUnitRunner.class)
public class MalwareScanMappingRangePersistenceRepositoryTest {

  private static final Charset CHARSET = Charset.forName(CharEncoding.UTF_8);
  private static final String MALWARE_SCAN_STATE_INFO_TABLE = "malwareScanMapping";

  private static final String FILE_ID = "fileId0001";
  private static final String STREAM_ID_FROM = "streamIdFrom0001";
  private static final String MESSAGE_ID_FROM = "messageIdFrom0001";
  private static final String STREAM_ID_TO = "streamIdTo0001";
  private static final String MESSAGE_ID_TO = "messageIdTo0001";
  private static final Instant EPOCH_MILLI_0 = Instant.ofEpochMilli(0L);
  private static final Instant EPOCH_MILLI_1 = Instant.ofEpochMilli(1L);

  @Mock
  private IPersistenceInfra persistenceInfra;

  @Mock
  private TemporalSupplier<Instant> instantSupplier;

  @Mock
  private Supplier<ObjectMapper> objectMapperSupplier;

  @Mock
  private ObjectMapper objectMapper;

  @Mock
  private IRangeTable malwareScanMappingRangeTable;

  @Mock
  private Closeable closeable;

  @Mock
  private IPaginatedIterable<IResult> resultPaginatedIterable;

  @Mock
  private Iterator<IResult> resultIterator;

  @Mock
  private IResult result;

  @Before
  public void before() throws Exception {
    when(instantSupplier.min()).thenReturn(EPOCH_MILLI_0);
    when(instantSupplier.now()).thenReturn(EPOCH_MILLI_1);
    when(objectMapperSupplier.get()).thenReturn(objectMapper);
    when(persistenceInfra.getRangeTable(MALWARE_SCAN_STATE_INFO_TABLE)).thenReturn(malwareScanMappingRangeTable);
  }

  @Test
  public void createRepository_malwareScanMappingTableExists_createTableNotCalled() throws Exception {
    when(malwareScanMappingRangeTable.exist()).thenReturn(Boolean.TRUE);

    new MalwareScanMappingRangePersistenceRepository(persistenceInfra, instantSupplier, objectMapperSupplier);

    verify(malwareScanMappingRangeTable, times(0)).createTable();
  }

  @Test
  public void createRepository_malwareScanMappingTableDoesNotExist_createTableCalled() throws Exception {
    when(malwareScanMappingRangeTable.exist()).thenReturn(Boolean.FALSE);

    new MalwareScanMappingRangePersistenceRepository(persistenceInfra, instantSupplier, objectMapperSupplier);

    verify(malwareScanMappingRangeTable, times(1)).createTable();
  }

  @Test
  public void save_noException_malwareScanMappingPut() throws Exception {
    final RangeKey rangeKey = new RangeKey();
    final MalwareScanMapping malwareScanMapping = MalwareScanMapping.builder().fileId(FILE_ID).build();

    when(objectMapper.writeValueAsString(malwareScanMapping)).thenReturn("{}");
    new MalwareScanMappingRangePersistenceRepository(persistenceInfra, instantSupplier, objectMapperSupplier).save(FILE_ID, rangeKey, malwareScanMapping);

    verify(objectMapper, times(1)).writeValueAsString(malwareScanMapping);
    verify(malwareScanMappingRangeTable, times(1)).save(eq(FILE_ID.getBytes(CHARSET)), eq((Long.toString(1L) + rangeKey).getBytes(CHARSET)), any(byte[].class));
  }

  @Test
  public void save_jsonProcessingException_persistentExceptionThrown() throws Exception {
    final RangeKey rangeKey = new RangeKey(STREAM_ID_FROM, MESSAGE_ID_FROM);
    final MalwareScanMapping malwareScanMapping = MalwareScanMapping.builder().fileId(FILE_ID).build();

    when(objectMapper.writeValueAsString(malwareScanMapping)).thenThrow(new JsonMappingException(closeable, "JSON Mapping Exception"));

    assertThatThrownBy(() -> new MalwareScanMappingRangePersistenceRepository(persistenceInfra, instantSupplier, objectMapperSupplier)
        .save(FILE_ID, rangeKey, malwareScanMapping)).isInstanceOf(PersistentException.class)
        .hasMessage("com.fasterxml.jackson.databind.JsonMappingException: JSON Mapping Exception");

    verify(objectMapper, times(1)).writeValueAsString(any(MalwareScanMapping.class));
    verify(malwareScanMappingRangeTable, times(0)).save(any(byte[].class), any(byte[].class), any(byte[].class));
  }

  @Test
  public void loadRange_byFileId_malwareScanMappingsReturned() throws Exception {
    final MalwareScanMapping malwareScanMapping = MalwareScanMapping.builder().fileId(FILE_ID).build();
    final byte[] malwareScanMappingBytes = ("{\"fileId\":\"" + FILE_ID + "\",\"streamId\":\"" + STREAM_ID_FROM + "\",\"fileId\":\"" + MESSAGE_ID_FROM + "\"}").getBytes(CHARSET);

    when(malwareScanMappingRangeTable.batchLoad(eq(FILE_ID.getBytes(CHARSET)), any(byte[].class), any(byte[].class))).thenReturn(resultPaginatedIterable);
    when(resultPaginatedIterable.iterator()).thenReturn(resultIterator);
    when(resultIterator.hasNext()).thenReturn(Boolean.TRUE).thenReturn(Boolean.FALSE);
    when(resultIterator.next()).thenReturn(result);
    when(result.getPayload()).thenReturn(malwareScanMappingBytes);
    when(objectMapper.readValue(malwareScanMappingBytes, MalwareScanMapping.class)).thenReturn(malwareScanMapping);

    final List<MalwareScanMapping> malwareScanMappings = new MalwareScanMappingRangePersistenceRepository(persistenceInfra, instantSupplier, objectMapperSupplier)
        .loadRange(FILE_ID);

    assertThat(malwareScanMappings).hasSize(1);
    assertThat(malwareScanMappings.get(0).getFileId()).isEqualTo(FILE_ID);

    verify(malwareScanMappingRangeTable, times(1)).batchLoad(FILE_ID.getBytes(CHARSET), Long.toString(EPOCH_MILLI_0.toEpochMilli()).getBytes(CHARSET),
        Long.toString(EPOCH_MILLI_1.toEpochMilli()).getBytes(CHARSET));
    verify(objectMapper, times(1)).readValue(malwareScanMappingBytes, MalwareScanMapping.class);
    verify(instantSupplier, times(1)).min();
    verify(instantSupplier, times(1)).now();
  }

  @Test
  public void loadRange_byFileIdAndFrom_malwareScanMappingsReturned() throws Exception {
    final RangeKey fromRangeKey = new RangeKey(STREAM_ID_FROM, MESSAGE_ID_FROM);
    final MalwareScanMapping malwareScanMapping = MalwareScanMapping.builder().fileId(FILE_ID).build();
    final byte[] malwareScanMappingBytes = ("{\"fileId\":\"" + FILE_ID + "\",\"streamId\":\"" + STREAM_ID_FROM + "\",\"fileId\":\"" + MESSAGE_ID_FROM + "\"}").getBytes(CHARSET);

    when(malwareScanMappingRangeTable.batchLoad(eq(FILE_ID.getBytes(CHARSET)), any(byte[].class), any(byte[].class))).thenReturn(resultPaginatedIterable);
    when(resultPaginatedIterable.iterator()).thenReturn(resultIterator);
    when(resultIterator.hasNext()).thenReturn(Boolean.TRUE).thenReturn(Boolean.FALSE);
    when(resultIterator.next()).thenReturn(result);
    when(result.getPayload()).thenReturn(malwareScanMappingBytes);
    when(objectMapper.readValue(malwareScanMappingBytes, MalwareScanMapping.class)).thenReturn(malwareScanMapping);

    final List<MalwareScanMapping> malwareScanMappings = new MalwareScanMappingRangePersistenceRepository(persistenceInfra, instantSupplier, objectMapperSupplier)
        .loadRange(FILE_ID, fromRangeKey);

    assertThat(malwareScanMappings).hasSize(1);
    assertThat(malwareScanMappings.get(0).getFileId()).isEqualTo(FILE_ID);

    verify(malwareScanMappingRangeTable, times(1)).batchLoad(FILE_ID.getBytes(CHARSET), (Long.toString(EPOCH_MILLI_0.toEpochMilli()) + fromRangeKey).getBytes(CHARSET),
        Long.toString(EPOCH_MILLI_1.toEpochMilli()).getBytes(CHARSET));
    verify(objectMapper, times(1)).readValue(malwareScanMappingBytes, MalwareScanMapping.class);
    verify(instantSupplier, times(1)).min();
    verify(instantSupplier, times(1)).now();
  }

  @Test
  public void loadRange_byFileIdAndFromAndTo_malwareScanMappingsReturned() throws Exception {
    final RangeKey fromRangeKey = new RangeKey(STREAM_ID_FROM, MESSAGE_ID_FROM);
    final RangeKey toRangeKey = new RangeKey(STREAM_ID_TO, MESSAGE_ID_TO);
    final MalwareScanMapping malwareScanMapping = MalwareScanMapping.builder().fileId(FILE_ID).build();
    final byte[] malwareScanMappingBytes = ("{\"fileId\":\"" + FILE_ID + "\",\"streamId\":\"" + STREAM_ID_FROM + "\",\"fileId\":\"" + MESSAGE_ID_FROM + "\"}").getBytes(CHARSET);

    when(malwareScanMappingRangeTable.batchLoad(eq(FILE_ID.getBytes(CHARSET)), any(byte[].class), any(byte[].class))).thenReturn(resultPaginatedIterable);
    when(resultPaginatedIterable.iterator()).thenReturn(resultIterator);
    when(resultIterator.hasNext()).thenReturn(Boolean.TRUE).thenReturn(Boolean.FALSE);
    when(resultIterator.next()).thenReturn(result);
    when(result.getPayload()).thenReturn(malwareScanMappingBytes);
    when(objectMapper.readValue(malwareScanMappingBytes, MalwareScanMapping.class)).thenReturn(malwareScanMapping);

    final List<MalwareScanMapping> malwareScanMappings = new MalwareScanMappingRangePersistenceRepository(persistenceInfra, instantSupplier, objectMapperSupplier)
        .loadRange(FILE_ID, fromRangeKey, toRangeKey);

    assertThat(malwareScanMappings).hasSize(1);
    assertThat(malwareScanMappings.get(0).getFileId()).isEqualTo(FILE_ID);

    verify(malwareScanMappingRangeTable, times(1)).batchLoad(FILE_ID.getBytes(CHARSET), (Long.toString(EPOCH_MILLI_0.toEpochMilli()) + fromRangeKey).getBytes(CHARSET),
        (Long.toString(EPOCH_MILLI_1.toEpochMilli()) + toRangeKey).getBytes(CHARSET));
    verify(objectMapper, times(1)).readValue(malwareScanMappingBytes, MalwareScanMapping.class);
    verify(instantSupplier, times(1)).min();
    verify(instantSupplier, times(1)).now();
  }

  @Test
  public void loadRange_jsonProcessingException_persistentExceptionThrown() throws Exception {
    final byte[] malwareScanMappingBytes = ("{\"fileId\":\"" + FILE_ID + "\",\"streamId\":\"" + STREAM_ID_FROM + "\",\"fileId\":\"" + MESSAGE_ID_FROM + "\"}").getBytes(CHARSET);

    when(malwareScanMappingRangeTable.batchLoad(eq(FILE_ID.getBytes(CHARSET)), any(byte[].class), any(byte[].class))).thenReturn(resultPaginatedIterable);
    when(resultPaginatedIterable.iterator()).thenReturn(resultIterator);
    when(resultIterator.hasNext()).thenReturn(Boolean.TRUE).thenReturn(Boolean.FALSE);
    when(resultIterator.next()).thenReturn(result);
    when(result.getPayload()).thenReturn(malwareScanMappingBytes);
    when(objectMapper.readValue(malwareScanMappingBytes, MalwareScanMapping.class)).thenThrow(new JsonMappingException(closeable, "JSON Mapping Exception"));

    assertThatThrownBy(() -> new MalwareScanMappingRangePersistenceRepository(persistenceInfra, instantSupplier, objectMapperSupplier)
        .loadRange(FILE_ID)).isInstanceOf(PersistentException.class)
        .hasMessage("com.fasterxml.jackson.databind.JsonMappingException: JSON Mapping Exception");

    verify(malwareScanMappingRangeTable, times(1)).batchLoad(FILE_ID.getBytes(CHARSET), Long.toString(EPOCH_MILLI_0.toEpochMilli()).getBytes(CHARSET),
        Long.toString(EPOCH_MILLI_1.toEpochMilli()).getBytes(CHARSET));
    verify(objectMapper, times(1)).readValue(malwareScanMappingBytes, MalwareScanMapping.class);
    verify(instantSupplier, times(1)).min();
    verify(instantSupplier, times(1)).now();
  }

  @Test
  public void loadRange_persistentException_persistentExceptionRethrown() throws Exception {
    when(malwareScanMappingRangeTable.batchLoad(FILE_ID.getBytes(CHARSET), Long.toString(EPOCH_MILLI_0.toEpochMilli()).getBytes(CHARSET),
        Long.toString(EPOCH_MILLI_1.toEpochMilli()).getBytes(CHARSET))).thenThrow(new PersistentException("Failed to load batch", ""));

    assertThatThrownBy(() -> new MalwareScanMappingRangePersistenceRepository(persistenceInfra, instantSupplier, objectMapperSupplier)
        .loadRange(FILE_ID)).isInstanceOf(PersistentException.class)
        .hasMessage("Failed to load batch");

    verify(malwareScanMappingRangeTable, times(1)).batchLoad(FILE_ID.getBytes(CHARSET), Long.toString(EPOCH_MILLI_0.toEpochMilli()).getBytes(CHARSET),
        Long.toString(EPOCH_MILLI_1.toEpochMilli()).getBytes(CHARSET));
    verify(objectMapper, times(0)).readValue(any(byte[].class), eq(MalwareScanMapping.class));
    verify(instantSupplier, times(1)).min();
    verify(instantSupplier, times(1)).now();
  }

}
