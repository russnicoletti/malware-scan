package com.symphony.malware.scan.persistence.service;

import static com.symphony.malware.scan.model.MalwareScanFileState.Status;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.model.Actor;
import com.symphony.malware.scan.model.MalwareScanFileMapping;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.persistence.exception.MalwareScanException;
import com.symphony.malware.scan.persistence.exception.MalwareScanStatusTransferException;
import com.symphony.malware.scan.persistence.repository.MalwareScanFileMappingRangeRepository.RangeKey;
import com.symphony.malware.scan.persistence.repository.PersistenceRangeRepository;
import com.symphony.malware.scan.persistence.repository.PersistenceRepository;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import lombok.extern.slf4j.Slf4j;
import util.TemporalSupplier;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;
import javax.persistence.OptimisticLockException;

/**
 * Enforces business logic, which should be applied to the data which is being stored in persistence layer
 * Instead of using repositories directly, this service should be used in order to save and load data to and from the data storage
 */
@Slf4j
public class MalwareScanPersistenceService {

    /**
     * These are statuses, which are allowed for {@link Actor#SYMPHONY} actor
     */
    private static final Set<Status> SYMPHONY_ALLOWED_STATUSES = ImmutableSet.of(
        Status.PENDING, Status.SUBMITTED, Status.FAILED_SUBMIT, Status.FAILED_UPDATE
    );

    /**
     * These are statuses, which are allowed for {@link Actor#MALWARE_SCANNER} actor
     */
    private static final Set<Status> MALWARE_SCANNER_ALLOWED_STATUSES = ImmutableSet.of(
        Status.OK, Status.BAD, Status.UNSCANNABLE, Status.EXPIRED
    );

    /**
     * List of allowed status transitions
     */
    private static final Map<Status, Set<Status>> ALLOWED_STATUS_TRANSITIONS = ImmutableMap.<Status, Set<Status>>builder()
        .put(Status.PENDING,
            ImmutableSet.<Status>builder().add(Status.PENDING, Status.FAILED_SUBMIT, Status.SUBMITTED).addAll(MALWARE_SCANNER_ALLOWED_STATUSES).build())
        .put(Status.FAILED_SUBMIT, ImmutableSet.<Status>builder().add(Status.FAILED_SUBMIT).addAll(MALWARE_SCANNER_ALLOWED_STATUSES).build())
        .put(Status.FAILED_UPDATE, ImmutableSet.<Status>builder().add(Status.FAILED_UPDATE).addAll(MALWARE_SCANNER_ALLOWED_STATUSES).build())
        .put(Status.SUBMITTED, ImmutableSet.<Status>builder().add(Status.FAILED_UPDATE, Status.SUBMITTED).addAll(MALWARE_SCANNER_ALLOWED_STATUSES).build())
        .put(Status.OK, MALWARE_SCANNER_ALLOWED_STATUSES)
        .put(Status.BAD, MALWARE_SCANNER_ALLOWED_STATUSES)
        .put(Status.UNSCANNABLE, MALWARE_SCANNER_ALLOWED_STATUSES)
        .put(Status.EXPIRED, MALWARE_SCANNER_ALLOWED_STATUSES)
        .build();

    private static final BiFunction<Status, Actor, MalwareScanException>
        UPDATE_TO_STATUS_NOT_ALLOWED_FOR_ACTOR = (status, actor) ->
        new MalwareScanStatusTransferException("Update to " + status + " status is not allowed for " + actor + " actor");

    private static final BiFunction<Status, Status, MalwareScanException> TRANSFER_FROM_STATUS_TO_STATUS_NOT_ALLOWED = (fromStatus, toStatus) ->
        new MalwareScanStatusTransferException("Transfer from " + fromStatus + " status to " + toStatus + " status is not allowed");

    private final PersistenceRepository<String, MalwareScanFileState> malwareScanFileStateRepository;
    private final PersistenceRangeRepository<String, Long, MalwareScanFileState> malwareScanFileStateHistoryRangeRepository;
    private final PersistenceRangeRepository<String, RangeKey, MalwareScanFileMapping> malwareScanFileMappingRangeRepository;
    private final TemporalSupplier<Long> timestampMillisSupplier;

    public MalwareScanPersistenceService(
        final PersistenceRepository<String, MalwareScanFileState> malwareScanFileStateRepository,
        final PersistenceRangeRepository<String, Long, MalwareScanFileState> malwareScanFileStateHistoryRangeRepository,
        final PersistenceRangeRepository<String, RangeKey, MalwareScanFileMapping> malwareScanFileMappingRangeRepository,
        final TemporalSupplier<Long> timestampMillisSupplier
    ) {
        this.malwareScanFileStateRepository = malwareScanFileStateRepository;
        this.malwareScanFileStateHistoryRangeRepository = malwareScanFileStateHistoryRangeRepository;
        this.malwareScanFileMappingRangeRepository = malwareScanFileMappingRangeRepository;
        this.timestampMillisSupplier = timestampMillisSupplier;
    }

    /**
     * Put {@link MalwareScanFileState} to the data storage
     * Might throw {@link MalwareScanException} if status transition is not allowed
     * @param newMalwareScanFileState {@link MalwareScanFileState}
     * @param actor {@link Actor} which performs an action
     * @throws PersistentException
     * @throws MalwareScanException
     */
    public void putMalwareScanFileState(@Nonnull final MalwareScanFileState newMalwareScanFileState, @Nonnull final Actor actor) throws PersistentException, MalwareScanException {

        validateUpdateByActor(newMalwareScanFileState, actor);

        final MalwareScanFileState existingMalwareScanFileState = malwareScanFileStateRepository
            .load(newMalwareScanFileState.getFileId());

        MalwareScanFileState mergedMalwareScanFileState;
        if (existingMalwareScanFileState == null) {
            mergedMalwareScanFileState = populateNewMalwareScanFileState(newMalwareScanFileState, actor);
        } else {
            LOGGER.info("Updating an existing malware scan file state record for file id {}: {}",
                newMalwareScanFileState.getFileId(), existingMalwareScanFileState);

            if (!ALLOWED_STATUS_TRANSITIONS.getOrDefault(existingMalwareScanFileState.getStatus(), ImmutableSet.of()).contains(newMalwareScanFileState.getStatus())) {
                throw TRANSFER_FROM_STATUS_TO_STATUS_NOT_ALLOWED.apply(existingMalwareScanFileState.getStatus(), newMalwareScanFileState.getStatus());
            }

            mergedMalwareScanFileState = existingMalwareScanFileState.toBuilder()
                .status(newMalwareScanFileState.getStatus())
                .ttl(newMalwareScanFileState.getTtl())
                .lastUpdateTimestamp(timestampMillisSupplier.now())
                .lastSubmissionAttemptTimestamp(newMalwareScanFileState.getLastSubmissionAttemptTimestamp())
                .lastUpdatedBy(actor)
                .details(newMalwareScanFileState.getDetails())
                .version(existingMalwareScanFileState.getVersion() + 1) // increase the version before saving it
                .build();
            LOGGER.info("Merged malware scan file state record for file id {}: {}", mergedMalwareScanFileState);
        }

        malwareScanFileStateRepository.save(mergedMalwareScanFileState.getFileId(), existingMalwareScanFileState, mergedMalwareScanFileState);
        malwareScanFileStateHistoryRangeRepository.save(mergedMalwareScanFileState.getFileId(), timestampMillisSupplier
            .now(), mergedMalwareScanFileState);
    }

    public MalwareScanFileState putIfAbsent(
        @Nonnull final MalwareScanFileState newMalwareScanFileState,
        @Nonnull final Actor actor) throws PersistentException, MalwareScanException {

        validateUpdateByActor(newMalwareScanFileState, actor);

        MalwareScanFileState createdFileState =
            populateNewMalwareScanFileState(newMalwareScanFileState, actor);

        LOGGER.info("Saving createdFileState {}", createdFileState);

        try {
            malwareScanFileStateRepository.save(createdFileState.getFileId(), null,
                createdFileState);
            LOGGER.info(
                "Inserting a new malware scan file state history record for file id {}: {}",
                newMalwareScanFileState.getFileId(), createdFileState);
            malwareScanFileStateHistoryRangeRepository.save(createdFileState.getFileId(),
                timestampMillisSupplier.now(), createdFileState);
            return null;
        } catch (PersistentException pe) {
            if (pe.getCause() instanceof OptimisticLockException) {
                LOGGER.error("OptimisticLockException: {}", pe);
                MalwareScanFileState foundState =
                    malwareScanFileStateRepository.load(newMalwareScanFileState.getFileId());
                if (foundState != null) {
                    LOGGER.warn(
                        "Found existing record with values: {} ; when trying to insert values: {}.",
                        foundState, newMalwareScanFileState, pe);
                    return foundState;
                }
            }
            // Some other issue than an existing record
            throw pe;
        }
    }

    private MalwareScanFileState populateNewMalwareScanFileState(
        @Nonnull MalwareScanFileState newMalwareScanFileState,
        @Nonnull Actor actor) {

        return newMalwareScanFileState.toBuilder()
            .createTimestamp(timestampMillisSupplier.now())
            .createdBy(actor)
            .lastUpdateTimestamp(timestampMillisSupplier.now())
            .lastUpdatedBy(actor)
            .version(1) // version value for a newly inserted record must be 1
            .build();
    }

    private void validateUpdateByActor(
        @Nonnull MalwareScanFileState newMalwareScanFileState,
        @Nonnull Actor actor)
        throws MalwareScanException {
        if (Actor.SYMPHONY.equals(actor) && !SYMPHONY_ALLOWED_STATUSES.contains(
            newMalwareScanFileState.getStatus())) {
            throw UPDATE_TO_STATUS_NOT_ALLOWED_FOR_ACTOR.apply(newMalwareScanFileState.getStatus(),
                actor);
        }

        if (Actor.MALWARE_SCANNER.equals(actor) && !MALWARE_SCANNER_ALLOWED_STATUSES.contains(
            newMalwareScanFileState.getStatus())) {
            throw UPDATE_TO_STATUS_NOT_ALLOWED_FOR_ACTOR.apply(newMalwareScanFileState.getStatus(),
                actor);
        }
    }

    /**
     * Get {@link MalwareScanFileState}
     * @param fileId file id
     * @return {@link Optional} of {@link MalwareScanFileState}
     * @throws PersistentException
     */
    public Optional<MalwareScanFileState> getMalwareScanFileState(@Nonnull final String fileId) throws PersistentException {
        return Optional.ofNullable(malwareScanFileStateRepository.load(fileId));
    }

    /**
     * Get a list of {@link MalwareScanFileState}s
     * @param fileId file id
     * @return {@link List} of {@link MalwareScanFileState}
     * @throws PersistentException
     */
    public List<MalwareScanFileState> getMalwareScanFileStates(@Nonnull final String fileId) throws PersistentException {
        return malwareScanFileStateHistoryRangeRepository.loadRange(fileId);
    }

    /**
     * Get list of {@link MalwareScanFileState}s, with a starting timestamp in milliseconds
     * @param fileId file id
     * @param fromMillis from timestamp in millis
     * @return {@link List} of {@link MalwareScanFileState}s
     * @throws PersistentException
     */
    public List<MalwareScanFileState> getMalwareScanFileStates(@Nonnull final String fileId, @Nonnull final Long fromMillis) throws PersistentException {
        return malwareScanFileStateHistoryRangeRepository.loadRange(fileId, fromMillis, timestampMillisSupplier
            .now());
    }

    /**
     * Get a list of {@link MalwareScanFileState}s, with a starting and ending timestamp in milliseconds
     * @param fileId file id
     * @param fromMillis from timestamp in millis
     * @param toMillis to timestamp in millis
     * @return {@link List} of {@link MalwareScanFileState}s
     * @throws PersistentException
     */
    public List<MalwareScanFileState> getMalwareScanFileStates(@Nonnull final String fileId, @Nonnull final Long fromMillis,
        @Nonnull final Long toMillis) throws PersistentException {
        return malwareScanFileStateHistoryRangeRepository.loadRange(fileId, fromMillis, toMillis);
    }

    /**
     * Put {@link MalwareScanFileMapping}
     * @param malwareScanFileMapping {@link MalwareScanFileMapping}
     * @throws PersistentException
     */
    public void putMalwareScanFileMapping(@Nonnull final MalwareScanFileMapping malwareScanFileMapping) throws PersistentException {
        malwareScanFileMappingRangeRepository.save(malwareScanFileMapping.getFileId(),
            new RangeKey(malwareScanFileMapping.getStreamId(), malwareScanFileMapping.getMessageId()), malwareScanFileMapping);
    }

    /**
     * Get a list of {@link MalwareScanFileMapping}s
     * @param fileId file id
     * @param streamId stream id
     * @param messageId message id
     * @return {@link List} of {@link MalwareScanFileMapping}s
     * @throws PersistentException
     */
    public List<MalwareScanFileMapping> getMalwareScanFileMappings(
        @Nonnull final String fileId, @Nonnull final String streamId, @Nonnull final String messageId
    ) throws PersistentException {
        return malwareScanFileMappingRangeRepository.loadRange(fileId).stream()
            .filter(mssi -> streamId.equals(mssi.getStreamId())).filter(mssi -> messageId.equals(mssi.getMessageId())).collect(Collectors.toList());
    }

    /**
     * Get a list of {@link MalwareScanFileMapping}s
     * @param fileId file id
     * @return {@link List} of {@link MalwareScanFileMapping}s
     * @throws PersistentException
     */
    public List<MalwareScanFileMapping> getMalwareScanFileMappings(
        @Nonnull final String fileId
    ) throws PersistentException {
        return malwareScanFileMappingRangeRepository.loadRange(fileId);
    }

}
