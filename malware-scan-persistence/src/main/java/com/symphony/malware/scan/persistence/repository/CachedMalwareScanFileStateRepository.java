package com.symphony.malware.scan.persistence.repository;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.model.MalwareScanFileState;
import com.symphony.malware.scan.persistence.util.MalwareScanFileStateCache;

import lombok.extern.slf4j.Slf4j;
import javax.annotation.Nonnull;

/**
 * Returns cached file states if possible, otherwise delegates operations onto {@link MalwareScanFileStateRepository}
 */
@Slf4j
public final class CachedMalwareScanFileStateRepository implements PersistenceRepository<String, MalwareScanFileState> {

  private final MalwareScanFileStateRepository repository;
  private final MalwareScanFileStateCache malwareScanFileStateCache;

    public CachedMalwareScanFileStateRepository(MalwareScanFileStateRepository repository,
                                                MalwareScanFileStateCache malwareScanFileStateCache) {
    this.repository = repository;
    this.malwareScanFileStateCache = malwareScanFileStateCache;
  }

  @Override
  public void save(@Nonnull String key, MalwareScanFileState currentValue,
      @Nonnull MalwareScanFileState newValue) throws PersistentException {
    LOGGER.info("(workflow) storing state {} in cache for {} (current state: {})", newValue, key, currentValue);
    repository.save(key, currentValue, newValue);
    malwareScanFileStateCache.put(key, newValue);
  }

  @Override
  public MalwareScanFileState load(@Nonnull String fileId) throws PersistentException {
    MalwareScanFileState malwareScanFileState = malwareScanFileStateCache.get(fileId);
    LOGGER.info("(workflow) State from cache {} for {}", malwareScanFileState, fileId);

    if (malwareScanFileState == null) {
      malwareScanFileState = repository.load(fileId);

      if (malwareScanFileState != null) {
        malwareScanFileStateCache.put(fileId, malwareScanFileState);
      }
      LOGGER.info("(workflow) State not found in cache for {}. State from repository: {}", fileId, malwareScanFileState);
    }
    return malwareScanFileState;
  }
}