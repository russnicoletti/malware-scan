package com.symphony.malware.scan.persistence.repository;

import com.symphony.data.infrastructure.IPersistenceInfra;
import com.symphony.data.mapper.IKeyValueTable;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.model.MalwareScanFileState;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.function.Supplier;

import javax.annotation.Nonnull;
import javax.persistence.OptimisticLockException;

/**
 * Keeps latest malware scan state of the attachments, which were sent to malware scanner
 */
@Slf4j
public class MalwareScanFileStateRepository implements PersistenceRepository<String, MalwareScanFileState> {

  private static final Charset CHARSET = StandardCharsets.UTF_8;

  private static final String MALWARE_SCAN_FILE_STATE_TABLE = "malwareScanFileState";

  private final IKeyValueTable malwareScanFileStateKeyValueTable;
  private final Supplier<ObjectMapper> objectMapperSupplier;

  public MalwareScanFileStateRepository(final IPersistenceInfra persistenceInfra, final Supplier<ObjectMapper> objectMapperSupplier) throws PersistentException {
    this.malwareScanFileStateKeyValueTable = persistenceInfra.getKeyValueTable(MALWARE_SCAN_FILE_STATE_TABLE);
    if (!malwareScanFileStateKeyValueTable.exist()) {
      LOGGER.info("Creating Malware Scan File State table");
      malwareScanFileStateKeyValueTable.createTable();
    }

    this.objectMapperSupplier = objectMapperSupplier;
  }

  /**
   * This method performs two validations, not only validates the newValue has a bigger version
   * than currentValue but most important it checks the currentValue is the one associated with the
   * fileId before saving (overwriting it with) the newValue.
   * @param fileId
   * @param currentValue value
   * @param newValue
   * @throws PersistentException
   * @throws IllegalArgumentException when the given current and new values do not have same version
   */
  @Override
  public void save(@Nonnull String fileId, MalwareScanFileState currentValue,
      @Nonnull MalwareScanFileState newValue) throws PersistentException {

    if (currentValue != null &&
        (currentValue.getVersion() >= newValue.getVersion() ||
            !currentValue.getFileId().equals(newValue.getFileId()))) {
        throw new IllegalArgumentException(
            String.format("Invalid call to save, tried to update current fileId: %s version: %s with "
                + "new fileId: %s version %s", currentValue.getFileId(), currentValue.getVersion(),
                newValue.getFileId(), newValue.getVersion()));
    }

    try {
      byte[] currentBytes = (currentValue == null) ? null :
          objectMapperSupplier.get().writeValueAsString(currentValue).getBytes(CHARSET);

      byte[] newBytes = objectMapperSupplier.get().writeValueAsString(newValue).getBytes(CHARSET);

      if (!malwareScanFileStateKeyValueTable.checkAndPut(fileId.getBytes(CHARSET), currentBytes, newBytes)) {
        throw new PersistentException(new OptimisticLockException("State was updated by another thread."),
           "Cannot save the given object with fileId: "+ newValue.getVersion());
      }
    } catch (JsonProcessingException jpe) {
      throw new PersistentException(jpe, "Could not convert "
          + MalwareScanFileState.class.getSimpleName() + " to array of bytes");
    }
  }

  @Override
  public MalwareScanFileState load(@Nonnull final String fileId) throws PersistentException {
    try {
      final byte[] bytes = malwareScanFileStateKeyValueTable.load(fileId.getBytes(CHARSET));
      if (bytes != null) {
        return objectMapperSupplier.get().readValue(bytes, MalwareScanFileState.class);
      }
      return null;
    } catch (PersistentException pe) {
      throw pe;
    } catch (IOException ioe) {
      throw new PersistentException(ioe, "Could not convert array of bytes to " + MalwareScanFileState.class.getSimpleName());
    }
  }

}
