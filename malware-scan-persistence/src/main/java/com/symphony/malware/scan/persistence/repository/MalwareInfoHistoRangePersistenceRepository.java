package com.symphony.malware.scan.persistence.repository;

import com.symphony.data.infrastructure.IPersistenceInfra;
import com.symphony.data.mapper.IPaginatedIterable;
import com.symphony.data.mapper.IRangeTable;
import com.symphony.data.mapper.IResult;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.dto.MalwareInfo;
import com.symphony.malware.scan.dto.MalwareScanStateInfo;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.CharEncoding;
import util.TemporalSupplier;

import java.io.IOException;
import java.nio.charset.Charset;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

import javax.annotation.Nonnull;

@Slf4j
public class MalwareInfoHistoRangePersistenceRepository implements RangePersistenceRepository<String, Instant, MalwareInfo> {

  private static final Charset CHARSET = Charset.forName(CharEncoding.UTF_8);

  private static final String MALWARE_INFO_TABLE = "malwareInfoHisto";

  private final ObjectMapper objectMapper;
  private final IRangeTable malwareInfoRangeTable;
  private final TemporalSupplier<Instant> instantSupplier;

  public MalwareInfoHistoRangePersistenceRepository(final IPersistenceInfra persistenceInfra, final TemporalSupplier<Instant> instantSupplier) throws PersistentException {
    this.objectMapper = new ObjectMapper();
    objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

    this.malwareInfoRangeTable = persistenceInfra.getRangeTable(MALWARE_INFO_TABLE);
    if (!malwareInfoRangeTable.exist()) {
      LOGGER.info("Creating Malware Info table");
      malwareInfoRangeTable.createTable();
    }

    this.instantSupplier = instantSupplier;
  }

  @Override
  public void save(@Nonnull final String fileId, @Nonnull final Instant instant, @Nonnull final MalwareInfo malwareInfo) throws PersistentException {
    try {
      malwareInfoRangeTable.save(fileId.getBytes(CHARSET), Long.toString(instant.toEpochMilli()).getBytes(CHARSET),
          objectMapper.writeValueAsString(malwareInfo).getBytes(CHARSET));
    } catch (IOException ioe) {
      throw new PersistentException(ioe, "Could not convert " + MalwareInfo.class.getSimpleName() + " to array of bytes");
    }
  }

  @Override
  public List<MalwareInfo> loadRange(@Nonnull final String fileId) throws PersistentException {
    return loadRange(fileId, instantSupplier.min());
  }

  @Override
  public List<MalwareInfo> loadRange(@Nonnull final String fileId, @NonNull final Instant from) throws PersistentException {
    return loadRange(fileId, from, instantSupplier.now());
  }

  @Override
  public List<MalwareInfo> loadRange(@Nonnull final String fileId, @NonNull final Instant from, @Nonnull final Instant to) throws PersistentException {
    try {
      final IPaginatedIterable<IResult> results = malwareInfoRangeTable.batchLoad(fileId.getBytes(CHARSET),
          Long.toString(from.toEpochMilli()).getBytes(CHARSET), Long.toString(to.toEpochMilli()).getBytes(CHARSET));

      final List<MalwareInfo> malwareInfos = new ArrayList<>();
      for (IResult result : results) {
        malwareInfos.add(objectMapper.readValue(result.getPayload(), MalwareInfo.class));
      }

      return malwareInfos;
    } catch (IOException ioe) {
      throw new PersistentException(ioe, "Could not convert array of bytes to " + MalwareScanStateInfo.class.getSimpleName());
    }
  }

}
