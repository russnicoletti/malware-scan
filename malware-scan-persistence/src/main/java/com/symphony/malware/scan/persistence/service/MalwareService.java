package com.symphony.malware.scan.persistence.service;

import static com.symphony.malware.scan.dto.MalwareInfo.Status;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.dto.Actor;
import com.symphony.malware.scan.dto.MalwareInfo;
import com.symphony.malware.scan.dto.MalwareScanStateInfo;
import com.symphony.malware.scan.persistence.exception.MalwareInfoUpdateException;
import com.symphony.malware.scan.persistence.repository.MalwareScanStateInfoRangePersistenceRepository.RangeKey;
import com.symphony.malware.scan.persistence.repository.PersistenceRepository;
import com.symphony.malware.scan.persistence.repository.RangePersistenceRepository;

import com.google.common.collect.ImmutableSet;
import lombok.RequiredArgsConstructor;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;

@RequiredArgsConstructor
public class MalwareService {

  private final PersistenceRepository<String, MalwareInfo> malwareInfoPersistenceRepository;
  private final RangePersistenceRepository<String, Instant, MalwareInfo> malwareInfoHistoRangePersistenceRepository;
  private final RangePersistenceRepository<String, RangeKey, MalwareScanStateInfo> malwareScanStateInfoRangePersistenceRepository;

  /**
   * These are terminal statuses, which are not allowed to be transferred to another statuses even by Malware Scanner
   */
  private final Set<MalwareInfo.Status> TERMINAL_STATUSES = ImmutableSet.of(
      Status.EXPIRED, Status.OK_DISABLED
  );
  /**
   * These are statuses, which are allowed for {@link Actor#SYMPHONY} actor
   */
  private final Set<MalwareInfo.Status> SYMPHONY_ALLOWED_STATUSES = ImmutableSet.of(
      Status.PENDING, Status.SUBMITTED, Status.FAILED_SUBMIT, Status.FAILED_RETRY, Status.OK_DISABLED
  );

  /**
   * These are statuses, which are allowed for {@link Actor#MALWARE_SCANNER} actor
   */
  private final Set<MalwareInfo.Status> MALWARE_SCANNER_ALLOWED_STATUSES = ImmutableSet.of(
      Status.OK, Status.BAD, Status.UNSCANNABLE, Status.EXPIRED
  );

  public void putMalwareInfo(
      @Nonnull final String fileId, @Nonnull final MalwareInfo newMalwareInfo, @Nonnull final Actor actor
  ) throws PersistentException, MalwareInfoUpdateException {
    final MalwareInfo existingMalwareInfo = malwareInfoPersistenceRepository.load(fileId);

    if (Actor.SYMPHONY.equals(actor) && !SYMPHONY_ALLOWED_STATUSES.contains(newMalwareInfo.getStatus())) {
      throw new MalwareInfoUpdateException("Transfer to " + newMalwareInfo.getStatus() + " status is not allowed for " + actor + " actor");
    }

    if (Actor.MALWARE_SCANNER.equals(actor) && !MALWARE_SCANNER_ALLOWED_STATUSES.contains(newMalwareInfo.getStatus())) {
      throw new MalwareInfoUpdateException("Transfer to " + newMalwareInfo.getStatus() + " status is not allowed for " + actor + " actor");
    }

    MalwareInfo mergedMalwareInfo;
    if (existingMalwareInfo == null) {
      mergedMalwareInfo = newMalwareInfo.toBuilder()
          .createTimestamp(Instant.now())
          .createdBy(actor.toString())
          .lastUpdateTimestamp(Instant.now())
          .lastUpdatedBy(actor.toString())
          .build();
    } else {
      if (TERMINAL_STATUSES.contains(existingMalwareInfo.getStatus())) {
        throw new MalwareInfoUpdateException("Transfer from " + existingMalwareInfo.getStatus() + " terminal status is not allowed");
      }

      mergedMalwareInfo = existingMalwareInfo.toBuilder()
          .status(newMalwareInfo.getStatus())
          .ttl(newMalwareInfo.getTtl())
          .lastUpdateTimestamp(Instant.now())
          .lastUpdatedBy(actor.toString())
          .build();
    }

    malwareInfoPersistenceRepository.save(fileId, mergedMalwareInfo);
    malwareInfoHistoRangePersistenceRepository.save(fileId, Instant.now(), mergedMalwareInfo);
  }

  public Optional<MalwareInfo> getMalwareInfo(@Nonnull final String fileId) throws PersistentException {
    return Optional.ofNullable(malwareInfoPersistenceRepository.load(fileId));
  }

  public List<MalwareInfo> getMalwareInfos(@Nonnull final String fileId) throws PersistentException {
    return getMalwareInfos(fileId, Instant.MIN);
  }

  public List<MalwareInfo> getMalwareInfos(@Nonnull final String fileId, @Nonnull final Instant from) throws PersistentException {
    return getMalwareInfos(fileId, from, Instant.now());
  }

  public List<MalwareInfo> getMalwareInfos(@Nonnull final String fileId, @Nonnull final Instant from, @Nonnull final Instant to) throws PersistentException {
    return malwareInfoHistoRangePersistenceRepository.loadRange(fileId, from, to);
  }

  public void putMalwareScanStateInfo(
      @Nonnull final String fileId, @Nonnull final String streamId, @Nonnull final String messageId,
      @Nonnull final MalwareScanStateInfo malwareScanStateInfo
  ) throws PersistentException {
    malwareScanStateInfoRangePersistenceRepository.save(fileId, new RangeKey(streamId, messageId), malwareScanStateInfo);
  }

  public List<MalwareScanStateInfo> getMalwareScanStateInfo(
      @Nonnull final String fileId, @Nonnull final String streamId, @Nonnull final String messageId
  ) throws PersistentException {
    return malwareScanStateInfoRangePersistenceRepository.loadRange(fileId).stream()
        .filter(mssi -> streamId.equals(mssi.getStreamId())).filter(mssi -> messageId.equals(mssi.getMessageId())).collect(Collectors.toList());
  }
}
