package com.symphony.malware.scan.persistence.repository;

import com.symphony.data.infrastructure.IPersistenceInfra;
import com.symphony.data.mapper.IPaginatedIterable;
import com.symphony.data.mapper.IRangeTable;
import com.symphony.data.mapper.IResult;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.dto.MalwareScanStateInfo;
import com.symphony.malware.scan.persistence.repository.MalwareScanStateInfoRangePersistenceRepository.RangeKey;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.CharEncoding;
import util.TemporalSupplier;

import java.io.IOException;
import java.nio.charset.Charset;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

import javax.annotation.Nonnull;

@Slf4j
public class MalwareScanStateInfoRangePersistenceRepository implements RangePersistenceRepository<String, RangeKey, MalwareScanStateInfo> {

  private static final Charset CHARSET = Charset.forName(CharEncoding.UTF_8);

  private static final String MALWARE_SCAN_STATE_INFO_TABLE = "malwareScanStateInfo";

  private final IRangeTable malwareScanStateInfoRangeTable;
  private final TemporalSupplier<Instant> instantSupplier;
  private final Supplier<ObjectMapper> objectMapperSupplier;

  public MalwareScanStateInfoRangePersistenceRepository(final IPersistenceInfra persistenceInfra,
      final TemporalSupplier<Instant> instantSupplier, final Supplier<ObjectMapper> objectMapperSupplier) throws PersistentException {

    this.malwareScanStateInfoRangeTable = persistenceInfra.getRangeTable(MALWARE_SCAN_STATE_INFO_TABLE);
    if (!malwareScanStateInfoRangeTable.exist()) {
      LOGGER.info("Creating Malware Scan State Info table");
      malwareScanStateInfoRangeTable.createTable();
    }

    this.instantSupplier = instantSupplier;
    this.objectMapperSupplier = objectMapperSupplier;
  }

  @Override
  public void save(@Nonnull final String fileId, @Nonnull final RangeKey rangeKey, @Nonnull final MalwareScanStateInfo malwareScanStateInfo) throws PersistentException {
    try {
      malwareScanStateInfoRangeTable.save(fileId.getBytes(CHARSET), (Long.toString(instantSupplier.now().toEpochMilli()) + rangeKey).getBytes(CHARSET),
          objectMapperSupplier.get().writeValueAsString(malwareScanStateInfo).getBytes(CHARSET));
    } catch (JsonProcessingException jpe) {
      throw new PersistentException(jpe, "Could not convert " + MalwareScanStateInfo.class.getSimpleName() + " to array of bytes");
    }
  }

  @Override
  public List<MalwareScanStateInfo> loadRange(@Nonnull final String fileId) throws PersistentException {
    return loadRange(fileId, new RangeKey());
  }

  @Override
  public List<MalwareScanStateInfo> loadRange(@Nonnull final String fileId, @NonNull final RangeKey from) throws PersistentException {
    return loadRange(fileId, from, new RangeKey());
  }

  @Override
  public List<MalwareScanStateInfo> loadRange(@Nonnull final String fileId, @NonNull final RangeKey from, @NonNull final RangeKey to) throws PersistentException {
    try {
      final IPaginatedIterable<IResult> results = malwareScanStateInfoRangeTable.batchLoad(fileId.getBytes(CHARSET),
          (Long.toString(instantSupplier.min().toEpochMilli()) + from).getBytes(CHARSET), (Long.toString(instantSupplier.now().toEpochMilli()) + to).getBytes(CHARSET));

      final List<MalwareScanStateInfo> malwareScanStateInfos = new ArrayList<>();
      for (IResult result : results) {
        malwareScanStateInfos.add(objectMapperSupplier.get().readValue(result.getPayload(), MalwareScanStateInfo.class));
      }

      return malwareScanStateInfos;
    } catch (IOException ioe) {
      if (ioe instanceof PersistentException) {
        throw (PersistentException) ioe;
      }
      throw new PersistentException(ioe, "Could not convert array of bytes to " + MalwareScanStateInfo.class.getSimpleName());
    }
  }

  @Getter
  @NoArgsConstructor
  @AllArgsConstructor
  public static final class RangeKey {
    private String streamId;
    private String messageId;

    @Override
    public String toString() {
      String string = "";
      if (streamId != null && streamId.length() > 0) {
        string += streamId;
      }
      if (messageId != null && messageId.length() > 0) {
        string += messageId;
      }
      if (string.length() > 0) {
        return "." + string;
      }
      return string;
    }
  }

}
