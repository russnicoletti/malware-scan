package com.symphony.malware.scan.persistence;

import com.symphony.circuitbreaker.CircuitBreakerConfig;
import com.symphony.circuitbreaker.CommandConfig;
import com.symphony.configuration.api.exception.ConfigurationException;
import com.symphony.configuration.api.exception.PropertyNotFoundException;
import com.symphony.configuration.api.store.IConfigurationStore;
import com.symphony.data.infrastructure.IPersistenceInfra;
import com.symphony.data.infrastructure.LightPersistenceLifecycle;
import com.symphony.healthchecks.indicators.AppsHealthStatus;

import com.google.common.collect.ImmutableMap;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;
import java.util.Optional;
import java.util.function.Supplier;

/**
 * Persistence factory which creates and manages a {@link IPersistenceInfra} lifecycle
 * As, usually we need only one instance of this provider it should be a singleton
 */
public class PersistenceInfraProvider implements Supplier<IPersistenceInfra> {

  private static final String POD_NAME_ZK_PATH = "pod/name";

  /**
   * System property which indicates which data storage to use
   * Should be aligned with the list of implementation strategies declared in {@link LightPersistenceLifecycle}
   * - {@value LightPersistenceLifecycle#BIG_TABLE_LEGACY}
   * - {@value LightPersistenceLifecycle#BIG_TABLE}
   * - {@value LightPersistenceLifecycle#HBASE}
   * - {@value LightPersistenceLifecycle#DYNAMODB}
   * If provided strategy is null, we fall back to {@value LightPersistenceLifecycle#HBASE} strategy
   * If provided strategy is not in the list mentioned above {@link LightPersistenceLifecycle} initialization will fail
   */
  private static final String DATA_STORAGE_PROPERTY_CONFIG = "data.storage";

  private static final String DATA_BIG_TABLE_LEGACY_COMMAND_CONFIG = "data.bigtable";
  private static final String DATA_BIG_TABLE_COMMAND_CONFIG = "data.gcp.bigtable";
  private static final String DATA_HBASE_COMMAND_CONFIG = "data.hbase";
  private static final String DATA_DYNAMO_COMMAND_CONFIG = "data.dynamo";

  private static final Map<String, String> DATA_COMMAND_CONFIG_MAPPING = ImmutableMap.of(
      LightPersistenceLifecycle.BIG_TABLE_LEGACY, DATA_BIG_TABLE_LEGACY_COMMAND_CONFIG,
      LightPersistenceLifecycle.BIG_TABLE, DATA_BIG_TABLE_COMMAND_CONFIG,
      LightPersistenceLifecycle.HBASE, DATA_HBASE_COMMAND_CONFIG,
      LightPersistenceLifecycle.DYNAMODB, DATA_DYNAMO_COMMAND_CONFIG
  );

  private final IPersistenceInfra persistenceInfra;

  public PersistenceInfraProvider(
      final IConfigurationStore configurationStore
  ) throws NoSuchMethodException, IllegalAccessException, InstantiationException, IOException,
      InvocationTargetException, ClassNotFoundException, ConfigurationException, PropertyNotFoundException {

    final String podName = configurationStore.getProperty(POD_NAME_ZK_PATH).getValue();
    final CircuitBreakerConfig circuitBreakerConfig = new CircuitBreakerConfig(podName, configurationStore);

    final String dataImplementationProperty = Optional.ofNullable(System.getProperty(DATA_STORAGE_PROPERTY_CONFIG))
        .orElse(LightPersistenceLifecycle.HBASE);

    final CommandConfig commandConfig = circuitBreakerConfig.getCommandConfig(
        DATA_COMMAND_CONFIG_MAPPING.getOrDefault(dataImplementationProperty, DATA_HBASE_COMMAND_CONFIG));

    final LightPersistenceLifecycle lightPersistenceLifecycle = new LightPersistenceLifecycle();
    lightPersistenceLifecycle.init(null, configurationStore, commandConfig, new AppsHealthStatus(), dataImplementationProperty);

    persistenceInfra = lightPersistenceLifecycle.getInfra();
  }

  public IPersistenceInfra get() {
    return persistenceInfra;
  }

}
