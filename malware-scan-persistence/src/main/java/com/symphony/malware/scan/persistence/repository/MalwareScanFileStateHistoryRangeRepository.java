package com.symphony.malware.scan.persistence.repository;

import com.symphony.data.infrastructure.IPersistenceInfra;
import com.symphony.data.mapper.IPaginatedIterable;
import com.symphony.data.mapper.IRangeTable;
import com.symphony.data.mapper.IResult;
import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.model.MalwareScanFileMapping;
import com.symphony.malware.scan.model.MalwareScanFileState;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.CharEncoding;
import util.TemporalSupplier;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

import javax.annotation.Nonnull;

/**
 * Keeps malware scan state history of the attachments, which were sent to malware scanner
 * Repository is ranged, which means that we can have multiple entries for particular file id
 * Ranged key for this repository is a timestamp of when entry was created
 */
@Slf4j
public class MalwareScanFileStateHistoryRangeRepository implements PersistenceRangeRepository<String, Long, MalwareScanFileState> {

  private static final Charset CHARSET = Charset.forName(CharEncoding.UTF_8);

  private static final String MALWARE_SCAN_FILE_STATE_HISTORY_TABLE = "malwareScanFileStateHistory";

  private final IRangeTable malwareScanFileStateHistoryRangeTable;
  private final TemporalSupplier<Long> timestampMillisSupplier;
  private final Supplier<ObjectMapper> objectMapperSupplier;

  public MalwareScanFileStateHistoryRangeRepository(final IPersistenceInfra persistenceInfra,
      final TemporalSupplier<Long> timestampMillisSupplier, final Supplier<ObjectMapper> objectMapperSupplier) throws PersistentException {

    this.malwareScanFileStateHistoryRangeTable = persistenceInfra.getRangeTable(MALWARE_SCAN_FILE_STATE_HISTORY_TABLE);
    this.timestampMillisSupplier = timestampMillisSupplier;
    this.objectMapperSupplier = objectMapperSupplier;
  }

  @Override
  public void save(@Nonnull final String fileId, @Nonnull final Long instantMillis, @Nonnull final MalwareScanFileState malwareScanFileState) throws PersistentException {
    try {
      malwareScanFileStateHistoryRangeTable.save(fileId.getBytes(CHARSET), Long.toString(instantMillis).getBytes(CHARSET),
          objectMapperSupplier.get().writeValueAsString(malwareScanFileState).getBytes(CHARSET));
    } catch (JsonProcessingException ioe) {
      throw new PersistentException(ioe, "Could not convert " + MalwareScanFileState.class.getSimpleName() + " to array of bytes");
    }
  }

  @Override
  public List<MalwareScanFileState> loadRange(@Nonnull final String fileId) throws PersistentException {
    return loadRange(fileId, timestampMillisSupplier.min());
  }

  @Override
  public List<MalwareScanFileState> loadRange(@Nonnull final String fileId, @Nonnull final Long fromMillis) throws PersistentException {
    return loadRange(fileId, fromMillis, timestampMillisSupplier.now());
  }

  @Override
  public List<MalwareScanFileState> loadRange(@Nonnull final String fileId, @Nonnull final Long fromMillis, @Nonnull final Long toMillis) throws PersistentException {
    try {
      final IPaginatedIterable<IResult> results = malwareScanFileStateHistoryRangeTable.batchLoad(fileId.getBytes(CHARSET),
          Long.toString(fromMillis).getBytes(CHARSET), Long.toString(toMillis).getBytes(CHARSET));

      final List<MalwareScanFileState> malwareScanFileStates = new ArrayList<>();
      for (IResult result : results) {
        malwareScanFileStates.add(objectMapperSupplier.get().readValue(result.getPayload(), MalwareScanFileState.class));
      }

      return malwareScanFileStates;
    } catch (PersistentException pe) {
      throw pe;
    } catch (IOException ioe) {
      throw new PersistentException(ioe, "Could not convert array of bytes to " + MalwareScanFileMapping.class.getSimpleName());
    }
  }

}
