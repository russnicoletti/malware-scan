package com.symphony.malware.scan.persistence.service;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.dto.MalwareInfo;
import com.symphony.malware.scan.dto.MalwareScanStateInfo;
import com.symphony.malware.scan.persistence.repository.MalwareScanStateInfoRangePersistenceRepository.RangeKey;
import com.symphony.malware.scan.persistence.repository.PersistenceRepository;
import com.symphony.malware.scan.persistence.repository.RangePersistenceRepository;

import com.google.common.collect.ImmutableSet;

import java.time.Instant;
import java.util.Optional;
import java.util.Set;

import javax.annotation.Nonnull;

public class MalwarePersistenceService {

  private final PersistenceRepository<String, MalwareInfo> malwareInfoPersistenceRepository;
  private final RangePersistenceRepository<String, Instant, MalwareInfo> malwareInfoHistoRangePersistenceRepository;
  private final RangePersistenceRepository<String, RangeKey, MalwareScanStateInfo> malwareScanStateInfoRangePersistenceRepository;

  private final Set<String> TERMINAL_STATUSES = ImmutableSet.of();

  public MalwarePersistenceService(
      final PersistenceRepository<String, MalwareInfo> malwareInfoPersistenceRepository,
      final RangePersistenceRepository<String, Instant, MalwareInfo> malwareInfoHistoRangePersistenceRepository,
      final RangePersistenceRepository<String, RangeKey, MalwareScanStateInfo> malwareScanStateInfoRangePersistenceRepository
  ) {
    this.malwareInfoPersistenceRepository = malwareInfoPersistenceRepository;
    this.malwareInfoHistoRangePersistenceRepository = malwareInfoHistoRangePersistenceRepository;
    this.malwareScanStateInfoRangePersistenceRepository = malwareScanStateInfoRangePersistenceRepository;
  }

  public void putMalwareInfo(
      @Nonnull final String fileId, @Nonnull final String streamId, @Nonnull final String messageId,
      @Nonnull final MalwareInfo malwareInfo, @Nonnull final String actor
  ) throws PersistentException {
    final MalwareInfo updatedMalwareInfo = malwareInfoPersistenceRepository.load(fileId).map(existingMalwareInfo -> {
      // TODO Need to update existing malware info with new values here
      return existingMalwareInfo;
    }).orElse(malwareInfo);

    malwareInfoPersistenceRepository.save(fileId, updatedMalwareInfo);
    malwareInfoHistoRangePersistenceRepository.save(fileId, Instant.now(), malwareInfo);
  }

  public Optional<MalwareInfo> getMalwareInfo(@Nonnull final String fileId) throws PersistentException {
    return malwareInfoPersistenceRepository.load(fileId);
  }
}
