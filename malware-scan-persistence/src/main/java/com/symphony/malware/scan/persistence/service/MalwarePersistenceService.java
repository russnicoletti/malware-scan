package com.symphony.malware.scan.persistence.service;

import static com.symphony.malware.scan.dto.MalwareScanState.Status;

import com.symphony.data.mapper.PersistentException;
import com.symphony.malware.scan.dto.Actor;
import com.symphony.malware.scan.dto.MalwareScanState;
import com.symphony.malware.scan.dto.MalwareScanMapping;
import com.symphony.malware.scan.persistence.exception.MalwareScanUpdateException;
import com.symphony.malware.scan.persistence.repository.MalwareScanMappingRangePersistenceRepository.RangeKey;
import com.symphony.malware.scan.persistence.repository.PersistenceRepository;
import com.symphony.malware.scan.persistence.repository.RangePersistenceRepository;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import util.TemporalSupplier;

import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;

public class MalwarePersistenceService {

  /**
   * These are statuses, which are allowed for {@link Actor#SYMPHONY} actor
   */
  private static final Set<Status> SYMPHONY_ALLOWED_STATUSES = ImmutableSet.of(
      Status.PENDING, Status.SUBMITTED, Status.FAILED_SUBMIT, Status.FAILED_RETRY, Status.OK_DISABLED
  );

  /**
   * These are statuses, which are allowed for {@link Actor#MALWARE_SCANNER} actor
   */
  private static final Set<Status> MALWARE_SCANNER_ALLOWED_STATUSES = ImmutableSet.of(
      Status.OK, Status.BAD, Status.UNSCANNABLE, Status.EXPIRED
  );

  /**
   * List of allowed status transitions
   */
  private static final Map<Status, Set<Status>> ALLOWED_STATUS_TRANSITIONS = ImmutableMap.<Status, Set<Status>>builder()
      .put(Status.PENDING, ImmutableSet.of(Status.FAILED_SUBMIT, Status.FAILED_RETRY, Status.SUBMITTED, Status.OK, Status.BAD, Status.UNSCANNABLE))
      .put(Status.OK, ImmutableSet.of(Status.PENDING, Status.EXPIRED))
      .put(Status.BAD, ImmutableSet.of(Status.PENDING, Status.EXPIRED))
      .put(Status.UNSCANNABLE, ImmutableSet.of(Status.PENDING, Status.EXPIRED))
      .put(Status.SUBMITTED, ImmutableSet.of(Status.OK, Status.BAD, Status.UNSCANNABLE))
      .put(Status.FAILED_SUBMIT, ImmutableSet.of(Status.FAILED_RETRY, Status.SUBMITTED))
      .build();

  private final PersistenceRepository<String, MalwareScanState> malwareScanStatePersistenceRepository;
  private final RangePersistenceRepository<String, Instant, MalwareScanState> malwareScanStateHistoRangePersistenceRepository;
  private final RangePersistenceRepository<String, RangeKey, MalwareScanMapping> malwareScanMappingRangePersistenceRepository;
  private final TemporalSupplier<Instant> instantSupplier;

  public MalwarePersistenceService(
      final PersistenceRepository<String, MalwareScanState> malwareScanStatePersistenceRepository,
      final RangePersistenceRepository<String, Instant, MalwareScanState> malwareScanStateHistoRangePersistenceRepository,
      final RangePersistenceRepository<String, RangeKey, MalwareScanMapping> malwareScanMappingRangePersistenceRepository,
      final TemporalSupplier<Instant> instantSupplier
  ) {
    this.malwareScanStatePersistenceRepository = malwareScanStatePersistenceRepository;
    this.malwareScanStateHistoRangePersistenceRepository = malwareScanStateHistoRangePersistenceRepository;
    this.malwareScanMappingRangePersistenceRepository = malwareScanMappingRangePersistenceRepository;
    this.instantSupplier = instantSupplier;
  }

  public void putMalwareScanState(@Nonnull final MalwareScanState newMalwareScanState, @Nonnull final Actor actor) throws PersistentException, MalwareScanUpdateException {
    final MalwareScanState existingMalwareScanState = malwareScanStatePersistenceRepository.load(newMalwareScanState.getFileId());

    if (Actor.SYMPHONY.equals(actor) && !SYMPHONY_ALLOWED_STATUSES.contains(newMalwareScanState.getStatus())) {
      throw new MalwareScanUpdateException("Transfer to " + newMalwareScanState.getStatus() + " status is not allowed for " + actor + " actor");
    }

    if (Actor.MALWARE_SCANNER.equals(actor) && !MALWARE_SCANNER_ALLOWED_STATUSES.contains(newMalwareScanState.getStatus())) {
      throw new MalwareScanUpdateException("Transfer to " + newMalwareScanState.getStatus() + " status is not allowed for " + actor + " actor");
    }

    MalwareScanState mergedMalwareScanState;
    if (existingMalwareScanState == null) {
      mergedMalwareScanState = newMalwareScanState.toBuilder()
          .createTimestamp(instantSupplier.now())
          .createdBy(actor)
          .lastUpdateTimestamp(instantSupplier.now())
          .lastUpdatedBy(actor)
          .build();
    } else {
      if (!ALLOWED_STATUS_TRANSITIONS.getOrDefault(existingMalwareScanState.getStatus(), ImmutableSet.of()).contains(newMalwareScanState.getStatus())) {
        throw new MalwareScanUpdateException("Transfer from " + existingMalwareScanState.getStatus() + " status to "
            + newMalwareScanState.getStatus() + " status is not allowed");
      }

      mergedMalwareScanState = existingMalwareScanState.toBuilder()
          .status(newMalwareScanState.getStatus())
          .ttl(newMalwareScanState.getTtl())
          .lastUpdateTimestamp(instantSupplier.now())
          .lastUpdatedBy(actor)
          .build();
    }

    malwareScanStatePersistenceRepository.save(mergedMalwareScanState.getFileId(), mergedMalwareScanState);
    malwareScanStateHistoRangePersistenceRepository.save(mergedMalwareScanState.getFileId(), instantSupplier.now(), mergedMalwareScanState);
  }

  public Optional<MalwareScanState> getMalwareScanState(@Nonnull final String fileId) throws PersistentException {
    return Optional.ofNullable(malwareScanStatePersistenceRepository.load(fileId));
  }

  public List<MalwareScanState> getMalwareScanStates(@Nonnull final String fileId) throws PersistentException {
    return malwareScanStateHistoRangePersistenceRepository.loadRange(fileId);
  }

  public List<MalwareScanState> getMalwareScanStates(@Nonnull final String fileId, @Nonnull final Instant from) throws PersistentException {
    return malwareScanStateHistoRangePersistenceRepository.loadRange(fileId, from, instantSupplier.now());
  }

  public List<MalwareScanState> getMalwareScanStates(@Nonnull final String fileId, @Nonnull final Instant from, @Nonnull final Instant to) throws PersistentException {
    return malwareScanStateHistoRangePersistenceRepository.loadRange(fileId, from, to);
  }

  public void putMalwareScanMapping(@Nonnull final MalwareScanMapping malwareScanMapping) throws PersistentException {
    malwareScanMappingRangePersistenceRepository.save(malwareScanMapping.getFileId(),
        new RangeKey(malwareScanMapping.getStreamId(), malwareScanMapping.getMessageId()), malwareScanMapping);
  }

  public List<MalwareScanMapping> getMalwareScanMapping(
      @Nonnull final String fileId, @Nonnull final String streamId, @Nonnull final String messageId
  ) throws PersistentException {
    return malwareScanMappingRangePersistenceRepository.loadRange(fileId).stream()
        .filter(mssi -> streamId.equals(mssi.getStreamId())).filter(mssi -> messageId.equals(mssi.getMessageId())).collect(Collectors.toList());
  }
}
